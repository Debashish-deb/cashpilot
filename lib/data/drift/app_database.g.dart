// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'app_database.dart';

// ignore_for_file: type=lint
class $UsersTable extends Users with TableInfo<$UsersTable, User> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UsersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
    'email',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
  );
  static const VerificationMeta _languagePreferenceMeta =
      const VerificationMeta('languagePreference');
  @override
  late final GeneratedColumn<String> languagePreference =
      GeneratedColumn<String>(
        'language_preference',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
        defaultValue: const Constant('en'),
      );
  static const VerificationMeta _avatarUrlMeta = const VerificationMeta(
    'avatarUrl',
  );
  @override
  late final GeneratedColumn<String> avatarUrl = GeneratedColumn<String>(
    'avatar_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _subscriptionTierMeta = const VerificationMeta(
    'subscriptionTier',
  );
  @override
  late final GeneratedColumn<String> subscriptionTier = GeneratedColumn<String>(
    'subscription_tier',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('free'),
  );
  static const VerificationMeta _subscriptionStatusMeta =
      const VerificationMeta('subscriptionStatus');
  @override
  late final GeneratedColumn<String> subscriptionStatus =
      GeneratedColumn<String>(
        'subscription_status',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
        defaultValue: const Constant('active'),
      );
  static const VerificationMeta _trialStartedAtMeta = const VerificationMeta(
    'trialStartedAt',
  );
  @override
  late final GeneratedColumn<DateTime> trialStartedAt =
      GeneratedColumn<DateTime>(
        'trial_started_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _trialExpiresAtMeta = const VerificationMeta(
    'trialExpiresAt',
  );
  @override
  late final GeneratedColumn<DateTime> trialExpiresAt =
      GeneratedColumn<DateTime>(
        'trial_expires_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _subscriptionExpiresAtMeta =
      const VerificationMeta('subscriptionExpiresAt');
  @override
  late final GeneratedColumn<DateTime> subscriptionExpiresAt =
      GeneratedColumn<DateTime>(
        'subscription_expires_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _lastPaymentDateMeta = const VerificationMeta(
    'lastPaymentDate',
  );
  @override
  late final GeneratedColumn<DateTime> lastPaymentDate =
      GeneratedColumn<DateTime>(
        'last_payment_date',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _paymentProviderMeta = const VerificationMeta(
    'paymentProvider',
  );
  @override
  late final GeneratedColumn<String> paymentProvider = GeneratedColumn<String>(
    'payment_provider',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _paymentProviderIdMeta = const VerificationMeta(
    'paymentProviderId',
  );
  @override
  late final GeneratedColumn<String> paymentProviderId =
      GeneratedColumn<String>(
        'payment_provider_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _ocrUsageCountMeta = const VerificationMeta(
    'ocrUsageCount',
  );
  @override
  late final GeneratedColumn<int> ocrUsageCount = GeneratedColumn<int>(
    'ocr_usage_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _ocrUsageResetAtMeta = const VerificationMeta(
    'ocrUsageResetAt',
  );
  @override
  late final GeneratedColumn<DateTime> ocrUsageResetAt =
      GeneratedColumn<DateTime>(
        'ocr_usage_reset_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _experienceModeMeta = const VerificationMeta(
    'experienceMode',
  );
  @override
  late final GeneratedColumn<String> experienceMode = GeneratedColumn<String>(
    'experience_mode',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('beginner'),
  );
  static const VerificationMeta _roleMeta = const VerificationMeta('role');
  @override
  late final GeneratedColumn<String> role = GeneratedColumn<String>(
    'role',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('user'),
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata = GeneratedColumn<String>(
    'metadata',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Map<String, dynamic>?>($UsersTable.$convertermetadatan);
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _baseRevisionMeta = const VerificationMeta(
    'baseRevision',
  );
  @override
  late final GeneratedColumn<int> baseRevision = GeneratedColumn<int>(
    'base_revision',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _operationIdMeta = const VerificationMeta(
    'operationId',
  );
  @override
  late final GeneratedColumn<String> operationId = GeneratedColumn<String>(
    'operation_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastModifiedByDeviceIdMeta =
      const VerificationMeta('lastModifiedByDeviceId');
  @override
  late final GeneratedColumn<String> lastModifiedByDeviceId =
      GeneratedColumn<String>(
        'last_modified_by_device_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    email,
    languagePreference,
    avatarUrl,
    subscriptionTier,
    subscriptionStatus,
    trialStartedAt,
    trialExpiresAt,
    subscriptionExpiresAt,
    lastPaymentDate,
    paymentProvider,
    paymentProviderId,
    ocrUsageCount,
    ocrUsageResetAt,
    experienceMode,
    role,
    metadata,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    isDeleted,
    syncState,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'users';
  @override
  VerificationContext validateIntegrity(
    Insertable<User> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('email')) {
      context.handle(
        _emailMeta,
        email.isAcceptableOrUnknown(data['email']!, _emailMeta),
      );
    } else if (isInserting) {
      context.missing(_emailMeta);
    }
    if (data.containsKey('language_preference')) {
      context.handle(
        _languagePreferenceMeta,
        languagePreference.isAcceptableOrUnknown(
          data['language_preference']!,
          _languagePreferenceMeta,
        ),
      );
    }
    if (data.containsKey('avatar_url')) {
      context.handle(
        _avatarUrlMeta,
        avatarUrl.isAcceptableOrUnknown(data['avatar_url']!, _avatarUrlMeta),
      );
    }
    if (data.containsKey('subscription_tier')) {
      context.handle(
        _subscriptionTierMeta,
        subscriptionTier.isAcceptableOrUnknown(
          data['subscription_tier']!,
          _subscriptionTierMeta,
        ),
      );
    }
    if (data.containsKey('subscription_status')) {
      context.handle(
        _subscriptionStatusMeta,
        subscriptionStatus.isAcceptableOrUnknown(
          data['subscription_status']!,
          _subscriptionStatusMeta,
        ),
      );
    }
    if (data.containsKey('trial_started_at')) {
      context.handle(
        _trialStartedAtMeta,
        trialStartedAt.isAcceptableOrUnknown(
          data['trial_started_at']!,
          _trialStartedAtMeta,
        ),
      );
    }
    if (data.containsKey('trial_expires_at')) {
      context.handle(
        _trialExpiresAtMeta,
        trialExpiresAt.isAcceptableOrUnknown(
          data['trial_expires_at']!,
          _trialExpiresAtMeta,
        ),
      );
    }
    if (data.containsKey('subscription_expires_at')) {
      context.handle(
        _subscriptionExpiresAtMeta,
        subscriptionExpiresAt.isAcceptableOrUnknown(
          data['subscription_expires_at']!,
          _subscriptionExpiresAtMeta,
        ),
      );
    }
    if (data.containsKey('last_payment_date')) {
      context.handle(
        _lastPaymentDateMeta,
        lastPaymentDate.isAcceptableOrUnknown(
          data['last_payment_date']!,
          _lastPaymentDateMeta,
        ),
      );
    }
    if (data.containsKey('payment_provider')) {
      context.handle(
        _paymentProviderMeta,
        paymentProvider.isAcceptableOrUnknown(
          data['payment_provider']!,
          _paymentProviderMeta,
        ),
      );
    }
    if (data.containsKey('payment_provider_id')) {
      context.handle(
        _paymentProviderIdMeta,
        paymentProviderId.isAcceptableOrUnknown(
          data['payment_provider_id']!,
          _paymentProviderIdMeta,
        ),
      );
    }
    if (data.containsKey('ocr_usage_count')) {
      context.handle(
        _ocrUsageCountMeta,
        ocrUsageCount.isAcceptableOrUnknown(
          data['ocr_usage_count']!,
          _ocrUsageCountMeta,
        ),
      );
    }
    if (data.containsKey('ocr_usage_reset_at')) {
      context.handle(
        _ocrUsageResetAtMeta,
        ocrUsageResetAt.isAcceptableOrUnknown(
          data['ocr_usage_reset_at']!,
          _ocrUsageResetAtMeta,
        ),
      );
    }
    if (data.containsKey('experience_mode')) {
      context.handle(
        _experienceModeMeta,
        experienceMode.isAcceptableOrUnknown(
          data['experience_mode']!,
          _experienceModeMeta,
        ),
      );
    }
    if (data.containsKey('role')) {
      context.handle(
        _roleMeta,
        role.isAcceptableOrUnknown(data['role']!, _roleMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('base_revision')) {
      context.handle(
        _baseRevisionMeta,
        baseRevision.isAcceptableOrUnknown(
          data['base_revision']!,
          _baseRevisionMeta,
        ),
      );
    }
    if (data.containsKey('operation_id')) {
      context.handle(
        _operationIdMeta,
        operationId.isAcceptableOrUnknown(
          data['operation_id']!,
          _operationIdMeta,
        ),
      );
    }
    if (data.containsKey('last_modified_by_device_id')) {
      context.handle(
        _lastModifiedByDeviceIdMeta,
        lastModifiedByDeviceId.isAcceptableOrUnknown(
          data['last_modified_by_device_id']!,
          _lastModifiedByDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  User map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return User(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      email: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}email'],
      )!,
      languagePreference: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}language_preference'],
      )!,
      avatarUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}avatar_url'],
      ),
      subscriptionTier: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}subscription_tier'],
      )!,
      subscriptionStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}subscription_status'],
      )!,
      trialStartedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}trial_started_at'],
      ),
      trialExpiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}trial_expires_at'],
      ),
      subscriptionExpiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}subscription_expires_at'],
      ),
      lastPaymentDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_payment_date'],
      ),
      paymentProvider: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payment_provider'],
      ),
      paymentProviderId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payment_provider_id'],
      ),
      ocrUsageCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}ocr_usage_count'],
      )!,
      ocrUsageResetAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}ocr_usage_reset_at'],
      ),
      experienceMode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}experience_mode'],
      )!,
      role: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}role'],
      )!,
      metadata: $UsersTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      baseRevision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}base_revision'],
      ),
      operationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation_id'],
      ),
      lastModifiedByDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_modified_by_device_id'],
      ),
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $UsersTable createAlias(String alias) {
    return $UsersTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class User extends DataClass implements Insertable<User> {
  final String id;
  final String name;
  final String email;
  final String languagePreference;
  final String? avatarUrl;
  final String subscriptionTier;
  final String subscriptionStatus;
  final DateTime? trialStartedAt;
  final DateTime? trialExpiresAt;
  final DateTime? subscriptionExpiresAt;
  final DateTime? lastPaymentDate;
  final String? paymentProvider;
  final String? paymentProviderId;
  final int ocrUsageCount;
  final DateTime? ocrUsageResetAt;
  final String experienceMode;
  final String role;
  final Map<String, dynamic>? metadata;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final int? baseRevision;
  final String? operationId;
  final String? lastModifiedByDeviceId;
  final bool isDeleted;
  final String syncState;
  final int lamportClock;
  final String? versionVector;
  const User({
    required this.id,
    required this.name,
    required this.email,
    required this.languagePreference,
    this.avatarUrl,
    required this.subscriptionTier,
    required this.subscriptionStatus,
    this.trialStartedAt,
    this.trialExpiresAt,
    this.subscriptionExpiresAt,
    this.lastPaymentDate,
    this.paymentProvider,
    this.paymentProviderId,
    required this.ocrUsageCount,
    this.ocrUsageResetAt,
    required this.experienceMode,
    required this.role,
    this.metadata,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    this.baseRevision,
    this.operationId,
    this.lastModifiedByDeviceId,
    required this.isDeleted,
    required this.syncState,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    map['email'] = Variable<String>(email);
    map['language_preference'] = Variable<String>(languagePreference);
    if (!nullToAbsent || avatarUrl != null) {
      map['avatar_url'] = Variable<String>(avatarUrl);
    }
    map['subscription_tier'] = Variable<String>(subscriptionTier);
    map['subscription_status'] = Variable<String>(subscriptionStatus);
    if (!nullToAbsent || trialStartedAt != null) {
      map['trial_started_at'] = Variable<DateTime>(trialStartedAt);
    }
    if (!nullToAbsent || trialExpiresAt != null) {
      map['trial_expires_at'] = Variable<DateTime>(trialExpiresAt);
    }
    if (!nullToAbsent || subscriptionExpiresAt != null) {
      map['subscription_expires_at'] = Variable<DateTime>(
        subscriptionExpiresAt,
      );
    }
    if (!nullToAbsent || lastPaymentDate != null) {
      map['last_payment_date'] = Variable<DateTime>(lastPaymentDate);
    }
    if (!nullToAbsent || paymentProvider != null) {
      map['payment_provider'] = Variable<String>(paymentProvider);
    }
    if (!nullToAbsent || paymentProviderId != null) {
      map['payment_provider_id'] = Variable<String>(paymentProviderId);
    }
    map['ocr_usage_count'] = Variable<int>(ocrUsageCount);
    if (!nullToAbsent || ocrUsageResetAt != null) {
      map['ocr_usage_reset_at'] = Variable<DateTime>(ocrUsageResetAt);
    }
    map['experience_mode'] = Variable<String>(experienceMode);
    map['role'] = Variable<String>(role);
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $UsersTable.$convertermetadatan.toSql(metadata),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    if (!nullToAbsent || baseRevision != null) {
      map['base_revision'] = Variable<int>(baseRevision);
    }
    if (!nullToAbsent || operationId != null) {
      map['operation_id'] = Variable<String>(operationId);
    }
    if (!nullToAbsent || lastModifiedByDeviceId != null) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId,
      );
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['sync_state'] = Variable<String>(syncState);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  UsersCompanion toCompanion(bool nullToAbsent) {
    return UsersCompanion(
      id: Value(id),
      name: Value(name),
      email: Value(email),
      languagePreference: Value(languagePreference),
      avatarUrl: avatarUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(avatarUrl),
      subscriptionTier: Value(subscriptionTier),
      subscriptionStatus: Value(subscriptionStatus),
      trialStartedAt: trialStartedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(trialStartedAt),
      trialExpiresAt: trialExpiresAt == null && nullToAbsent
          ? const Value.absent()
          : Value(trialExpiresAt),
      subscriptionExpiresAt: subscriptionExpiresAt == null && nullToAbsent
          ? const Value.absent()
          : Value(subscriptionExpiresAt),
      lastPaymentDate: lastPaymentDate == null && nullToAbsent
          ? const Value.absent()
          : Value(lastPaymentDate),
      paymentProvider: paymentProvider == null && nullToAbsent
          ? const Value.absent()
          : Value(paymentProvider),
      paymentProviderId: paymentProviderId == null && nullToAbsent
          ? const Value.absent()
          : Value(paymentProviderId),
      ocrUsageCount: Value(ocrUsageCount),
      ocrUsageResetAt: ocrUsageResetAt == null && nullToAbsent
          ? const Value.absent()
          : Value(ocrUsageResetAt),
      experienceMode: Value(experienceMode),
      role: Value(role),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      baseRevision: baseRevision == null && nullToAbsent
          ? const Value.absent()
          : Value(baseRevision),
      operationId: operationId == null && nullToAbsent
          ? const Value.absent()
          : Value(operationId),
      lastModifiedByDeviceId: lastModifiedByDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedByDeviceId),
      isDeleted: Value(isDeleted),
      syncState: Value(syncState),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory User.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return User(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      email: serializer.fromJson<String>(json['email']),
      languagePreference: serializer.fromJson<String>(
        json['languagePreference'],
      ),
      avatarUrl: serializer.fromJson<String?>(json['avatarUrl']),
      subscriptionTier: serializer.fromJson<String>(json['subscriptionTier']),
      subscriptionStatus: serializer.fromJson<String>(
        json['subscriptionStatus'],
      ),
      trialStartedAt: serializer.fromJson<DateTime?>(json['trialStartedAt']),
      trialExpiresAt: serializer.fromJson<DateTime?>(json['trialExpiresAt']),
      subscriptionExpiresAt: serializer.fromJson<DateTime?>(
        json['subscriptionExpiresAt'],
      ),
      lastPaymentDate: serializer.fromJson<DateTime?>(json['lastPaymentDate']),
      paymentProvider: serializer.fromJson<String?>(json['paymentProvider']),
      paymentProviderId: serializer.fromJson<String?>(
        json['paymentProviderId'],
      ),
      ocrUsageCount: serializer.fromJson<int>(json['ocrUsageCount']),
      ocrUsageResetAt: serializer.fromJson<DateTime?>(json['ocrUsageResetAt']),
      experienceMode: serializer.fromJson<String>(json['experienceMode']),
      role: serializer.fromJson<String>(json['role']),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      baseRevision: serializer.fromJson<int?>(json['baseRevision']),
      operationId: serializer.fromJson<String?>(json['operationId']),
      lastModifiedByDeviceId: serializer.fromJson<String?>(
        json['lastModifiedByDeviceId'],
      ),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncState: serializer.fromJson<String>(json['syncState']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'email': serializer.toJson<String>(email),
      'languagePreference': serializer.toJson<String>(languagePreference),
      'avatarUrl': serializer.toJson<String?>(avatarUrl),
      'subscriptionTier': serializer.toJson<String>(subscriptionTier),
      'subscriptionStatus': serializer.toJson<String>(subscriptionStatus),
      'trialStartedAt': serializer.toJson<DateTime?>(trialStartedAt),
      'trialExpiresAt': serializer.toJson<DateTime?>(trialExpiresAt),
      'subscriptionExpiresAt': serializer.toJson<DateTime?>(
        subscriptionExpiresAt,
      ),
      'lastPaymentDate': serializer.toJson<DateTime?>(lastPaymentDate),
      'paymentProvider': serializer.toJson<String?>(paymentProvider),
      'paymentProviderId': serializer.toJson<String?>(paymentProviderId),
      'ocrUsageCount': serializer.toJson<int>(ocrUsageCount),
      'ocrUsageResetAt': serializer.toJson<DateTime?>(ocrUsageResetAt),
      'experienceMode': serializer.toJson<String>(experienceMode),
      'role': serializer.toJson<String>(role),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'baseRevision': serializer.toJson<int?>(baseRevision),
      'operationId': serializer.toJson<String?>(operationId),
      'lastModifiedByDeviceId': serializer.toJson<String?>(
        lastModifiedByDeviceId,
      ),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncState': serializer.toJson<String>(syncState),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  User copyWith({
    String? id,
    String? name,
    String? email,
    String? languagePreference,
    Value<String?> avatarUrl = const Value.absent(),
    String? subscriptionTier,
    String? subscriptionStatus,
    Value<DateTime?> trialStartedAt = const Value.absent(),
    Value<DateTime?> trialExpiresAt = const Value.absent(),
    Value<DateTime?> subscriptionExpiresAt = const Value.absent(),
    Value<DateTime?> lastPaymentDate = const Value.absent(),
    Value<String?> paymentProvider = const Value.absent(),
    Value<String?> paymentProviderId = const Value.absent(),
    int? ocrUsageCount,
    Value<DateTime?> ocrUsageResetAt = const Value.absent(),
    String? experienceMode,
    String? role,
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    Value<int?> baseRevision = const Value.absent(),
    Value<String?> operationId = const Value.absent(),
    Value<String?> lastModifiedByDeviceId = const Value.absent(),
    bool? isDeleted,
    String? syncState,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => User(
    id: id ?? this.id,
    name: name ?? this.name,
    email: email ?? this.email,
    languagePreference: languagePreference ?? this.languagePreference,
    avatarUrl: avatarUrl.present ? avatarUrl.value : this.avatarUrl,
    subscriptionTier: subscriptionTier ?? this.subscriptionTier,
    subscriptionStatus: subscriptionStatus ?? this.subscriptionStatus,
    trialStartedAt: trialStartedAt.present
        ? trialStartedAt.value
        : this.trialStartedAt,
    trialExpiresAt: trialExpiresAt.present
        ? trialExpiresAt.value
        : this.trialExpiresAt,
    subscriptionExpiresAt: subscriptionExpiresAt.present
        ? subscriptionExpiresAt.value
        : this.subscriptionExpiresAt,
    lastPaymentDate: lastPaymentDate.present
        ? lastPaymentDate.value
        : this.lastPaymentDate,
    paymentProvider: paymentProvider.present
        ? paymentProvider.value
        : this.paymentProvider,
    paymentProviderId: paymentProviderId.present
        ? paymentProviderId.value
        : this.paymentProviderId,
    ocrUsageCount: ocrUsageCount ?? this.ocrUsageCount,
    ocrUsageResetAt: ocrUsageResetAt.present
        ? ocrUsageResetAt.value
        : this.ocrUsageResetAt,
    experienceMode: experienceMode ?? this.experienceMode,
    role: role ?? this.role,
    metadata: metadata.present ? metadata.value : this.metadata,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    baseRevision: baseRevision.present ? baseRevision.value : this.baseRevision,
    operationId: operationId.present ? operationId.value : this.operationId,
    lastModifiedByDeviceId: lastModifiedByDeviceId.present
        ? lastModifiedByDeviceId.value
        : this.lastModifiedByDeviceId,
    isDeleted: isDeleted ?? this.isDeleted,
    syncState: syncState ?? this.syncState,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  User copyWithCompanion(UsersCompanion data) {
    return User(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      email: data.email.present ? data.email.value : this.email,
      languagePreference: data.languagePreference.present
          ? data.languagePreference.value
          : this.languagePreference,
      avatarUrl: data.avatarUrl.present ? data.avatarUrl.value : this.avatarUrl,
      subscriptionTier: data.subscriptionTier.present
          ? data.subscriptionTier.value
          : this.subscriptionTier,
      subscriptionStatus: data.subscriptionStatus.present
          ? data.subscriptionStatus.value
          : this.subscriptionStatus,
      trialStartedAt: data.trialStartedAt.present
          ? data.trialStartedAt.value
          : this.trialStartedAt,
      trialExpiresAt: data.trialExpiresAt.present
          ? data.trialExpiresAt.value
          : this.trialExpiresAt,
      subscriptionExpiresAt: data.subscriptionExpiresAt.present
          ? data.subscriptionExpiresAt.value
          : this.subscriptionExpiresAt,
      lastPaymentDate: data.lastPaymentDate.present
          ? data.lastPaymentDate.value
          : this.lastPaymentDate,
      paymentProvider: data.paymentProvider.present
          ? data.paymentProvider.value
          : this.paymentProvider,
      paymentProviderId: data.paymentProviderId.present
          ? data.paymentProviderId.value
          : this.paymentProviderId,
      ocrUsageCount: data.ocrUsageCount.present
          ? data.ocrUsageCount.value
          : this.ocrUsageCount,
      ocrUsageResetAt: data.ocrUsageResetAt.present
          ? data.ocrUsageResetAt.value
          : this.ocrUsageResetAt,
      experienceMode: data.experienceMode.present
          ? data.experienceMode.value
          : this.experienceMode,
      role: data.role.present ? data.role.value : this.role,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      baseRevision: data.baseRevision.present
          ? data.baseRevision.value
          : this.baseRevision,
      operationId: data.operationId.present
          ? data.operationId.value
          : this.operationId,
      lastModifiedByDeviceId: data.lastModifiedByDeviceId.present
          ? data.lastModifiedByDeviceId.value
          : this.lastModifiedByDeviceId,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('User(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('email: $email, ')
          ..write('languagePreference: $languagePreference, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('subscriptionTier: $subscriptionTier, ')
          ..write('subscriptionStatus: $subscriptionStatus, ')
          ..write('trialStartedAt: $trialStartedAt, ')
          ..write('trialExpiresAt: $trialExpiresAt, ')
          ..write('subscriptionExpiresAt: $subscriptionExpiresAt, ')
          ..write('lastPaymentDate: $lastPaymentDate, ')
          ..write('paymentProvider: $paymentProvider, ')
          ..write('paymentProviderId: $paymentProviderId, ')
          ..write('ocrUsageCount: $ocrUsageCount, ')
          ..write('ocrUsageResetAt: $ocrUsageResetAt, ')
          ..write('experienceMode: $experienceMode, ')
          ..write('role: $role, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    name,
    email,
    languagePreference,
    avatarUrl,
    subscriptionTier,
    subscriptionStatus,
    trialStartedAt,
    trialExpiresAt,
    subscriptionExpiresAt,
    lastPaymentDate,
    paymentProvider,
    paymentProviderId,
    ocrUsageCount,
    ocrUsageResetAt,
    experienceMode,
    role,
    metadata,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    isDeleted,
    syncState,
    lamportClock,
    versionVector,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is User &&
          other.id == this.id &&
          other.name == this.name &&
          other.email == this.email &&
          other.languagePreference == this.languagePreference &&
          other.avatarUrl == this.avatarUrl &&
          other.subscriptionTier == this.subscriptionTier &&
          other.subscriptionStatus == this.subscriptionStatus &&
          other.trialStartedAt == this.trialStartedAt &&
          other.trialExpiresAt == this.trialExpiresAt &&
          other.subscriptionExpiresAt == this.subscriptionExpiresAt &&
          other.lastPaymentDate == this.lastPaymentDate &&
          other.paymentProvider == this.paymentProvider &&
          other.paymentProviderId == this.paymentProviderId &&
          other.ocrUsageCount == this.ocrUsageCount &&
          other.ocrUsageResetAt == this.ocrUsageResetAt &&
          other.experienceMode == this.experienceMode &&
          other.role == this.role &&
          other.metadata == this.metadata &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.baseRevision == this.baseRevision &&
          other.operationId == this.operationId &&
          other.lastModifiedByDeviceId == this.lastModifiedByDeviceId &&
          other.isDeleted == this.isDeleted &&
          other.syncState == this.syncState &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class UsersCompanion extends UpdateCompanion<User> {
  final Value<String> id;
  final Value<String> name;
  final Value<String> email;
  final Value<String> languagePreference;
  final Value<String?> avatarUrl;
  final Value<String> subscriptionTier;
  final Value<String> subscriptionStatus;
  final Value<DateTime?> trialStartedAt;
  final Value<DateTime?> trialExpiresAt;
  final Value<DateTime?> subscriptionExpiresAt;
  final Value<DateTime?> lastPaymentDate;
  final Value<String?> paymentProvider;
  final Value<String?> paymentProviderId;
  final Value<int> ocrUsageCount;
  final Value<DateTime?> ocrUsageResetAt;
  final Value<String> experienceMode;
  final Value<String> role;
  final Value<Map<String, dynamic>?> metadata;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<int?> baseRevision;
  final Value<String?> operationId;
  final Value<String?> lastModifiedByDeviceId;
  final Value<bool> isDeleted;
  final Value<String> syncState;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const UsersCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.email = const Value.absent(),
    this.languagePreference = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.subscriptionTier = const Value.absent(),
    this.subscriptionStatus = const Value.absent(),
    this.trialStartedAt = const Value.absent(),
    this.trialExpiresAt = const Value.absent(),
    this.subscriptionExpiresAt = const Value.absent(),
    this.lastPaymentDate = const Value.absent(),
    this.paymentProvider = const Value.absent(),
    this.paymentProviderId = const Value.absent(),
    this.ocrUsageCount = const Value.absent(),
    this.ocrUsageResetAt = const Value.absent(),
    this.experienceMode = const Value.absent(),
    this.role = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UsersCompanion.insert({
    required String id,
    required String name,
    required String email,
    this.languagePreference = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.subscriptionTier = const Value.absent(),
    this.subscriptionStatus = const Value.absent(),
    this.trialStartedAt = const Value.absent(),
    this.trialExpiresAt = const Value.absent(),
    this.subscriptionExpiresAt = const Value.absent(),
    this.lastPaymentDate = const Value.absent(),
    this.paymentProvider = const Value.absent(),
    this.paymentProviderId = const Value.absent(),
    this.ocrUsageCount = const Value.absent(),
    this.ocrUsageResetAt = const Value.absent(),
    this.experienceMode = const Value.absent(),
    this.role = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name),
       email = Value(email);
  static Insertable<User> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? email,
    Expression<String>? languagePreference,
    Expression<String>? avatarUrl,
    Expression<String>? subscriptionTier,
    Expression<String>? subscriptionStatus,
    Expression<DateTime>? trialStartedAt,
    Expression<DateTime>? trialExpiresAt,
    Expression<DateTime>? subscriptionExpiresAt,
    Expression<DateTime>? lastPaymentDate,
    Expression<String>? paymentProvider,
    Expression<String>? paymentProviderId,
    Expression<int>? ocrUsageCount,
    Expression<DateTime>? ocrUsageResetAt,
    Expression<String>? experienceMode,
    Expression<String>? role,
    Expression<String>? metadata,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<int>? baseRevision,
    Expression<String>? operationId,
    Expression<String>? lastModifiedByDeviceId,
    Expression<bool>? isDeleted,
    Expression<String>? syncState,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (email != null) 'email': email,
      if (languagePreference != null) 'language_preference': languagePreference,
      if (avatarUrl != null) 'avatar_url': avatarUrl,
      if (subscriptionTier != null) 'subscription_tier': subscriptionTier,
      if (subscriptionStatus != null) 'subscription_status': subscriptionStatus,
      if (trialStartedAt != null) 'trial_started_at': trialStartedAt,
      if (trialExpiresAt != null) 'trial_expires_at': trialExpiresAt,
      if (subscriptionExpiresAt != null)
        'subscription_expires_at': subscriptionExpiresAt,
      if (lastPaymentDate != null) 'last_payment_date': lastPaymentDate,
      if (paymentProvider != null) 'payment_provider': paymentProvider,
      if (paymentProviderId != null) 'payment_provider_id': paymentProviderId,
      if (ocrUsageCount != null) 'ocr_usage_count': ocrUsageCount,
      if (ocrUsageResetAt != null) 'ocr_usage_reset_at': ocrUsageResetAt,
      if (experienceMode != null) 'experience_mode': experienceMode,
      if (role != null) 'role': role,
      if (metadata != null) 'metadata': metadata,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (baseRevision != null) 'base_revision': baseRevision,
      if (operationId != null) 'operation_id': operationId,
      if (lastModifiedByDeviceId != null)
        'last_modified_by_device_id': lastModifiedByDeviceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncState != null) 'sync_state': syncState,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UsersCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String>? email,
    Value<String>? languagePreference,
    Value<String?>? avatarUrl,
    Value<String>? subscriptionTier,
    Value<String>? subscriptionStatus,
    Value<DateTime?>? trialStartedAt,
    Value<DateTime?>? trialExpiresAt,
    Value<DateTime?>? subscriptionExpiresAt,
    Value<DateTime?>? lastPaymentDate,
    Value<String?>? paymentProvider,
    Value<String?>? paymentProviderId,
    Value<int>? ocrUsageCount,
    Value<DateTime?>? ocrUsageResetAt,
    Value<String>? experienceMode,
    Value<String>? role,
    Value<Map<String, dynamic>?>? metadata,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<int?>? baseRevision,
    Value<String?>? operationId,
    Value<String?>? lastModifiedByDeviceId,
    Value<bool>? isDeleted,
    Value<String>? syncState,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return UsersCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      email: email ?? this.email,
      languagePreference: languagePreference ?? this.languagePreference,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      subscriptionTier: subscriptionTier ?? this.subscriptionTier,
      subscriptionStatus: subscriptionStatus ?? this.subscriptionStatus,
      trialStartedAt: trialStartedAt ?? this.trialStartedAt,
      trialExpiresAt: trialExpiresAt ?? this.trialExpiresAt,
      subscriptionExpiresAt:
          subscriptionExpiresAt ?? this.subscriptionExpiresAt,
      lastPaymentDate: lastPaymentDate ?? this.lastPaymentDate,
      paymentProvider: paymentProvider ?? this.paymentProvider,
      paymentProviderId: paymentProviderId ?? this.paymentProviderId,
      ocrUsageCount: ocrUsageCount ?? this.ocrUsageCount,
      ocrUsageResetAt: ocrUsageResetAt ?? this.ocrUsageResetAt,
      experienceMode: experienceMode ?? this.experienceMode,
      role: role ?? this.role,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      baseRevision: baseRevision ?? this.baseRevision,
      operationId: operationId ?? this.operationId,
      lastModifiedByDeviceId:
          lastModifiedByDeviceId ?? this.lastModifiedByDeviceId,
      isDeleted: isDeleted ?? this.isDeleted,
      syncState: syncState ?? this.syncState,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (languagePreference.present) {
      map['language_preference'] = Variable<String>(languagePreference.value);
    }
    if (avatarUrl.present) {
      map['avatar_url'] = Variable<String>(avatarUrl.value);
    }
    if (subscriptionTier.present) {
      map['subscription_tier'] = Variable<String>(subscriptionTier.value);
    }
    if (subscriptionStatus.present) {
      map['subscription_status'] = Variable<String>(subscriptionStatus.value);
    }
    if (trialStartedAt.present) {
      map['trial_started_at'] = Variable<DateTime>(trialStartedAt.value);
    }
    if (trialExpiresAt.present) {
      map['trial_expires_at'] = Variable<DateTime>(trialExpiresAt.value);
    }
    if (subscriptionExpiresAt.present) {
      map['subscription_expires_at'] = Variable<DateTime>(
        subscriptionExpiresAt.value,
      );
    }
    if (lastPaymentDate.present) {
      map['last_payment_date'] = Variable<DateTime>(lastPaymentDate.value);
    }
    if (paymentProvider.present) {
      map['payment_provider'] = Variable<String>(paymentProvider.value);
    }
    if (paymentProviderId.present) {
      map['payment_provider_id'] = Variable<String>(paymentProviderId.value);
    }
    if (ocrUsageCount.present) {
      map['ocr_usage_count'] = Variable<int>(ocrUsageCount.value);
    }
    if (ocrUsageResetAt.present) {
      map['ocr_usage_reset_at'] = Variable<DateTime>(ocrUsageResetAt.value);
    }
    if (experienceMode.present) {
      map['experience_mode'] = Variable<String>(experienceMode.value);
    }
    if (role.present) {
      map['role'] = Variable<String>(role.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $UsersTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (baseRevision.present) {
      map['base_revision'] = Variable<int>(baseRevision.value);
    }
    if (operationId.present) {
      map['operation_id'] = Variable<String>(operationId.value);
    }
    if (lastModifiedByDeviceId.present) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId.value,
      );
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UsersCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('email: $email, ')
          ..write('languagePreference: $languagePreference, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('subscriptionTier: $subscriptionTier, ')
          ..write('subscriptionStatus: $subscriptionStatus, ')
          ..write('trialStartedAt: $trialStartedAt, ')
          ..write('trialExpiresAt: $trialExpiresAt, ')
          ..write('subscriptionExpiresAt: $subscriptionExpiresAt, ')
          ..write('lastPaymentDate: $lastPaymentDate, ')
          ..write('paymentProvider: $paymentProvider, ')
          ..write('paymentProviderId: $paymentProviderId, ')
          ..write('ocrUsageCount: $ocrUsageCount, ')
          ..write('ocrUsageResetAt: $ocrUsageResetAt, ')
          ..write('experienceMode: $experienceMode, ')
          ..write('role: $role, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BudgetsTable extends Budgets with TableInfo<$BudgetsTable, Budget> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BudgetsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _ownerIdMeta = const VerificationMeta(
    'ownerId',
  );
  @override
  late final GeneratedColumn<String> ownerId = GeneratedColumn<String>(
    'owner_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _startDateMeta = const VerificationMeta(
    'startDate',
  );
  @override
  late final GeneratedColumn<DateTime> startDate = GeneratedColumn<DateTime>(
    'start_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _endDateMeta = const VerificationMeta(
    'endDate',
  );
  @override
  late final GeneratedColumn<DateTime> endDate = GeneratedColumn<DateTime>(
    'end_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currencyMeta = const VerificationMeta(
    'currency',
  );
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
    'currency',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('EUR'),
  );
  static const VerificationMeta _totalLimitMeta = const VerificationMeta(
    'totalLimit',
  );
  @override
  late final GeneratedColumn<int> totalLimit = GeneratedColumn<int>(
    'total_limit',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isSharedMeta = const VerificationMeta(
    'isShared',
  );
  @override
  late final GeneratedColumn<bool> isShared = GeneratedColumn<bool>(
    'is_shared',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_shared" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isTemplateMeta = const VerificationMeta(
    'isTemplate',
  );
  @override
  late final GeneratedColumn<bool> isTemplate = GeneratedColumn<bool>(
    'is_template',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_template" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('active'),
  );
  static const VerificationMeta _iconNameMeta = const VerificationMeta(
    'iconName',
  );
  @override
  late final GeneratedColumn<String> iconName = GeneratedColumn<String>(
    'icon_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _colorHexMeta = const VerificationMeta(
    'colorHex',
  );
  @override
  late final GeneratedColumn<String> colorHex = GeneratedColumn<String>(
    'color_hex',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _tagsMeta = const VerificationMeta('tags');
  @override
  late final GeneratedColumn<String> tags = GeneratedColumn<String>(
    'tags',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata = GeneratedColumn<String>(
    'metadata',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Map<String, dynamic>?>($BudgetsTable.$convertermetadatan);
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _baseRevisionMeta = const VerificationMeta(
    'baseRevision',
  );
  @override
  late final GeneratedColumn<int> baseRevision = GeneratedColumn<int>(
    'base_revision',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _operationIdMeta = const VerificationMeta(
    'operationId',
  );
  @override
  late final GeneratedColumn<String> operationId = GeneratedColumn<String>(
    'operation_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastModifiedByDeviceIdMeta =
      const VerificationMeta('lastModifiedByDeviceId');
  @override
  late final GeneratedColumn<String> lastModifiedByDeviceId =
      GeneratedColumn<String>(
        'last_modified_by_device_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _globalSeqMeta = const VerificationMeta(
    'globalSeq',
  );
  @override
  late final GeneratedColumn<int> globalSeq = GeneratedColumn<int>(
    'global_seq',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    ownerId,
    title,
    description,
    type,
    startDate,
    endDate,
    currency,
    totalLimit,
    isShared,
    isTemplate,
    status,
    iconName,
    colorHex,
    notes,
    tags,
    metadata,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    isDeleted,
    globalSeq,
    syncState,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'budgets';
  @override
  VerificationContext validateIntegrity(
    Insertable<Budget> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('owner_id')) {
      context.handle(
        _ownerIdMeta,
        ownerId.isAcceptableOrUnknown(data['owner_id']!, _ownerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_ownerIdMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('start_date')) {
      context.handle(
        _startDateMeta,
        startDate.isAcceptableOrUnknown(data['start_date']!, _startDateMeta),
      );
    } else if (isInserting) {
      context.missing(_startDateMeta);
    }
    if (data.containsKey('end_date')) {
      context.handle(
        _endDateMeta,
        endDate.isAcceptableOrUnknown(data['end_date']!, _endDateMeta),
      );
    } else if (isInserting) {
      context.missing(_endDateMeta);
    }
    if (data.containsKey('currency')) {
      context.handle(
        _currencyMeta,
        currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta),
      );
    }
    if (data.containsKey('total_limit')) {
      context.handle(
        _totalLimitMeta,
        totalLimit.isAcceptableOrUnknown(data['total_limit']!, _totalLimitMeta),
      );
    }
    if (data.containsKey('is_shared')) {
      context.handle(
        _isSharedMeta,
        isShared.isAcceptableOrUnknown(data['is_shared']!, _isSharedMeta),
      );
    }
    if (data.containsKey('is_template')) {
      context.handle(
        _isTemplateMeta,
        isTemplate.isAcceptableOrUnknown(data['is_template']!, _isTemplateMeta),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('icon_name')) {
      context.handle(
        _iconNameMeta,
        iconName.isAcceptableOrUnknown(data['icon_name']!, _iconNameMeta),
      );
    }
    if (data.containsKey('color_hex')) {
      context.handle(
        _colorHexMeta,
        colorHex.isAcceptableOrUnknown(data['color_hex']!, _colorHexMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('tags')) {
      context.handle(
        _tagsMeta,
        tags.isAcceptableOrUnknown(data['tags']!, _tagsMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('base_revision')) {
      context.handle(
        _baseRevisionMeta,
        baseRevision.isAcceptableOrUnknown(
          data['base_revision']!,
          _baseRevisionMeta,
        ),
      );
    }
    if (data.containsKey('operation_id')) {
      context.handle(
        _operationIdMeta,
        operationId.isAcceptableOrUnknown(
          data['operation_id']!,
          _operationIdMeta,
        ),
      );
    }
    if (data.containsKey('last_modified_by_device_id')) {
      context.handle(
        _lastModifiedByDeviceIdMeta,
        lastModifiedByDeviceId.isAcceptableOrUnknown(
          data['last_modified_by_device_id']!,
          _lastModifiedByDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('global_seq')) {
      context.handle(
        _globalSeqMeta,
        globalSeq.isAcceptableOrUnknown(data['global_seq']!, _globalSeqMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Budget map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Budget(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      ownerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_id'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      startDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}start_date'],
      )!,
      endDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}end_date'],
      )!,
      currency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}currency'],
      )!,
      totalLimit: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}total_limit'],
      ),
      isShared: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_shared'],
      )!,
      isTemplate: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_template'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      iconName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}icon_name'],
      ),
      colorHex: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color_hex'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      tags: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tags'],
      ),
      metadata: $BudgetsTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      baseRevision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}base_revision'],
      ),
      operationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation_id'],
      ),
      lastModifiedByDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_modified_by_device_id'],
      ),
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      globalSeq: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}global_seq'],
      ),
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $BudgetsTable createAlias(String alias) {
    return $BudgetsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class Budget extends DataClass implements Insertable<Budget> {
  final String id;
  final String ownerId;
  final String title;
  final String? description;
  final String type;
  final DateTime startDate;
  final DateTime endDate;
  final String currency;
  final int? totalLimit;
  final bool isShared;
  final bool isTemplate;
  final String status;
  final String? iconName;
  final String? colorHex;
  final String? notes;
  final String? tags;
  final Map<String, dynamic>? metadata;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final int? baseRevision;
  final String? operationId;
  final String? lastModifiedByDeviceId;
  final bool isDeleted;
  final int? globalSeq;
  final String syncState;
  final int lamportClock;
  final String? versionVector;
  const Budget({
    required this.id,
    required this.ownerId,
    required this.title,
    this.description,
    required this.type,
    required this.startDate,
    required this.endDate,
    required this.currency,
    this.totalLimit,
    required this.isShared,
    required this.isTemplate,
    required this.status,
    this.iconName,
    this.colorHex,
    this.notes,
    this.tags,
    this.metadata,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    this.baseRevision,
    this.operationId,
    this.lastModifiedByDeviceId,
    required this.isDeleted,
    this.globalSeq,
    required this.syncState,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['owner_id'] = Variable<String>(ownerId);
    map['title'] = Variable<String>(title);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['type'] = Variable<String>(type);
    map['start_date'] = Variable<DateTime>(startDate);
    map['end_date'] = Variable<DateTime>(endDate);
    map['currency'] = Variable<String>(currency);
    if (!nullToAbsent || totalLimit != null) {
      map['total_limit'] = Variable<int>(totalLimit);
    }
    map['is_shared'] = Variable<bool>(isShared);
    map['is_template'] = Variable<bool>(isTemplate);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || iconName != null) {
      map['icon_name'] = Variable<String>(iconName);
    }
    if (!nullToAbsent || colorHex != null) {
      map['color_hex'] = Variable<String>(colorHex);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    if (!nullToAbsent || tags != null) {
      map['tags'] = Variable<String>(tags);
    }
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $BudgetsTable.$convertermetadatan.toSql(metadata),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    if (!nullToAbsent || baseRevision != null) {
      map['base_revision'] = Variable<int>(baseRevision);
    }
    if (!nullToAbsent || operationId != null) {
      map['operation_id'] = Variable<String>(operationId);
    }
    if (!nullToAbsent || lastModifiedByDeviceId != null) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId,
      );
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || globalSeq != null) {
      map['global_seq'] = Variable<int>(globalSeq);
    }
    map['sync_state'] = Variable<String>(syncState);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  BudgetsCompanion toCompanion(bool nullToAbsent) {
    return BudgetsCompanion(
      id: Value(id),
      ownerId: Value(ownerId),
      title: Value(title),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      type: Value(type),
      startDate: Value(startDate),
      endDate: Value(endDate),
      currency: Value(currency),
      totalLimit: totalLimit == null && nullToAbsent
          ? const Value.absent()
          : Value(totalLimit),
      isShared: Value(isShared),
      isTemplate: Value(isTemplate),
      status: Value(status),
      iconName: iconName == null && nullToAbsent
          ? const Value.absent()
          : Value(iconName),
      colorHex: colorHex == null && nullToAbsent
          ? const Value.absent()
          : Value(colorHex),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      tags: tags == null && nullToAbsent ? const Value.absent() : Value(tags),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      baseRevision: baseRevision == null && nullToAbsent
          ? const Value.absent()
          : Value(baseRevision),
      operationId: operationId == null && nullToAbsent
          ? const Value.absent()
          : Value(operationId),
      lastModifiedByDeviceId: lastModifiedByDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedByDeviceId),
      isDeleted: Value(isDeleted),
      globalSeq: globalSeq == null && nullToAbsent
          ? const Value.absent()
          : Value(globalSeq),
      syncState: Value(syncState),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory Budget.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Budget(
      id: serializer.fromJson<String>(json['id']),
      ownerId: serializer.fromJson<String>(json['ownerId']),
      title: serializer.fromJson<String>(json['title']),
      description: serializer.fromJson<String?>(json['description']),
      type: serializer.fromJson<String>(json['type']),
      startDate: serializer.fromJson<DateTime>(json['startDate']),
      endDate: serializer.fromJson<DateTime>(json['endDate']),
      currency: serializer.fromJson<String>(json['currency']),
      totalLimit: serializer.fromJson<int?>(json['totalLimit']),
      isShared: serializer.fromJson<bool>(json['isShared']),
      isTemplate: serializer.fromJson<bool>(json['isTemplate']),
      status: serializer.fromJson<String>(json['status']),
      iconName: serializer.fromJson<String?>(json['iconName']),
      colorHex: serializer.fromJson<String?>(json['colorHex']),
      notes: serializer.fromJson<String?>(json['notes']),
      tags: serializer.fromJson<String?>(json['tags']),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      baseRevision: serializer.fromJson<int?>(json['baseRevision']),
      operationId: serializer.fromJson<String?>(json['operationId']),
      lastModifiedByDeviceId: serializer.fromJson<String?>(
        json['lastModifiedByDeviceId'],
      ),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      globalSeq: serializer.fromJson<int?>(json['globalSeq']),
      syncState: serializer.fromJson<String>(json['syncState']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'ownerId': serializer.toJson<String>(ownerId),
      'title': serializer.toJson<String>(title),
      'description': serializer.toJson<String?>(description),
      'type': serializer.toJson<String>(type),
      'startDate': serializer.toJson<DateTime>(startDate),
      'endDate': serializer.toJson<DateTime>(endDate),
      'currency': serializer.toJson<String>(currency),
      'totalLimit': serializer.toJson<int?>(totalLimit),
      'isShared': serializer.toJson<bool>(isShared),
      'isTemplate': serializer.toJson<bool>(isTemplate),
      'status': serializer.toJson<String>(status),
      'iconName': serializer.toJson<String?>(iconName),
      'colorHex': serializer.toJson<String?>(colorHex),
      'notes': serializer.toJson<String?>(notes),
      'tags': serializer.toJson<String?>(tags),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'baseRevision': serializer.toJson<int?>(baseRevision),
      'operationId': serializer.toJson<String?>(operationId),
      'lastModifiedByDeviceId': serializer.toJson<String?>(
        lastModifiedByDeviceId,
      ),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'globalSeq': serializer.toJson<int?>(globalSeq),
      'syncState': serializer.toJson<String>(syncState),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  Budget copyWith({
    String? id,
    String? ownerId,
    String? title,
    Value<String?> description = const Value.absent(),
    String? type,
    DateTime? startDate,
    DateTime? endDate,
    String? currency,
    Value<int?> totalLimit = const Value.absent(),
    bool? isShared,
    bool? isTemplate,
    String? status,
    Value<String?> iconName = const Value.absent(),
    Value<String?> colorHex = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    Value<String?> tags = const Value.absent(),
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    Value<int?> baseRevision = const Value.absent(),
    Value<String?> operationId = const Value.absent(),
    Value<String?> lastModifiedByDeviceId = const Value.absent(),
    bool? isDeleted,
    Value<int?> globalSeq = const Value.absent(),
    String? syncState,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => Budget(
    id: id ?? this.id,
    ownerId: ownerId ?? this.ownerId,
    title: title ?? this.title,
    description: description.present ? description.value : this.description,
    type: type ?? this.type,
    startDate: startDate ?? this.startDate,
    endDate: endDate ?? this.endDate,
    currency: currency ?? this.currency,
    totalLimit: totalLimit.present ? totalLimit.value : this.totalLimit,
    isShared: isShared ?? this.isShared,
    isTemplate: isTemplate ?? this.isTemplate,
    status: status ?? this.status,
    iconName: iconName.present ? iconName.value : this.iconName,
    colorHex: colorHex.present ? colorHex.value : this.colorHex,
    notes: notes.present ? notes.value : this.notes,
    tags: tags.present ? tags.value : this.tags,
    metadata: metadata.present ? metadata.value : this.metadata,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    baseRevision: baseRevision.present ? baseRevision.value : this.baseRevision,
    operationId: operationId.present ? operationId.value : this.operationId,
    lastModifiedByDeviceId: lastModifiedByDeviceId.present
        ? lastModifiedByDeviceId.value
        : this.lastModifiedByDeviceId,
    isDeleted: isDeleted ?? this.isDeleted,
    globalSeq: globalSeq.present ? globalSeq.value : this.globalSeq,
    syncState: syncState ?? this.syncState,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  Budget copyWithCompanion(BudgetsCompanion data) {
    return Budget(
      id: data.id.present ? data.id.value : this.id,
      ownerId: data.ownerId.present ? data.ownerId.value : this.ownerId,
      title: data.title.present ? data.title.value : this.title,
      description: data.description.present
          ? data.description.value
          : this.description,
      type: data.type.present ? data.type.value : this.type,
      startDate: data.startDate.present ? data.startDate.value : this.startDate,
      endDate: data.endDate.present ? data.endDate.value : this.endDate,
      currency: data.currency.present ? data.currency.value : this.currency,
      totalLimit: data.totalLimit.present
          ? data.totalLimit.value
          : this.totalLimit,
      isShared: data.isShared.present ? data.isShared.value : this.isShared,
      isTemplate: data.isTemplate.present
          ? data.isTemplate.value
          : this.isTemplate,
      status: data.status.present ? data.status.value : this.status,
      iconName: data.iconName.present ? data.iconName.value : this.iconName,
      colorHex: data.colorHex.present ? data.colorHex.value : this.colorHex,
      notes: data.notes.present ? data.notes.value : this.notes,
      tags: data.tags.present ? data.tags.value : this.tags,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      baseRevision: data.baseRevision.present
          ? data.baseRevision.value
          : this.baseRevision,
      operationId: data.operationId.present
          ? data.operationId.value
          : this.operationId,
      lastModifiedByDeviceId: data.lastModifiedByDeviceId.present
          ? data.lastModifiedByDeviceId.value
          : this.lastModifiedByDeviceId,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      globalSeq: data.globalSeq.present ? data.globalSeq.value : this.globalSeq,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Budget(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('title: $title, ')
          ..write('description: $description, ')
          ..write('type: $type, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('currency: $currency, ')
          ..write('totalLimit: $totalLimit, ')
          ..write('isShared: $isShared, ')
          ..write('isTemplate: $isTemplate, ')
          ..write('status: $status, ')
          ..write('iconName: $iconName, ')
          ..write('colorHex: $colorHex, ')
          ..write('notes: $notes, ')
          ..write('tags: $tags, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('globalSeq: $globalSeq, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    ownerId,
    title,
    description,
    type,
    startDate,
    endDate,
    currency,
    totalLimit,
    isShared,
    isTemplate,
    status,
    iconName,
    colorHex,
    notes,
    tags,
    metadata,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    isDeleted,
    globalSeq,
    syncState,
    lamportClock,
    versionVector,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Budget &&
          other.id == this.id &&
          other.ownerId == this.ownerId &&
          other.title == this.title &&
          other.description == this.description &&
          other.type == this.type &&
          other.startDate == this.startDate &&
          other.endDate == this.endDate &&
          other.currency == this.currency &&
          other.totalLimit == this.totalLimit &&
          other.isShared == this.isShared &&
          other.isTemplate == this.isTemplate &&
          other.status == this.status &&
          other.iconName == this.iconName &&
          other.colorHex == this.colorHex &&
          other.notes == this.notes &&
          other.tags == this.tags &&
          other.metadata == this.metadata &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.baseRevision == this.baseRevision &&
          other.operationId == this.operationId &&
          other.lastModifiedByDeviceId == this.lastModifiedByDeviceId &&
          other.isDeleted == this.isDeleted &&
          other.globalSeq == this.globalSeq &&
          other.syncState == this.syncState &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class BudgetsCompanion extends UpdateCompanion<Budget> {
  final Value<String> id;
  final Value<String> ownerId;
  final Value<String> title;
  final Value<String?> description;
  final Value<String> type;
  final Value<DateTime> startDate;
  final Value<DateTime> endDate;
  final Value<String> currency;
  final Value<int?> totalLimit;
  final Value<bool> isShared;
  final Value<bool> isTemplate;
  final Value<String> status;
  final Value<String?> iconName;
  final Value<String?> colorHex;
  final Value<String?> notes;
  final Value<String?> tags;
  final Value<Map<String, dynamic>?> metadata;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<int?> baseRevision;
  final Value<String?> operationId;
  final Value<String?> lastModifiedByDeviceId;
  final Value<bool> isDeleted;
  final Value<int?> globalSeq;
  final Value<String> syncState;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const BudgetsCompanion({
    this.id = const Value.absent(),
    this.ownerId = const Value.absent(),
    this.title = const Value.absent(),
    this.description = const Value.absent(),
    this.type = const Value.absent(),
    this.startDate = const Value.absent(),
    this.endDate = const Value.absent(),
    this.currency = const Value.absent(),
    this.totalLimit = const Value.absent(),
    this.isShared = const Value.absent(),
    this.isTemplate = const Value.absent(),
    this.status = const Value.absent(),
    this.iconName = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.notes = const Value.absent(),
    this.tags = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.globalSeq = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BudgetsCompanion.insert({
    required String id,
    required String ownerId,
    required String title,
    this.description = const Value.absent(),
    required String type,
    required DateTime startDate,
    required DateTime endDate,
    this.currency = const Value.absent(),
    this.totalLimit = const Value.absent(),
    this.isShared = const Value.absent(),
    this.isTemplate = const Value.absent(),
    this.status = const Value.absent(),
    this.iconName = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.notes = const Value.absent(),
    this.tags = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.globalSeq = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       ownerId = Value(ownerId),
       title = Value(title),
       type = Value(type),
       startDate = Value(startDate),
       endDate = Value(endDate);
  static Insertable<Budget> custom({
    Expression<String>? id,
    Expression<String>? ownerId,
    Expression<String>? title,
    Expression<String>? description,
    Expression<String>? type,
    Expression<DateTime>? startDate,
    Expression<DateTime>? endDate,
    Expression<String>? currency,
    Expression<int>? totalLimit,
    Expression<bool>? isShared,
    Expression<bool>? isTemplate,
    Expression<String>? status,
    Expression<String>? iconName,
    Expression<String>? colorHex,
    Expression<String>? notes,
    Expression<String>? tags,
    Expression<String>? metadata,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<int>? baseRevision,
    Expression<String>? operationId,
    Expression<String>? lastModifiedByDeviceId,
    Expression<bool>? isDeleted,
    Expression<int>? globalSeq,
    Expression<String>? syncState,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (ownerId != null) 'owner_id': ownerId,
      if (title != null) 'title': title,
      if (description != null) 'description': description,
      if (type != null) 'type': type,
      if (startDate != null) 'start_date': startDate,
      if (endDate != null) 'end_date': endDate,
      if (currency != null) 'currency': currency,
      if (totalLimit != null) 'total_limit': totalLimit,
      if (isShared != null) 'is_shared': isShared,
      if (isTemplate != null) 'is_template': isTemplate,
      if (status != null) 'status': status,
      if (iconName != null) 'icon_name': iconName,
      if (colorHex != null) 'color_hex': colorHex,
      if (notes != null) 'notes': notes,
      if (tags != null) 'tags': tags,
      if (metadata != null) 'metadata': metadata,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (baseRevision != null) 'base_revision': baseRevision,
      if (operationId != null) 'operation_id': operationId,
      if (lastModifiedByDeviceId != null)
        'last_modified_by_device_id': lastModifiedByDeviceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (globalSeq != null) 'global_seq': globalSeq,
      if (syncState != null) 'sync_state': syncState,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BudgetsCompanion copyWith({
    Value<String>? id,
    Value<String>? ownerId,
    Value<String>? title,
    Value<String?>? description,
    Value<String>? type,
    Value<DateTime>? startDate,
    Value<DateTime>? endDate,
    Value<String>? currency,
    Value<int?>? totalLimit,
    Value<bool>? isShared,
    Value<bool>? isTemplate,
    Value<String>? status,
    Value<String?>? iconName,
    Value<String?>? colorHex,
    Value<String?>? notes,
    Value<String?>? tags,
    Value<Map<String, dynamic>?>? metadata,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<int?>? baseRevision,
    Value<String?>? operationId,
    Value<String?>? lastModifiedByDeviceId,
    Value<bool>? isDeleted,
    Value<int?>? globalSeq,
    Value<String>? syncState,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return BudgetsCompanion(
      id: id ?? this.id,
      ownerId: ownerId ?? this.ownerId,
      title: title ?? this.title,
      description: description ?? this.description,
      type: type ?? this.type,
      startDate: startDate ?? this.startDate,
      endDate: endDate ?? this.endDate,
      currency: currency ?? this.currency,
      totalLimit: totalLimit ?? this.totalLimit,
      isShared: isShared ?? this.isShared,
      isTemplate: isTemplate ?? this.isTemplate,
      status: status ?? this.status,
      iconName: iconName ?? this.iconName,
      colorHex: colorHex ?? this.colorHex,
      notes: notes ?? this.notes,
      tags: tags ?? this.tags,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      baseRevision: baseRevision ?? this.baseRevision,
      operationId: operationId ?? this.operationId,
      lastModifiedByDeviceId:
          lastModifiedByDeviceId ?? this.lastModifiedByDeviceId,
      isDeleted: isDeleted ?? this.isDeleted,
      globalSeq: globalSeq ?? this.globalSeq,
      syncState: syncState ?? this.syncState,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (ownerId.present) {
      map['owner_id'] = Variable<String>(ownerId.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (startDate.present) {
      map['start_date'] = Variable<DateTime>(startDate.value);
    }
    if (endDate.present) {
      map['end_date'] = Variable<DateTime>(endDate.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (totalLimit.present) {
      map['total_limit'] = Variable<int>(totalLimit.value);
    }
    if (isShared.present) {
      map['is_shared'] = Variable<bool>(isShared.value);
    }
    if (isTemplate.present) {
      map['is_template'] = Variable<bool>(isTemplate.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (iconName.present) {
      map['icon_name'] = Variable<String>(iconName.value);
    }
    if (colorHex.present) {
      map['color_hex'] = Variable<String>(colorHex.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (tags.present) {
      map['tags'] = Variable<String>(tags.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $BudgetsTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (baseRevision.present) {
      map['base_revision'] = Variable<int>(baseRevision.value);
    }
    if (operationId.present) {
      map['operation_id'] = Variable<String>(operationId.value);
    }
    if (lastModifiedByDeviceId.present) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId.value,
      );
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (globalSeq.present) {
      map['global_seq'] = Variable<int>(globalSeq.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BudgetsCompanion(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('title: $title, ')
          ..write('description: $description, ')
          ..write('type: $type, ')
          ..write('startDate: $startDate, ')
          ..write('endDate: $endDate, ')
          ..write('currency: $currency, ')
          ..write('totalLimit: $totalLimit, ')
          ..write('isShared: $isShared, ')
          ..write('isTemplate: $isTemplate, ')
          ..write('status: $status, ')
          ..write('iconName: $iconName, ')
          ..write('colorHex: $colorHex, ')
          ..write('notes: $notes, ')
          ..write('tags: $tags, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('globalSeq: $globalSeq, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CategoriesTable extends Categories
    with TableInfo<$CategoriesTable, Category> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CategoriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _ownerIdMeta = const VerificationMeta(
    'ownerId',
  );
  @override
  late final GeneratedColumn<String> ownerId = GeneratedColumn<String>(
    'owner_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  nameTranslations =
      GeneratedColumn<String>(
        'name_translations',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Map<String, dynamic>?>(
        $CategoriesTable.$converternameTranslationsn,
      );
  static const VerificationMeta _iconNameMeta = const VerificationMeta(
    'iconName',
  );
  @override
  late final GeneratedColumn<String> iconName = GeneratedColumn<String>(
    'icon_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _colorHexMeta = const VerificationMeta(
    'colorHex',
  );
  @override
  late final GeneratedColumn<String> colorHex = GeneratedColumn<String>(
    'color_hex',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('expense'),
  );
  static const VerificationMeta _isSystemMeta = const VerificationMeta(
    'isSystem',
  );
  @override
  late final GeneratedColumn<bool> isSystem = GeneratedColumn<bool>(
    'is_system',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_system" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _parentIdMeta = const VerificationMeta(
    'parentId',
  );
  @override
  late final GeneratedColumn<String> parentId = GeneratedColumn<String>(
    'parent_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES categories (id)',
    ),
  );
  static const VerificationMeta _tagsMeta = const VerificationMeta('tags');
  @override
  late final GeneratedColumn<String> tags = GeneratedColumn<String>(
    'tags',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    ownerId,
    name,
    nameTranslations,
    iconName,
    colorHex,
    type,
    isSystem,
    parentId,
    tags,
    isDeleted,
    createdAt,
    updatedAt,
    revision,
    syncState,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'categories';
  @override
  VerificationContext validateIntegrity(
    Insertable<Category> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('owner_id')) {
      context.handle(
        _ownerIdMeta,
        ownerId.isAcceptableOrUnknown(data['owner_id']!, _ownerIdMeta),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('icon_name')) {
      context.handle(
        _iconNameMeta,
        iconName.isAcceptableOrUnknown(data['icon_name']!, _iconNameMeta),
      );
    }
    if (data.containsKey('color_hex')) {
      context.handle(
        _colorHexMeta,
        colorHex.isAcceptableOrUnknown(data['color_hex']!, _colorHexMeta),
      );
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    }
    if (data.containsKey('is_system')) {
      context.handle(
        _isSystemMeta,
        isSystem.isAcceptableOrUnknown(data['is_system']!, _isSystemMeta),
      );
    }
    if (data.containsKey('parent_id')) {
      context.handle(
        _parentIdMeta,
        parentId.isAcceptableOrUnknown(data['parent_id']!, _parentIdMeta),
      );
    }
    if (data.containsKey('tags')) {
      context.handle(
        _tagsMeta,
        tags.isAcceptableOrUnknown(data['tags']!, _tagsMeta),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Category map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Category(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      ownerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_id'],
      ),
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      nameTranslations: $CategoriesTable.$converternameTranslationsn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}name_translations'],
        ),
      ),
      iconName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}icon_name'],
      ),
      colorHex: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color_hex'],
      ),
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      isSystem: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_system'],
      )!,
      parentId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_id'],
      ),
      tags: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tags'],
      ),
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $CategoriesTable createAlias(String alias) {
    return $CategoriesTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String>
  $converternameTranslations = const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?>
  $converternameTranslationsn = NullAwareTypeConverter.wrap(
    $converternameTranslations,
  );
}

class Category extends DataClass implements Insertable<Category> {
  final String id;
  final String? ownerId;
  final String name;
  final Map<String, dynamic>? nameTranslations;
  final String? iconName;
  final String? colorHex;
  final String type;
  final bool isSystem;
  final String? parentId;
  final String? tags;
  final bool isDeleted;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final String syncState;
  final int lamportClock;
  final String? versionVector;
  const Category({
    required this.id,
    this.ownerId,
    required this.name,
    this.nameTranslations,
    this.iconName,
    this.colorHex,
    required this.type,
    required this.isSystem,
    this.parentId,
    this.tags,
    required this.isDeleted,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    required this.syncState,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || ownerId != null) {
      map['owner_id'] = Variable<String>(ownerId);
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || nameTranslations != null) {
      map['name_translations'] = Variable<String>(
        $CategoriesTable.$converternameTranslationsn.toSql(nameTranslations),
      );
    }
    if (!nullToAbsent || iconName != null) {
      map['icon_name'] = Variable<String>(iconName);
    }
    if (!nullToAbsent || colorHex != null) {
      map['color_hex'] = Variable<String>(colorHex);
    }
    map['type'] = Variable<String>(type);
    map['is_system'] = Variable<bool>(isSystem);
    if (!nullToAbsent || parentId != null) {
      map['parent_id'] = Variable<String>(parentId);
    }
    if (!nullToAbsent || tags != null) {
      map['tags'] = Variable<String>(tags);
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    map['sync_state'] = Variable<String>(syncState);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  CategoriesCompanion toCompanion(bool nullToAbsent) {
    return CategoriesCompanion(
      id: Value(id),
      ownerId: ownerId == null && nullToAbsent
          ? const Value.absent()
          : Value(ownerId),
      name: Value(name),
      nameTranslations: nameTranslations == null && nullToAbsent
          ? const Value.absent()
          : Value(nameTranslations),
      iconName: iconName == null && nullToAbsent
          ? const Value.absent()
          : Value(iconName),
      colorHex: colorHex == null && nullToAbsent
          ? const Value.absent()
          : Value(colorHex),
      type: Value(type),
      isSystem: Value(isSystem),
      parentId: parentId == null && nullToAbsent
          ? const Value.absent()
          : Value(parentId),
      tags: tags == null && nullToAbsent ? const Value.absent() : Value(tags),
      isDeleted: Value(isDeleted),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      syncState: Value(syncState),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory Category.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Category(
      id: serializer.fromJson<String>(json['id']),
      ownerId: serializer.fromJson<String?>(json['ownerId']),
      name: serializer.fromJson<String>(json['name']),
      nameTranslations: serializer.fromJson<Map<String, dynamic>?>(
        json['nameTranslations'],
      ),
      iconName: serializer.fromJson<String?>(json['iconName']),
      colorHex: serializer.fromJson<String?>(json['colorHex']),
      type: serializer.fromJson<String>(json['type']),
      isSystem: serializer.fromJson<bool>(json['isSystem']),
      parentId: serializer.fromJson<String?>(json['parentId']),
      tags: serializer.fromJson<String?>(json['tags']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      syncState: serializer.fromJson<String>(json['syncState']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'ownerId': serializer.toJson<String?>(ownerId),
      'name': serializer.toJson<String>(name),
      'nameTranslations': serializer.toJson<Map<String, dynamic>?>(
        nameTranslations,
      ),
      'iconName': serializer.toJson<String?>(iconName),
      'colorHex': serializer.toJson<String?>(colorHex),
      'type': serializer.toJson<String>(type),
      'isSystem': serializer.toJson<bool>(isSystem),
      'parentId': serializer.toJson<String?>(parentId),
      'tags': serializer.toJson<String?>(tags),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'syncState': serializer.toJson<String>(syncState),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  Category copyWith({
    String? id,
    Value<String?> ownerId = const Value.absent(),
    String? name,
    Value<Map<String, dynamic>?> nameTranslations = const Value.absent(),
    Value<String?> iconName = const Value.absent(),
    Value<String?> colorHex = const Value.absent(),
    String? type,
    bool? isSystem,
    Value<String?> parentId = const Value.absent(),
    Value<String?> tags = const Value.absent(),
    bool? isDeleted,
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    String? syncState,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => Category(
    id: id ?? this.id,
    ownerId: ownerId.present ? ownerId.value : this.ownerId,
    name: name ?? this.name,
    nameTranslations: nameTranslations.present
        ? nameTranslations.value
        : this.nameTranslations,
    iconName: iconName.present ? iconName.value : this.iconName,
    colorHex: colorHex.present ? colorHex.value : this.colorHex,
    type: type ?? this.type,
    isSystem: isSystem ?? this.isSystem,
    parentId: parentId.present ? parentId.value : this.parentId,
    tags: tags.present ? tags.value : this.tags,
    isDeleted: isDeleted ?? this.isDeleted,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    syncState: syncState ?? this.syncState,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  Category copyWithCompanion(CategoriesCompanion data) {
    return Category(
      id: data.id.present ? data.id.value : this.id,
      ownerId: data.ownerId.present ? data.ownerId.value : this.ownerId,
      name: data.name.present ? data.name.value : this.name,
      nameTranslations: data.nameTranslations.present
          ? data.nameTranslations.value
          : this.nameTranslations,
      iconName: data.iconName.present ? data.iconName.value : this.iconName,
      colorHex: data.colorHex.present ? data.colorHex.value : this.colorHex,
      type: data.type.present ? data.type.value : this.type,
      isSystem: data.isSystem.present ? data.isSystem.value : this.isSystem,
      parentId: data.parentId.present ? data.parentId.value : this.parentId,
      tags: data.tags.present ? data.tags.value : this.tags,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Category(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('name: $name, ')
          ..write('nameTranslations: $nameTranslations, ')
          ..write('iconName: $iconName, ')
          ..write('colorHex: $colorHex, ')
          ..write('type: $type, ')
          ..write('isSystem: $isSystem, ')
          ..write('parentId: $parentId, ')
          ..write('tags: $tags, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    ownerId,
    name,
    nameTranslations,
    iconName,
    colorHex,
    type,
    isSystem,
    parentId,
    tags,
    isDeleted,
    createdAt,
    updatedAt,
    revision,
    syncState,
    lamportClock,
    versionVector,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Category &&
          other.id == this.id &&
          other.ownerId == this.ownerId &&
          other.name == this.name &&
          other.nameTranslations == this.nameTranslations &&
          other.iconName == this.iconName &&
          other.colorHex == this.colorHex &&
          other.type == this.type &&
          other.isSystem == this.isSystem &&
          other.parentId == this.parentId &&
          other.tags == this.tags &&
          other.isDeleted == this.isDeleted &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.syncState == this.syncState &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class CategoriesCompanion extends UpdateCompanion<Category> {
  final Value<String> id;
  final Value<String?> ownerId;
  final Value<String> name;
  final Value<Map<String, dynamic>?> nameTranslations;
  final Value<String?> iconName;
  final Value<String?> colorHex;
  final Value<String> type;
  final Value<bool> isSystem;
  final Value<String?> parentId;
  final Value<String?> tags;
  final Value<bool> isDeleted;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<String> syncState;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const CategoriesCompanion({
    this.id = const Value.absent(),
    this.ownerId = const Value.absent(),
    this.name = const Value.absent(),
    this.nameTranslations = const Value.absent(),
    this.iconName = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.type = const Value.absent(),
    this.isSystem = const Value.absent(),
    this.parentId = const Value.absent(),
    this.tags = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CategoriesCompanion.insert({
    required String id,
    this.ownerId = const Value.absent(),
    required String name,
    this.nameTranslations = const Value.absent(),
    this.iconName = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.type = const Value.absent(),
    this.isSystem = const Value.absent(),
    this.parentId = const Value.absent(),
    this.tags = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<Category> custom({
    Expression<String>? id,
    Expression<String>? ownerId,
    Expression<String>? name,
    Expression<String>? nameTranslations,
    Expression<String>? iconName,
    Expression<String>? colorHex,
    Expression<String>? type,
    Expression<bool>? isSystem,
    Expression<String>? parentId,
    Expression<String>? tags,
    Expression<bool>? isDeleted,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<String>? syncState,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (ownerId != null) 'owner_id': ownerId,
      if (name != null) 'name': name,
      if (nameTranslations != null) 'name_translations': nameTranslations,
      if (iconName != null) 'icon_name': iconName,
      if (colorHex != null) 'color_hex': colorHex,
      if (type != null) 'type': type,
      if (isSystem != null) 'is_system': isSystem,
      if (parentId != null) 'parent_id': parentId,
      if (tags != null) 'tags': tags,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (syncState != null) 'sync_state': syncState,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CategoriesCompanion copyWith({
    Value<String>? id,
    Value<String?>? ownerId,
    Value<String>? name,
    Value<Map<String, dynamic>?>? nameTranslations,
    Value<String?>? iconName,
    Value<String?>? colorHex,
    Value<String>? type,
    Value<bool>? isSystem,
    Value<String?>? parentId,
    Value<String?>? tags,
    Value<bool>? isDeleted,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<String>? syncState,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return CategoriesCompanion(
      id: id ?? this.id,
      ownerId: ownerId ?? this.ownerId,
      name: name ?? this.name,
      nameTranslations: nameTranslations ?? this.nameTranslations,
      iconName: iconName ?? this.iconName,
      colorHex: colorHex ?? this.colorHex,
      type: type ?? this.type,
      isSystem: isSystem ?? this.isSystem,
      parentId: parentId ?? this.parentId,
      tags: tags ?? this.tags,
      isDeleted: isDeleted ?? this.isDeleted,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      syncState: syncState ?? this.syncState,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (ownerId.present) {
      map['owner_id'] = Variable<String>(ownerId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (nameTranslations.present) {
      map['name_translations'] = Variable<String>(
        $CategoriesTable.$converternameTranslationsn.toSql(
          nameTranslations.value,
        ),
      );
    }
    if (iconName.present) {
      map['icon_name'] = Variable<String>(iconName.value);
    }
    if (colorHex.present) {
      map['color_hex'] = Variable<String>(colorHex.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (isSystem.present) {
      map['is_system'] = Variable<bool>(isSystem.value);
    }
    if (parentId.present) {
      map['parent_id'] = Variable<String>(parentId.value);
    }
    if (tags.present) {
      map['tags'] = Variable<String>(tags.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CategoriesCompanion(')
          ..write('id: $id, ')
          ..write('ownerId: $ownerId, ')
          ..write('name: $name, ')
          ..write('nameTranslations: $nameTranslations, ')
          ..write('iconName: $iconName, ')
          ..write('colorHex: $colorHex, ')
          ..write('type: $type, ')
          ..write('isSystem: $isSystem, ')
          ..write('parentId: $parentId, ')
          ..write('tags: $tags, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SemiBudgetsTable extends SemiBudgets
    with TableInfo<$SemiBudgetsTable, SemiBudget> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SemiBudgetsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _budgetIdMeta = const VerificationMeta(
    'budgetId',
  );
  @override
  late final GeneratedColumn<String> budgetId = GeneratedColumn<String>(
    'budget_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES budgets (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _limitAmountMeta = const VerificationMeta(
    'limitAmount',
  );
  @override
  late final GeneratedColumn<int> limitAmount = GeneratedColumn<int>(
    'limit_amount',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _priorityMeta = const VerificationMeta(
    'priority',
  );
  @override
  late final GeneratedColumn<int> priority = GeneratedColumn<int>(
    'priority',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(3),
  );
  static const VerificationMeta _iconNameMeta = const VerificationMeta(
    'iconName',
  );
  @override
  late final GeneratedColumn<String> iconName = GeneratedColumn<String>(
    'icon_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _colorHexMeta = const VerificationMeta(
    'colorHex',
  );
  @override
  late final GeneratedColumn<String> colorHex = GeneratedColumn<String>(
    'color_hex',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata = GeneratedColumn<String>(
    'metadata',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Map<String, dynamic>?>($SemiBudgetsTable.$convertermetadatan);
  static const VerificationMeta _parentCategoryIdMeta = const VerificationMeta(
    'parentCategoryId',
  );
  @override
  late final GeneratedColumn<String> parentCategoryId = GeneratedColumn<String>(
    'parent_category_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES semi_budgets (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _isSubcategoryMeta = const VerificationMeta(
    'isSubcategory',
  );
  @override
  late final GeneratedColumn<bool> isSubcategory = GeneratedColumn<bool>(
    'is_subcategory',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_subcategory" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _suggestedPercentMeta = const VerificationMeta(
    'suggestedPercent',
  );
  @override
  late final GeneratedColumn<double> suggestedPercent = GeneratedColumn<double>(
    'suggested_percent',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _displayOrderMeta = const VerificationMeta(
    'displayOrder',
  );
  @override
  late final GeneratedColumn<int> displayOrder = GeneratedColumn<int>(
    'display_order',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _masterCategoryIdMeta = const VerificationMeta(
    'masterCategoryId',
  );
  @override
  late final GeneratedColumn<String> masterCategoryId = GeneratedColumn<String>(
    'master_category_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES categories (id)',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _baseRevisionMeta = const VerificationMeta(
    'baseRevision',
  );
  @override
  late final GeneratedColumn<int> baseRevision = GeneratedColumn<int>(
    'base_revision',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _operationIdMeta = const VerificationMeta(
    'operationId',
  );
  @override
  late final GeneratedColumn<String> operationId = GeneratedColumn<String>(
    'operation_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastModifiedByDeviceIdMeta =
      const VerificationMeta('lastModifiedByDeviceId');
  @override
  late final GeneratedColumn<String> lastModifiedByDeviceId =
      GeneratedColumn<String>(
        'last_modified_by_device_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    budgetId,
    name,
    limitAmount,
    priority,
    iconName,
    colorHex,
    metadata,
    parentCategoryId,
    isSubcategory,
    suggestedPercent,
    displayOrder,
    masterCategoryId,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    isDeleted,
    syncState,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'semi_budgets';
  @override
  VerificationContext validateIntegrity(
    Insertable<SemiBudget> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('budget_id')) {
      context.handle(
        _budgetIdMeta,
        budgetId.isAcceptableOrUnknown(data['budget_id']!, _budgetIdMeta),
      );
    } else if (isInserting) {
      context.missing(_budgetIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('limit_amount')) {
      context.handle(
        _limitAmountMeta,
        limitAmount.isAcceptableOrUnknown(
          data['limit_amount']!,
          _limitAmountMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_limitAmountMeta);
    }
    if (data.containsKey('priority')) {
      context.handle(
        _priorityMeta,
        priority.isAcceptableOrUnknown(data['priority']!, _priorityMeta),
      );
    }
    if (data.containsKey('icon_name')) {
      context.handle(
        _iconNameMeta,
        iconName.isAcceptableOrUnknown(data['icon_name']!, _iconNameMeta),
      );
    }
    if (data.containsKey('color_hex')) {
      context.handle(
        _colorHexMeta,
        colorHex.isAcceptableOrUnknown(data['color_hex']!, _colorHexMeta),
      );
    }
    if (data.containsKey('parent_category_id')) {
      context.handle(
        _parentCategoryIdMeta,
        parentCategoryId.isAcceptableOrUnknown(
          data['parent_category_id']!,
          _parentCategoryIdMeta,
        ),
      );
    }
    if (data.containsKey('is_subcategory')) {
      context.handle(
        _isSubcategoryMeta,
        isSubcategory.isAcceptableOrUnknown(
          data['is_subcategory']!,
          _isSubcategoryMeta,
        ),
      );
    }
    if (data.containsKey('suggested_percent')) {
      context.handle(
        _suggestedPercentMeta,
        suggestedPercent.isAcceptableOrUnknown(
          data['suggested_percent']!,
          _suggestedPercentMeta,
        ),
      );
    }
    if (data.containsKey('display_order')) {
      context.handle(
        _displayOrderMeta,
        displayOrder.isAcceptableOrUnknown(
          data['display_order']!,
          _displayOrderMeta,
        ),
      );
    }
    if (data.containsKey('master_category_id')) {
      context.handle(
        _masterCategoryIdMeta,
        masterCategoryId.isAcceptableOrUnknown(
          data['master_category_id']!,
          _masterCategoryIdMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('base_revision')) {
      context.handle(
        _baseRevisionMeta,
        baseRevision.isAcceptableOrUnknown(
          data['base_revision']!,
          _baseRevisionMeta,
        ),
      );
    }
    if (data.containsKey('operation_id')) {
      context.handle(
        _operationIdMeta,
        operationId.isAcceptableOrUnknown(
          data['operation_id']!,
          _operationIdMeta,
        ),
      );
    }
    if (data.containsKey('last_modified_by_device_id')) {
      context.handle(
        _lastModifiedByDeviceIdMeta,
        lastModifiedByDeviceId.isAcceptableOrUnknown(
          data['last_modified_by_device_id']!,
          _lastModifiedByDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SemiBudget map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SemiBudget(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      budgetId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}budget_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      limitAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}limit_amount'],
      )!,
      priority: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}priority'],
      )!,
      iconName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}icon_name'],
      ),
      colorHex: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color_hex'],
      ),
      metadata: $SemiBudgetsTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      parentCategoryId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}parent_category_id'],
      ),
      isSubcategory: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_subcategory'],
      )!,
      suggestedPercent: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}suggested_percent'],
      ),
      displayOrder: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}display_order'],
      )!,
      masterCategoryId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}master_category_id'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      baseRevision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}base_revision'],
      ),
      operationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation_id'],
      ),
      lastModifiedByDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_modified_by_device_id'],
      ),
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $SemiBudgetsTable createAlias(String alias) {
    return $SemiBudgetsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class SemiBudget extends DataClass implements Insertable<SemiBudget> {
  final String id;
  final String budgetId;
  final String name;
  final int limitAmount;
  final int priority;
  final String? iconName;
  final String? colorHex;
  final Map<String, dynamic>? metadata;
  final String? parentCategoryId;
  final bool isSubcategory;
  final double? suggestedPercent;
  final int displayOrder;
  final String? masterCategoryId;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final int? baseRevision;
  final String? operationId;
  final String? lastModifiedByDeviceId;
  final bool isDeleted;
  final String syncState;
  final int lamportClock;
  final String? versionVector;
  const SemiBudget({
    required this.id,
    required this.budgetId,
    required this.name,
    required this.limitAmount,
    required this.priority,
    this.iconName,
    this.colorHex,
    this.metadata,
    this.parentCategoryId,
    required this.isSubcategory,
    this.suggestedPercent,
    required this.displayOrder,
    this.masterCategoryId,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    this.baseRevision,
    this.operationId,
    this.lastModifiedByDeviceId,
    required this.isDeleted,
    required this.syncState,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['budget_id'] = Variable<String>(budgetId);
    map['name'] = Variable<String>(name);
    map['limit_amount'] = Variable<int>(limitAmount);
    map['priority'] = Variable<int>(priority);
    if (!nullToAbsent || iconName != null) {
      map['icon_name'] = Variable<String>(iconName);
    }
    if (!nullToAbsent || colorHex != null) {
      map['color_hex'] = Variable<String>(colorHex);
    }
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $SemiBudgetsTable.$convertermetadatan.toSql(metadata),
      );
    }
    if (!nullToAbsent || parentCategoryId != null) {
      map['parent_category_id'] = Variable<String>(parentCategoryId);
    }
    map['is_subcategory'] = Variable<bool>(isSubcategory);
    if (!nullToAbsent || suggestedPercent != null) {
      map['suggested_percent'] = Variable<double>(suggestedPercent);
    }
    map['display_order'] = Variable<int>(displayOrder);
    if (!nullToAbsent || masterCategoryId != null) {
      map['master_category_id'] = Variable<String>(masterCategoryId);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    if (!nullToAbsent || baseRevision != null) {
      map['base_revision'] = Variable<int>(baseRevision);
    }
    if (!nullToAbsent || operationId != null) {
      map['operation_id'] = Variable<String>(operationId);
    }
    if (!nullToAbsent || lastModifiedByDeviceId != null) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId,
      );
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['sync_state'] = Variable<String>(syncState);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  SemiBudgetsCompanion toCompanion(bool nullToAbsent) {
    return SemiBudgetsCompanion(
      id: Value(id),
      budgetId: Value(budgetId),
      name: Value(name),
      limitAmount: Value(limitAmount),
      priority: Value(priority),
      iconName: iconName == null && nullToAbsent
          ? const Value.absent()
          : Value(iconName),
      colorHex: colorHex == null && nullToAbsent
          ? const Value.absent()
          : Value(colorHex),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      parentCategoryId: parentCategoryId == null && nullToAbsent
          ? const Value.absent()
          : Value(parentCategoryId),
      isSubcategory: Value(isSubcategory),
      suggestedPercent: suggestedPercent == null && nullToAbsent
          ? const Value.absent()
          : Value(suggestedPercent),
      displayOrder: Value(displayOrder),
      masterCategoryId: masterCategoryId == null && nullToAbsent
          ? const Value.absent()
          : Value(masterCategoryId),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      baseRevision: baseRevision == null && nullToAbsent
          ? const Value.absent()
          : Value(baseRevision),
      operationId: operationId == null && nullToAbsent
          ? const Value.absent()
          : Value(operationId),
      lastModifiedByDeviceId: lastModifiedByDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedByDeviceId),
      isDeleted: Value(isDeleted),
      syncState: Value(syncState),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory SemiBudget.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SemiBudget(
      id: serializer.fromJson<String>(json['id']),
      budgetId: serializer.fromJson<String>(json['budgetId']),
      name: serializer.fromJson<String>(json['name']),
      limitAmount: serializer.fromJson<int>(json['limitAmount']),
      priority: serializer.fromJson<int>(json['priority']),
      iconName: serializer.fromJson<String?>(json['iconName']),
      colorHex: serializer.fromJson<String?>(json['colorHex']),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      parentCategoryId: serializer.fromJson<String?>(json['parentCategoryId']),
      isSubcategory: serializer.fromJson<bool>(json['isSubcategory']),
      suggestedPercent: serializer.fromJson<double?>(json['suggestedPercent']),
      displayOrder: serializer.fromJson<int>(json['displayOrder']),
      masterCategoryId: serializer.fromJson<String?>(json['masterCategoryId']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      baseRevision: serializer.fromJson<int?>(json['baseRevision']),
      operationId: serializer.fromJson<String?>(json['operationId']),
      lastModifiedByDeviceId: serializer.fromJson<String?>(
        json['lastModifiedByDeviceId'],
      ),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncState: serializer.fromJson<String>(json['syncState']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'budgetId': serializer.toJson<String>(budgetId),
      'name': serializer.toJson<String>(name),
      'limitAmount': serializer.toJson<int>(limitAmount),
      'priority': serializer.toJson<int>(priority),
      'iconName': serializer.toJson<String?>(iconName),
      'colorHex': serializer.toJson<String?>(colorHex),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'parentCategoryId': serializer.toJson<String?>(parentCategoryId),
      'isSubcategory': serializer.toJson<bool>(isSubcategory),
      'suggestedPercent': serializer.toJson<double?>(suggestedPercent),
      'displayOrder': serializer.toJson<int>(displayOrder),
      'masterCategoryId': serializer.toJson<String?>(masterCategoryId),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'baseRevision': serializer.toJson<int?>(baseRevision),
      'operationId': serializer.toJson<String?>(operationId),
      'lastModifiedByDeviceId': serializer.toJson<String?>(
        lastModifiedByDeviceId,
      ),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncState': serializer.toJson<String>(syncState),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  SemiBudget copyWith({
    String? id,
    String? budgetId,
    String? name,
    int? limitAmount,
    int? priority,
    Value<String?> iconName = const Value.absent(),
    Value<String?> colorHex = const Value.absent(),
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    Value<String?> parentCategoryId = const Value.absent(),
    bool? isSubcategory,
    Value<double?> suggestedPercent = const Value.absent(),
    int? displayOrder,
    Value<String?> masterCategoryId = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    Value<int?> baseRevision = const Value.absent(),
    Value<String?> operationId = const Value.absent(),
    Value<String?> lastModifiedByDeviceId = const Value.absent(),
    bool? isDeleted,
    String? syncState,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => SemiBudget(
    id: id ?? this.id,
    budgetId: budgetId ?? this.budgetId,
    name: name ?? this.name,
    limitAmount: limitAmount ?? this.limitAmount,
    priority: priority ?? this.priority,
    iconName: iconName.present ? iconName.value : this.iconName,
    colorHex: colorHex.present ? colorHex.value : this.colorHex,
    metadata: metadata.present ? metadata.value : this.metadata,
    parentCategoryId: parentCategoryId.present
        ? parentCategoryId.value
        : this.parentCategoryId,
    isSubcategory: isSubcategory ?? this.isSubcategory,
    suggestedPercent: suggestedPercent.present
        ? suggestedPercent.value
        : this.suggestedPercent,
    displayOrder: displayOrder ?? this.displayOrder,
    masterCategoryId: masterCategoryId.present
        ? masterCategoryId.value
        : this.masterCategoryId,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    baseRevision: baseRevision.present ? baseRevision.value : this.baseRevision,
    operationId: operationId.present ? operationId.value : this.operationId,
    lastModifiedByDeviceId: lastModifiedByDeviceId.present
        ? lastModifiedByDeviceId.value
        : this.lastModifiedByDeviceId,
    isDeleted: isDeleted ?? this.isDeleted,
    syncState: syncState ?? this.syncState,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  SemiBudget copyWithCompanion(SemiBudgetsCompanion data) {
    return SemiBudget(
      id: data.id.present ? data.id.value : this.id,
      budgetId: data.budgetId.present ? data.budgetId.value : this.budgetId,
      name: data.name.present ? data.name.value : this.name,
      limitAmount: data.limitAmount.present
          ? data.limitAmount.value
          : this.limitAmount,
      priority: data.priority.present ? data.priority.value : this.priority,
      iconName: data.iconName.present ? data.iconName.value : this.iconName,
      colorHex: data.colorHex.present ? data.colorHex.value : this.colorHex,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      parentCategoryId: data.parentCategoryId.present
          ? data.parentCategoryId.value
          : this.parentCategoryId,
      isSubcategory: data.isSubcategory.present
          ? data.isSubcategory.value
          : this.isSubcategory,
      suggestedPercent: data.suggestedPercent.present
          ? data.suggestedPercent.value
          : this.suggestedPercent,
      displayOrder: data.displayOrder.present
          ? data.displayOrder.value
          : this.displayOrder,
      masterCategoryId: data.masterCategoryId.present
          ? data.masterCategoryId.value
          : this.masterCategoryId,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      baseRevision: data.baseRevision.present
          ? data.baseRevision.value
          : this.baseRevision,
      operationId: data.operationId.present
          ? data.operationId.value
          : this.operationId,
      lastModifiedByDeviceId: data.lastModifiedByDeviceId.present
          ? data.lastModifiedByDeviceId.value
          : this.lastModifiedByDeviceId,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SemiBudget(')
          ..write('id: $id, ')
          ..write('budgetId: $budgetId, ')
          ..write('name: $name, ')
          ..write('limitAmount: $limitAmount, ')
          ..write('priority: $priority, ')
          ..write('iconName: $iconName, ')
          ..write('colorHex: $colorHex, ')
          ..write('metadata: $metadata, ')
          ..write('parentCategoryId: $parentCategoryId, ')
          ..write('isSubcategory: $isSubcategory, ')
          ..write('suggestedPercent: $suggestedPercent, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('masterCategoryId: $masterCategoryId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    budgetId,
    name,
    limitAmount,
    priority,
    iconName,
    colorHex,
    metadata,
    parentCategoryId,
    isSubcategory,
    suggestedPercent,
    displayOrder,
    masterCategoryId,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    isDeleted,
    syncState,
    lamportClock,
    versionVector,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SemiBudget &&
          other.id == this.id &&
          other.budgetId == this.budgetId &&
          other.name == this.name &&
          other.limitAmount == this.limitAmount &&
          other.priority == this.priority &&
          other.iconName == this.iconName &&
          other.colorHex == this.colorHex &&
          other.metadata == this.metadata &&
          other.parentCategoryId == this.parentCategoryId &&
          other.isSubcategory == this.isSubcategory &&
          other.suggestedPercent == this.suggestedPercent &&
          other.displayOrder == this.displayOrder &&
          other.masterCategoryId == this.masterCategoryId &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.baseRevision == this.baseRevision &&
          other.operationId == this.operationId &&
          other.lastModifiedByDeviceId == this.lastModifiedByDeviceId &&
          other.isDeleted == this.isDeleted &&
          other.syncState == this.syncState &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class SemiBudgetsCompanion extends UpdateCompanion<SemiBudget> {
  final Value<String> id;
  final Value<String> budgetId;
  final Value<String> name;
  final Value<int> limitAmount;
  final Value<int> priority;
  final Value<String?> iconName;
  final Value<String?> colorHex;
  final Value<Map<String, dynamic>?> metadata;
  final Value<String?> parentCategoryId;
  final Value<bool> isSubcategory;
  final Value<double?> suggestedPercent;
  final Value<int> displayOrder;
  final Value<String?> masterCategoryId;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<int?> baseRevision;
  final Value<String?> operationId;
  final Value<String?> lastModifiedByDeviceId;
  final Value<bool> isDeleted;
  final Value<String> syncState;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const SemiBudgetsCompanion({
    this.id = const Value.absent(),
    this.budgetId = const Value.absent(),
    this.name = const Value.absent(),
    this.limitAmount = const Value.absent(),
    this.priority = const Value.absent(),
    this.iconName = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.metadata = const Value.absent(),
    this.parentCategoryId = const Value.absent(),
    this.isSubcategory = const Value.absent(),
    this.suggestedPercent = const Value.absent(),
    this.displayOrder = const Value.absent(),
    this.masterCategoryId = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SemiBudgetsCompanion.insert({
    required String id,
    required String budgetId,
    required String name,
    required int limitAmount,
    this.priority = const Value.absent(),
    this.iconName = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.metadata = const Value.absent(),
    this.parentCategoryId = const Value.absent(),
    this.isSubcategory = const Value.absent(),
    this.suggestedPercent = const Value.absent(),
    this.displayOrder = const Value.absent(),
    this.masterCategoryId = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       budgetId = Value(budgetId),
       name = Value(name),
       limitAmount = Value(limitAmount);
  static Insertable<SemiBudget> custom({
    Expression<String>? id,
    Expression<String>? budgetId,
    Expression<String>? name,
    Expression<int>? limitAmount,
    Expression<int>? priority,
    Expression<String>? iconName,
    Expression<String>? colorHex,
    Expression<String>? metadata,
    Expression<String>? parentCategoryId,
    Expression<bool>? isSubcategory,
    Expression<double>? suggestedPercent,
    Expression<int>? displayOrder,
    Expression<String>? masterCategoryId,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<int>? baseRevision,
    Expression<String>? operationId,
    Expression<String>? lastModifiedByDeviceId,
    Expression<bool>? isDeleted,
    Expression<String>? syncState,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (budgetId != null) 'budget_id': budgetId,
      if (name != null) 'name': name,
      if (limitAmount != null) 'limit_amount': limitAmount,
      if (priority != null) 'priority': priority,
      if (iconName != null) 'icon_name': iconName,
      if (colorHex != null) 'color_hex': colorHex,
      if (metadata != null) 'metadata': metadata,
      if (parentCategoryId != null) 'parent_category_id': parentCategoryId,
      if (isSubcategory != null) 'is_subcategory': isSubcategory,
      if (suggestedPercent != null) 'suggested_percent': suggestedPercent,
      if (displayOrder != null) 'display_order': displayOrder,
      if (masterCategoryId != null) 'master_category_id': masterCategoryId,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (baseRevision != null) 'base_revision': baseRevision,
      if (operationId != null) 'operation_id': operationId,
      if (lastModifiedByDeviceId != null)
        'last_modified_by_device_id': lastModifiedByDeviceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncState != null) 'sync_state': syncState,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SemiBudgetsCompanion copyWith({
    Value<String>? id,
    Value<String>? budgetId,
    Value<String>? name,
    Value<int>? limitAmount,
    Value<int>? priority,
    Value<String?>? iconName,
    Value<String?>? colorHex,
    Value<Map<String, dynamic>?>? metadata,
    Value<String?>? parentCategoryId,
    Value<bool>? isSubcategory,
    Value<double?>? suggestedPercent,
    Value<int>? displayOrder,
    Value<String?>? masterCategoryId,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<int?>? baseRevision,
    Value<String?>? operationId,
    Value<String?>? lastModifiedByDeviceId,
    Value<bool>? isDeleted,
    Value<String>? syncState,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return SemiBudgetsCompanion(
      id: id ?? this.id,
      budgetId: budgetId ?? this.budgetId,
      name: name ?? this.name,
      limitAmount: limitAmount ?? this.limitAmount,
      priority: priority ?? this.priority,
      iconName: iconName ?? this.iconName,
      colorHex: colorHex ?? this.colorHex,
      metadata: metadata ?? this.metadata,
      parentCategoryId: parentCategoryId ?? this.parentCategoryId,
      isSubcategory: isSubcategory ?? this.isSubcategory,
      suggestedPercent: suggestedPercent ?? this.suggestedPercent,
      displayOrder: displayOrder ?? this.displayOrder,
      masterCategoryId: masterCategoryId ?? this.masterCategoryId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      baseRevision: baseRevision ?? this.baseRevision,
      operationId: operationId ?? this.operationId,
      lastModifiedByDeviceId:
          lastModifiedByDeviceId ?? this.lastModifiedByDeviceId,
      isDeleted: isDeleted ?? this.isDeleted,
      syncState: syncState ?? this.syncState,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (budgetId.present) {
      map['budget_id'] = Variable<String>(budgetId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (limitAmount.present) {
      map['limit_amount'] = Variable<int>(limitAmount.value);
    }
    if (priority.present) {
      map['priority'] = Variable<int>(priority.value);
    }
    if (iconName.present) {
      map['icon_name'] = Variable<String>(iconName.value);
    }
    if (colorHex.present) {
      map['color_hex'] = Variable<String>(colorHex.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $SemiBudgetsTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (parentCategoryId.present) {
      map['parent_category_id'] = Variable<String>(parentCategoryId.value);
    }
    if (isSubcategory.present) {
      map['is_subcategory'] = Variable<bool>(isSubcategory.value);
    }
    if (suggestedPercent.present) {
      map['suggested_percent'] = Variable<double>(suggestedPercent.value);
    }
    if (displayOrder.present) {
      map['display_order'] = Variable<int>(displayOrder.value);
    }
    if (masterCategoryId.present) {
      map['master_category_id'] = Variable<String>(masterCategoryId.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (baseRevision.present) {
      map['base_revision'] = Variable<int>(baseRevision.value);
    }
    if (operationId.present) {
      map['operation_id'] = Variable<String>(operationId.value);
    }
    if (lastModifiedByDeviceId.present) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId.value,
      );
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SemiBudgetsCompanion(')
          ..write('id: $id, ')
          ..write('budgetId: $budgetId, ')
          ..write('name: $name, ')
          ..write('limitAmount: $limitAmount, ')
          ..write('priority: $priority, ')
          ..write('iconName: $iconName, ')
          ..write('colorHex: $colorHex, ')
          ..write('metadata: $metadata, ')
          ..write('parentCategoryId: $parentCategoryId, ')
          ..write('isSubcategory: $isSubcategory, ')
          ..write('suggestedPercent: $suggestedPercent, ')
          ..write('displayOrder: $displayOrder, ')
          ..write('masterCategoryId: $masterCategoryId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AccountsTable extends Accounts with TableInfo<$AccountsTable, Account> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AccountsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _balanceMeta = const VerificationMeta(
    'balance',
  );
  @override
  late final GeneratedColumn<int> balance = GeneratedColumn<int>(
    'balance',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currencyMeta = const VerificationMeta(
    'currency',
  );
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
    'currency',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('EUR'),
  );
  static const VerificationMeta _iconNameMeta = const VerificationMeta(
    'iconName',
  );
  @override
  late final GeneratedColumn<String> iconName = GeneratedColumn<String>(
    'icon_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _colorHexMeta = const VerificationMeta(
    'colorHex',
  );
  @override
  late final GeneratedColumn<String> colorHex = GeneratedColumn<String>(
    'color_hex',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isDefaultMeta = const VerificationMeta(
    'isDefault',
  );
  @override
  late final GeneratedColumn<bool> isDefault = GeneratedColumn<bool>(
    'is_default',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_default" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _institutionNameMeta = const VerificationMeta(
    'institutionName',
  );
  @override
  late final GeneratedColumn<String> institutionName = GeneratedColumn<String>(
    'institution_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _accountNumberLast4Meta =
      const VerificationMeta('accountNumberLast4');
  @override
  late final GeneratedColumn<String> accountNumberLast4 =
      GeneratedColumn<String>(
        'account_number_last4',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata = GeneratedColumn<String>(
    'metadata',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Map<String, dynamic>?>($AccountsTable.$convertermetadatan);
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _baseRevisionMeta = const VerificationMeta(
    'baseRevision',
  );
  @override
  late final GeneratedColumn<int> baseRevision = GeneratedColumn<int>(
    'base_revision',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _operationIdMeta = const VerificationMeta(
    'operationId',
  );
  @override
  late final GeneratedColumn<String> operationId = GeneratedColumn<String>(
    'operation_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastModifiedByDeviceIdMeta =
      const VerificationMeta('lastModifiedByDeviceId');
  @override
  late final GeneratedColumn<String> lastModifiedByDeviceId =
      GeneratedColumn<String>(
        'last_modified_by_device_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    name,
    type,
    balance,
    currency,
    iconName,
    colorHex,
    isDefault,
    institutionName,
    accountNumberLast4,
    metadata,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    isDeleted,
    syncState,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'accounts';
  @override
  VerificationContext validateIntegrity(
    Insertable<Account> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('balance')) {
      context.handle(
        _balanceMeta,
        balance.isAcceptableOrUnknown(data['balance']!, _balanceMeta),
      );
    } else if (isInserting) {
      context.missing(_balanceMeta);
    }
    if (data.containsKey('currency')) {
      context.handle(
        _currencyMeta,
        currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta),
      );
    }
    if (data.containsKey('icon_name')) {
      context.handle(
        _iconNameMeta,
        iconName.isAcceptableOrUnknown(data['icon_name']!, _iconNameMeta),
      );
    }
    if (data.containsKey('color_hex')) {
      context.handle(
        _colorHexMeta,
        colorHex.isAcceptableOrUnknown(data['color_hex']!, _colorHexMeta),
      );
    }
    if (data.containsKey('is_default')) {
      context.handle(
        _isDefaultMeta,
        isDefault.isAcceptableOrUnknown(data['is_default']!, _isDefaultMeta),
      );
    }
    if (data.containsKey('institution_name')) {
      context.handle(
        _institutionNameMeta,
        institutionName.isAcceptableOrUnknown(
          data['institution_name']!,
          _institutionNameMeta,
        ),
      );
    }
    if (data.containsKey('account_number_last4')) {
      context.handle(
        _accountNumberLast4Meta,
        accountNumberLast4.isAcceptableOrUnknown(
          data['account_number_last4']!,
          _accountNumberLast4Meta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('base_revision')) {
      context.handle(
        _baseRevisionMeta,
        baseRevision.isAcceptableOrUnknown(
          data['base_revision']!,
          _baseRevisionMeta,
        ),
      );
    }
    if (data.containsKey('operation_id')) {
      context.handle(
        _operationIdMeta,
        operationId.isAcceptableOrUnknown(
          data['operation_id']!,
          _operationIdMeta,
        ),
      );
    }
    if (data.containsKey('last_modified_by_device_id')) {
      context.handle(
        _lastModifiedByDeviceIdMeta,
        lastModifiedByDeviceId.isAcceptableOrUnknown(
          data['last_modified_by_device_id']!,
          _lastModifiedByDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Account map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Account(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      balance: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}balance'],
      )!,
      currency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}currency'],
      )!,
      iconName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}icon_name'],
      ),
      colorHex: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color_hex'],
      ),
      isDefault: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_default'],
      )!,
      institutionName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}institution_name'],
      ),
      accountNumberLast4: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}account_number_last4'],
      ),
      metadata: $AccountsTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      baseRevision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}base_revision'],
      ),
      operationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation_id'],
      ),
      lastModifiedByDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_modified_by_device_id'],
      ),
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $AccountsTable createAlias(String alias) {
    return $AccountsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class Account extends DataClass implements Insertable<Account> {
  final String id;
  final String userId;
  final String name;
  final String type;
  final int balance;
  final String currency;
  final String? iconName;
  final String? colorHex;
  final bool isDefault;
  final String? institutionName;
  final String? accountNumberLast4;
  final Map<String, dynamic>? metadata;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final int? baseRevision;
  final String? operationId;
  final String? lastModifiedByDeviceId;
  final bool isDeleted;
  final String syncState;
  final int lamportClock;
  final String? versionVector;
  const Account({
    required this.id,
    required this.userId,
    required this.name,
    required this.type,
    required this.balance,
    required this.currency,
    this.iconName,
    this.colorHex,
    required this.isDefault,
    this.institutionName,
    this.accountNumberLast4,
    this.metadata,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    this.baseRevision,
    this.operationId,
    this.lastModifiedByDeviceId,
    required this.isDeleted,
    required this.syncState,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['name'] = Variable<String>(name);
    map['type'] = Variable<String>(type);
    map['balance'] = Variable<int>(balance);
    map['currency'] = Variable<String>(currency);
    if (!nullToAbsent || iconName != null) {
      map['icon_name'] = Variable<String>(iconName);
    }
    if (!nullToAbsent || colorHex != null) {
      map['color_hex'] = Variable<String>(colorHex);
    }
    map['is_default'] = Variable<bool>(isDefault);
    if (!nullToAbsent || institutionName != null) {
      map['institution_name'] = Variable<String>(institutionName);
    }
    if (!nullToAbsent || accountNumberLast4 != null) {
      map['account_number_last4'] = Variable<String>(accountNumberLast4);
    }
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $AccountsTable.$convertermetadatan.toSql(metadata),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    if (!nullToAbsent || baseRevision != null) {
      map['base_revision'] = Variable<int>(baseRevision);
    }
    if (!nullToAbsent || operationId != null) {
      map['operation_id'] = Variable<String>(operationId);
    }
    if (!nullToAbsent || lastModifiedByDeviceId != null) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId,
      );
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['sync_state'] = Variable<String>(syncState);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  AccountsCompanion toCompanion(bool nullToAbsent) {
    return AccountsCompanion(
      id: Value(id),
      userId: Value(userId),
      name: Value(name),
      type: Value(type),
      balance: Value(balance),
      currency: Value(currency),
      iconName: iconName == null && nullToAbsent
          ? const Value.absent()
          : Value(iconName),
      colorHex: colorHex == null && nullToAbsent
          ? const Value.absent()
          : Value(colorHex),
      isDefault: Value(isDefault),
      institutionName: institutionName == null && nullToAbsent
          ? const Value.absent()
          : Value(institutionName),
      accountNumberLast4: accountNumberLast4 == null && nullToAbsent
          ? const Value.absent()
          : Value(accountNumberLast4),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      baseRevision: baseRevision == null && nullToAbsent
          ? const Value.absent()
          : Value(baseRevision),
      operationId: operationId == null && nullToAbsent
          ? const Value.absent()
          : Value(operationId),
      lastModifiedByDeviceId: lastModifiedByDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedByDeviceId),
      isDeleted: Value(isDeleted),
      syncState: Value(syncState),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory Account.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Account(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      name: serializer.fromJson<String>(json['name']),
      type: serializer.fromJson<String>(json['type']),
      balance: serializer.fromJson<int>(json['balance']),
      currency: serializer.fromJson<String>(json['currency']),
      iconName: serializer.fromJson<String?>(json['iconName']),
      colorHex: serializer.fromJson<String?>(json['colorHex']),
      isDefault: serializer.fromJson<bool>(json['isDefault']),
      institutionName: serializer.fromJson<String?>(json['institutionName']),
      accountNumberLast4: serializer.fromJson<String?>(
        json['accountNumberLast4'],
      ),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      baseRevision: serializer.fromJson<int?>(json['baseRevision']),
      operationId: serializer.fromJson<String?>(json['operationId']),
      lastModifiedByDeviceId: serializer.fromJson<String?>(
        json['lastModifiedByDeviceId'],
      ),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncState: serializer.fromJson<String>(json['syncState']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'name': serializer.toJson<String>(name),
      'type': serializer.toJson<String>(type),
      'balance': serializer.toJson<int>(balance),
      'currency': serializer.toJson<String>(currency),
      'iconName': serializer.toJson<String?>(iconName),
      'colorHex': serializer.toJson<String?>(colorHex),
      'isDefault': serializer.toJson<bool>(isDefault),
      'institutionName': serializer.toJson<String?>(institutionName),
      'accountNumberLast4': serializer.toJson<String?>(accountNumberLast4),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'baseRevision': serializer.toJson<int?>(baseRevision),
      'operationId': serializer.toJson<String?>(operationId),
      'lastModifiedByDeviceId': serializer.toJson<String?>(
        lastModifiedByDeviceId,
      ),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncState': serializer.toJson<String>(syncState),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  Account copyWith({
    String? id,
    String? userId,
    String? name,
    String? type,
    int? balance,
    String? currency,
    Value<String?> iconName = const Value.absent(),
    Value<String?> colorHex = const Value.absent(),
    bool? isDefault,
    Value<String?> institutionName = const Value.absent(),
    Value<String?> accountNumberLast4 = const Value.absent(),
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    Value<int?> baseRevision = const Value.absent(),
    Value<String?> operationId = const Value.absent(),
    Value<String?> lastModifiedByDeviceId = const Value.absent(),
    bool? isDeleted,
    String? syncState,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => Account(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    name: name ?? this.name,
    type: type ?? this.type,
    balance: balance ?? this.balance,
    currency: currency ?? this.currency,
    iconName: iconName.present ? iconName.value : this.iconName,
    colorHex: colorHex.present ? colorHex.value : this.colorHex,
    isDefault: isDefault ?? this.isDefault,
    institutionName: institutionName.present
        ? institutionName.value
        : this.institutionName,
    accountNumberLast4: accountNumberLast4.present
        ? accountNumberLast4.value
        : this.accountNumberLast4,
    metadata: metadata.present ? metadata.value : this.metadata,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    baseRevision: baseRevision.present ? baseRevision.value : this.baseRevision,
    operationId: operationId.present ? operationId.value : this.operationId,
    lastModifiedByDeviceId: lastModifiedByDeviceId.present
        ? lastModifiedByDeviceId.value
        : this.lastModifiedByDeviceId,
    isDeleted: isDeleted ?? this.isDeleted,
    syncState: syncState ?? this.syncState,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  Account copyWithCompanion(AccountsCompanion data) {
    return Account(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      name: data.name.present ? data.name.value : this.name,
      type: data.type.present ? data.type.value : this.type,
      balance: data.balance.present ? data.balance.value : this.balance,
      currency: data.currency.present ? data.currency.value : this.currency,
      iconName: data.iconName.present ? data.iconName.value : this.iconName,
      colorHex: data.colorHex.present ? data.colorHex.value : this.colorHex,
      isDefault: data.isDefault.present ? data.isDefault.value : this.isDefault,
      institutionName: data.institutionName.present
          ? data.institutionName.value
          : this.institutionName,
      accountNumberLast4: data.accountNumberLast4.present
          ? data.accountNumberLast4.value
          : this.accountNumberLast4,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      baseRevision: data.baseRevision.present
          ? data.baseRevision.value
          : this.baseRevision,
      operationId: data.operationId.present
          ? data.operationId.value
          : this.operationId,
      lastModifiedByDeviceId: data.lastModifiedByDeviceId.present
          ? data.lastModifiedByDeviceId.value
          : this.lastModifiedByDeviceId,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Account(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('name: $name, ')
          ..write('type: $type, ')
          ..write('balance: $balance, ')
          ..write('currency: $currency, ')
          ..write('iconName: $iconName, ')
          ..write('colorHex: $colorHex, ')
          ..write('isDefault: $isDefault, ')
          ..write('institutionName: $institutionName, ')
          ..write('accountNumberLast4: $accountNumberLast4, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    userId,
    name,
    type,
    balance,
    currency,
    iconName,
    colorHex,
    isDefault,
    institutionName,
    accountNumberLast4,
    metadata,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    isDeleted,
    syncState,
    lamportClock,
    versionVector,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Account &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.name == this.name &&
          other.type == this.type &&
          other.balance == this.balance &&
          other.currency == this.currency &&
          other.iconName == this.iconName &&
          other.colorHex == this.colorHex &&
          other.isDefault == this.isDefault &&
          other.institutionName == this.institutionName &&
          other.accountNumberLast4 == this.accountNumberLast4 &&
          other.metadata == this.metadata &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.baseRevision == this.baseRevision &&
          other.operationId == this.operationId &&
          other.lastModifiedByDeviceId == this.lastModifiedByDeviceId &&
          other.isDeleted == this.isDeleted &&
          other.syncState == this.syncState &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class AccountsCompanion extends UpdateCompanion<Account> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String> name;
  final Value<String> type;
  final Value<int> balance;
  final Value<String> currency;
  final Value<String?> iconName;
  final Value<String?> colorHex;
  final Value<bool> isDefault;
  final Value<String?> institutionName;
  final Value<String?> accountNumberLast4;
  final Value<Map<String, dynamic>?> metadata;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<int?> baseRevision;
  final Value<String?> operationId;
  final Value<String?> lastModifiedByDeviceId;
  final Value<bool> isDeleted;
  final Value<String> syncState;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const AccountsCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.name = const Value.absent(),
    this.type = const Value.absent(),
    this.balance = const Value.absent(),
    this.currency = const Value.absent(),
    this.iconName = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.institutionName = const Value.absent(),
    this.accountNumberLast4 = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AccountsCompanion.insert({
    required String id,
    required String userId,
    required String name,
    required String type,
    required int balance,
    this.currency = const Value.absent(),
    this.iconName = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.isDefault = const Value.absent(),
    this.institutionName = const Value.absent(),
    this.accountNumberLast4 = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       name = Value(name),
       type = Value(type),
       balance = Value(balance);
  static Insertable<Account> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? name,
    Expression<String>? type,
    Expression<int>? balance,
    Expression<String>? currency,
    Expression<String>? iconName,
    Expression<String>? colorHex,
    Expression<bool>? isDefault,
    Expression<String>? institutionName,
    Expression<String>? accountNumberLast4,
    Expression<String>? metadata,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<int>? baseRevision,
    Expression<String>? operationId,
    Expression<String>? lastModifiedByDeviceId,
    Expression<bool>? isDeleted,
    Expression<String>? syncState,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (name != null) 'name': name,
      if (type != null) 'type': type,
      if (balance != null) 'balance': balance,
      if (currency != null) 'currency': currency,
      if (iconName != null) 'icon_name': iconName,
      if (colorHex != null) 'color_hex': colorHex,
      if (isDefault != null) 'is_default': isDefault,
      if (institutionName != null) 'institution_name': institutionName,
      if (accountNumberLast4 != null)
        'account_number_last4': accountNumberLast4,
      if (metadata != null) 'metadata': metadata,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (baseRevision != null) 'base_revision': baseRevision,
      if (operationId != null) 'operation_id': operationId,
      if (lastModifiedByDeviceId != null)
        'last_modified_by_device_id': lastModifiedByDeviceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncState != null) 'sync_state': syncState,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AccountsCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String>? name,
    Value<String>? type,
    Value<int>? balance,
    Value<String>? currency,
    Value<String?>? iconName,
    Value<String?>? colorHex,
    Value<bool>? isDefault,
    Value<String?>? institutionName,
    Value<String?>? accountNumberLast4,
    Value<Map<String, dynamic>?>? metadata,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<int?>? baseRevision,
    Value<String?>? operationId,
    Value<String?>? lastModifiedByDeviceId,
    Value<bool>? isDeleted,
    Value<String>? syncState,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return AccountsCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      name: name ?? this.name,
      type: type ?? this.type,
      balance: balance ?? this.balance,
      currency: currency ?? this.currency,
      iconName: iconName ?? this.iconName,
      colorHex: colorHex ?? this.colorHex,
      isDefault: isDefault ?? this.isDefault,
      institutionName: institutionName ?? this.institutionName,
      accountNumberLast4: accountNumberLast4 ?? this.accountNumberLast4,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      baseRevision: baseRevision ?? this.baseRevision,
      operationId: operationId ?? this.operationId,
      lastModifiedByDeviceId:
          lastModifiedByDeviceId ?? this.lastModifiedByDeviceId,
      isDeleted: isDeleted ?? this.isDeleted,
      syncState: syncState ?? this.syncState,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (balance.present) {
      map['balance'] = Variable<int>(balance.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (iconName.present) {
      map['icon_name'] = Variable<String>(iconName.value);
    }
    if (colorHex.present) {
      map['color_hex'] = Variable<String>(colorHex.value);
    }
    if (isDefault.present) {
      map['is_default'] = Variable<bool>(isDefault.value);
    }
    if (institutionName.present) {
      map['institution_name'] = Variable<String>(institutionName.value);
    }
    if (accountNumberLast4.present) {
      map['account_number_last4'] = Variable<String>(accountNumberLast4.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $AccountsTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (baseRevision.present) {
      map['base_revision'] = Variable<int>(baseRevision.value);
    }
    if (operationId.present) {
      map['operation_id'] = Variable<String>(operationId.value);
    }
    if (lastModifiedByDeviceId.present) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId.value,
      );
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AccountsCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('name: $name, ')
          ..write('type: $type, ')
          ..write('balance: $balance, ')
          ..write('currency: $currency, ')
          ..write('iconName: $iconName, ')
          ..write('colorHex: $colorHex, ')
          ..write('isDefault: $isDefault, ')
          ..write('institutionName: $institutionName, ')
          ..write('accountNumberLast4: $accountNumberLast4, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SubCategoriesTable extends SubCategories
    with TableInfo<$SubCategoriesTable, SubCategory> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SubCategoriesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _categoryIdMeta = const VerificationMeta(
    'categoryId',
  );
  @override
  late final GeneratedColumn<String> categoryId = GeneratedColumn<String>(
    'category_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES categories (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _ownerIdMeta = const VerificationMeta(
    'ownerId',
  );
  @override
  late final GeneratedColumn<String> ownerId = GeneratedColumn<String>(
    'owner_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _isSystemMeta = const VerificationMeta(
    'isSystem',
  );
  @override
  late final GeneratedColumn<bool> isSystem = GeneratedColumn<bool>(
    'is_system',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_system" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _isDefaultOtherMeta = const VerificationMeta(
    'isDefaultOther',
  );
  @override
  late final GeneratedColumn<bool> isDefaultOther = GeneratedColumn<bool>(
    'is_default_other',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_default_other" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _usageCountMeta = const VerificationMeta(
    'usageCount',
  );
  @override
  late final GeneratedColumn<int> usageCount = GeneratedColumn<int>(
    'usage_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _lastUsedAtMeta = const VerificationMeta(
    'lastUsedAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastUsedAt = GeneratedColumn<DateTime>(
    'last_used_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _confidenceMeta = const VerificationMeta(
    'confidence',
  );
  @override
  late final GeneratedColumn<double> confidence = GeneratedColumn<double>(
    'confidence',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(1.0),
  );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    categoryId,
    name,
    ownerId,
    isSystem,
    isDefaultOther,
    usageCount,
    lastUsedAt,
    confidence,
    isDeleted,
    createdAt,
    updatedAt,
    revision,
    syncState,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sub_categories';
  @override
  VerificationContext validateIntegrity(
    Insertable<SubCategory> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('category_id')) {
      context.handle(
        _categoryIdMeta,
        categoryId.isAcceptableOrUnknown(data['category_id']!, _categoryIdMeta),
      );
    } else if (isInserting) {
      context.missing(_categoryIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('owner_id')) {
      context.handle(
        _ownerIdMeta,
        ownerId.isAcceptableOrUnknown(data['owner_id']!, _ownerIdMeta),
      );
    }
    if (data.containsKey('is_system')) {
      context.handle(
        _isSystemMeta,
        isSystem.isAcceptableOrUnknown(data['is_system']!, _isSystemMeta),
      );
    }
    if (data.containsKey('is_default_other')) {
      context.handle(
        _isDefaultOtherMeta,
        isDefaultOther.isAcceptableOrUnknown(
          data['is_default_other']!,
          _isDefaultOtherMeta,
        ),
      );
    }
    if (data.containsKey('usage_count')) {
      context.handle(
        _usageCountMeta,
        usageCount.isAcceptableOrUnknown(data['usage_count']!, _usageCountMeta),
      );
    }
    if (data.containsKey('last_used_at')) {
      context.handle(
        _lastUsedAtMeta,
        lastUsedAt.isAcceptableOrUnknown(
          data['last_used_at']!,
          _lastUsedAtMeta,
        ),
      );
    }
    if (data.containsKey('confidence')) {
      context.handle(
        _confidenceMeta,
        confidence.isAcceptableOrUnknown(data['confidence']!, _confidenceMeta),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SubCategory map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SubCategory(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      categoryId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      ownerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_id'],
      ),
      isSystem: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_system'],
      )!,
      isDefaultOther: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_default_other'],
      )!,
      usageCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}usage_count'],
      )!,
      lastUsedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_used_at'],
      )!,
      confidence: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}confidence'],
      )!,
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $SubCategoriesTable createAlias(String alias) {
    return $SubCategoriesTable(attachedDatabase, alias);
  }
}

class SubCategory extends DataClass implements Insertable<SubCategory> {
  final String id;

  /// Links to the main Categories table
  final String categoryId;
  final String name;
  final String? ownerId;
  final bool isSystem;
  final bool isDefaultOther;
  final int usageCount;
  final DateTime lastUsedAt;
  final double confidence;
  final bool isDeleted;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final String syncState;
  final int lamportClock;
  final String? versionVector;
  const SubCategory({
    required this.id,
    required this.categoryId,
    required this.name,
    this.ownerId,
    required this.isSystem,
    required this.isDefaultOther,
    required this.usageCount,
    required this.lastUsedAt,
    required this.confidence,
    required this.isDeleted,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    required this.syncState,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['category_id'] = Variable<String>(categoryId);
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || ownerId != null) {
      map['owner_id'] = Variable<String>(ownerId);
    }
    map['is_system'] = Variable<bool>(isSystem);
    map['is_default_other'] = Variable<bool>(isDefaultOther);
    map['usage_count'] = Variable<int>(usageCount);
    map['last_used_at'] = Variable<DateTime>(lastUsedAt);
    map['confidence'] = Variable<double>(confidence);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    map['sync_state'] = Variable<String>(syncState);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  SubCategoriesCompanion toCompanion(bool nullToAbsent) {
    return SubCategoriesCompanion(
      id: Value(id),
      categoryId: Value(categoryId),
      name: Value(name),
      ownerId: ownerId == null && nullToAbsent
          ? const Value.absent()
          : Value(ownerId),
      isSystem: Value(isSystem),
      isDefaultOther: Value(isDefaultOther),
      usageCount: Value(usageCount),
      lastUsedAt: Value(lastUsedAt),
      confidence: Value(confidence),
      isDeleted: Value(isDeleted),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      syncState: Value(syncState),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory SubCategory.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SubCategory(
      id: serializer.fromJson<String>(json['id']),
      categoryId: serializer.fromJson<String>(json['categoryId']),
      name: serializer.fromJson<String>(json['name']),
      ownerId: serializer.fromJson<String?>(json['ownerId']),
      isSystem: serializer.fromJson<bool>(json['isSystem']),
      isDefaultOther: serializer.fromJson<bool>(json['isDefaultOther']),
      usageCount: serializer.fromJson<int>(json['usageCount']),
      lastUsedAt: serializer.fromJson<DateTime>(json['lastUsedAt']),
      confidence: serializer.fromJson<double>(json['confidence']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      syncState: serializer.fromJson<String>(json['syncState']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'categoryId': serializer.toJson<String>(categoryId),
      'name': serializer.toJson<String>(name),
      'ownerId': serializer.toJson<String?>(ownerId),
      'isSystem': serializer.toJson<bool>(isSystem),
      'isDefaultOther': serializer.toJson<bool>(isDefaultOther),
      'usageCount': serializer.toJson<int>(usageCount),
      'lastUsedAt': serializer.toJson<DateTime>(lastUsedAt),
      'confidence': serializer.toJson<double>(confidence),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'syncState': serializer.toJson<String>(syncState),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  SubCategory copyWith({
    String? id,
    String? categoryId,
    String? name,
    Value<String?> ownerId = const Value.absent(),
    bool? isSystem,
    bool? isDefaultOther,
    int? usageCount,
    DateTime? lastUsedAt,
    double? confidence,
    bool? isDeleted,
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    String? syncState,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => SubCategory(
    id: id ?? this.id,
    categoryId: categoryId ?? this.categoryId,
    name: name ?? this.name,
    ownerId: ownerId.present ? ownerId.value : this.ownerId,
    isSystem: isSystem ?? this.isSystem,
    isDefaultOther: isDefaultOther ?? this.isDefaultOther,
    usageCount: usageCount ?? this.usageCount,
    lastUsedAt: lastUsedAt ?? this.lastUsedAt,
    confidence: confidence ?? this.confidence,
    isDeleted: isDeleted ?? this.isDeleted,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    syncState: syncState ?? this.syncState,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  SubCategory copyWithCompanion(SubCategoriesCompanion data) {
    return SubCategory(
      id: data.id.present ? data.id.value : this.id,
      categoryId: data.categoryId.present
          ? data.categoryId.value
          : this.categoryId,
      name: data.name.present ? data.name.value : this.name,
      ownerId: data.ownerId.present ? data.ownerId.value : this.ownerId,
      isSystem: data.isSystem.present ? data.isSystem.value : this.isSystem,
      isDefaultOther: data.isDefaultOther.present
          ? data.isDefaultOther.value
          : this.isDefaultOther,
      usageCount: data.usageCount.present
          ? data.usageCount.value
          : this.usageCount,
      lastUsedAt: data.lastUsedAt.present
          ? data.lastUsedAt.value
          : this.lastUsedAt,
      confidence: data.confidence.present
          ? data.confidence.value
          : this.confidence,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SubCategory(')
          ..write('id: $id, ')
          ..write('categoryId: $categoryId, ')
          ..write('name: $name, ')
          ..write('ownerId: $ownerId, ')
          ..write('isSystem: $isSystem, ')
          ..write('isDefaultOther: $isDefaultOther, ')
          ..write('usageCount: $usageCount, ')
          ..write('lastUsedAt: $lastUsedAt, ')
          ..write('confidence: $confidence, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    categoryId,
    name,
    ownerId,
    isSystem,
    isDefaultOther,
    usageCount,
    lastUsedAt,
    confidence,
    isDeleted,
    createdAt,
    updatedAt,
    revision,
    syncState,
    lamportClock,
    versionVector,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SubCategory &&
          other.id == this.id &&
          other.categoryId == this.categoryId &&
          other.name == this.name &&
          other.ownerId == this.ownerId &&
          other.isSystem == this.isSystem &&
          other.isDefaultOther == this.isDefaultOther &&
          other.usageCount == this.usageCount &&
          other.lastUsedAt == this.lastUsedAt &&
          other.confidence == this.confidence &&
          other.isDeleted == this.isDeleted &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.syncState == this.syncState &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class SubCategoriesCompanion extends UpdateCompanion<SubCategory> {
  final Value<String> id;
  final Value<String> categoryId;
  final Value<String> name;
  final Value<String?> ownerId;
  final Value<bool> isSystem;
  final Value<bool> isDefaultOther;
  final Value<int> usageCount;
  final Value<DateTime> lastUsedAt;
  final Value<double> confidence;
  final Value<bool> isDeleted;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<String> syncState;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const SubCategoriesCompanion({
    this.id = const Value.absent(),
    this.categoryId = const Value.absent(),
    this.name = const Value.absent(),
    this.ownerId = const Value.absent(),
    this.isSystem = const Value.absent(),
    this.isDefaultOther = const Value.absent(),
    this.usageCount = const Value.absent(),
    this.lastUsedAt = const Value.absent(),
    this.confidence = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SubCategoriesCompanion.insert({
    required String id,
    required String categoryId,
    required String name,
    this.ownerId = const Value.absent(),
    this.isSystem = const Value.absent(),
    this.isDefaultOther = const Value.absent(),
    this.usageCount = const Value.absent(),
    this.lastUsedAt = const Value.absent(),
    this.confidence = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       categoryId = Value(categoryId),
       name = Value(name);
  static Insertable<SubCategory> custom({
    Expression<String>? id,
    Expression<String>? categoryId,
    Expression<String>? name,
    Expression<String>? ownerId,
    Expression<bool>? isSystem,
    Expression<bool>? isDefaultOther,
    Expression<int>? usageCount,
    Expression<DateTime>? lastUsedAt,
    Expression<double>? confidence,
    Expression<bool>? isDeleted,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<String>? syncState,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (categoryId != null) 'category_id': categoryId,
      if (name != null) 'name': name,
      if (ownerId != null) 'owner_id': ownerId,
      if (isSystem != null) 'is_system': isSystem,
      if (isDefaultOther != null) 'is_default_other': isDefaultOther,
      if (usageCount != null) 'usage_count': usageCount,
      if (lastUsedAt != null) 'last_used_at': lastUsedAt,
      if (confidence != null) 'confidence': confidence,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (syncState != null) 'sync_state': syncState,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SubCategoriesCompanion copyWith({
    Value<String>? id,
    Value<String>? categoryId,
    Value<String>? name,
    Value<String?>? ownerId,
    Value<bool>? isSystem,
    Value<bool>? isDefaultOther,
    Value<int>? usageCount,
    Value<DateTime>? lastUsedAt,
    Value<double>? confidence,
    Value<bool>? isDeleted,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<String>? syncState,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return SubCategoriesCompanion(
      id: id ?? this.id,
      categoryId: categoryId ?? this.categoryId,
      name: name ?? this.name,
      ownerId: ownerId ?? this.ownerId,
      isSystem: isSystem ?? this.isSystem,
      isDefaultOther: isDefaultOther ?? this.isDefaultOther,
      usageCount: usageCount ?? this.usageCount,
      lastUsedAt: lastUsedAt ?? this.lastUsedAt,
      confidence: confidence ?? this.confidence,
      isDeleted: isDeleted ?? this.isDeleted,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      syncState: syncState ?? this.syncState,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (categoryId.present) {
      map['category_id'] = Variable<String>(categoryId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (ownerId.present) {
      map['owner_id'] = Variable<String>(ownerId.value);
    }
    if (isSystem.present) {
      map['is_system'] = Variable<bool>(isSystem.value);
    }
    if (isDefaultOther.present) {
      map['is_default_other'] = Variable<bool>(isDefaultOther.value);
    }
    if (usageCount.present) {
      map['usage_count'] = Variable<int>(usageCount.value);
    }
    if (lastUsedAt.present) {
      map['last_used_at'] = Variable<DateTime>(lastUsedAt.value);
    }
    if (confidence.present) {
      map['confidence'] = Variable<double>(confidence.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SubCategoriesCompanion(')
          ..write('id: $id, ')
          ..write('categoryId: $categoryId, ')
          ..write('name: $name, ')
          ..write('ownerId: $ownerId, ')
          ..write('isSystem: $isSystem, ')
          ..write('isDefaultOther: $isDefaultOther, ')
          ..write('usageCount: $usageCount, ')
          ..write('lastUsedAt: $lastUsedAt, ')
          ..write('confidence: $confidence, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ExpensesTable extends Expenses with TableInfo<$ExpensesTable, Expense> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ExpensesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _budgetIdMeta = const VerificationMeta(
    'budgetId',
  );
  @override
  late final GeneratedColumn<String> budgetId = GeneratedColumn<String>(
    'budget_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES budgets (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _categoryIdMeta = const VerificationMeta(
    'categoryId',
  );
  @override
  late final GeneratedColumn<String> categoryId = GeneratedColumn<String>(
    'category_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES categories (id)',
    ),
  );
  static const VerificationMeta _subCategoryIdMeta = const VerificationMeta(
    'subCategoryId',
  );
  @override
  late final GeneratedColumn<String> subCategoryId = GeneratedColumn<String>(
    'sub_category_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES sub_categories (id)',
    ),
  );
  static const VerificationMeta _semiBudgetIdMeta = const VerificationMeta(
    'semiBudgetId',
  );
  @override
  late final GeneratedColumn<String> semiBudgetId = GeneratedColumn<String>(
    'semi_budget_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES semi_budgets (id) ON DELETE SET NULL',
    ),
  );
  static const VerificationMeta _enteredByMeta = const VerificationMeta(
    'enteredBy',
  );
  @override
  late final GeneratedColumn<String> enteredBy = GeneratedColumn<String>(
    'entered_by',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<int> amount = GeneratedColumn<int>(
    'amount',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currencyMeta = const VerificationMeta(
    'currency',
  );
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
    'currency',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('EUR'),
  );
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
    'date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _accountIdMeta = const VerificationMeta(
    'accountId',
  );
  @override
  late final GeneratedColumn<String> accountId = GeneratedColumn<String>(
    'account_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES accounts (id)',
    ),
  );
  static const VerificationMeta _merchantNameMeta = const VerificationMeta(
    'merchantName',
  );
  @override
  late final GeneratedColumn<String> merchantName = GeneratedColumn<String>(
    'merchant_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _paymentMethodMeta = const VerificationMeta(
    'paymentMethod',
  );
  @override
  late final GeneratedColumn<String> paymentMethod = GeneratedColumn<String>(
    'payment_method',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('cash'),
  );
  static const VerificationMeta _receiptUrlMeta = const VerificationMeta(
    'receiptUrl',
  );
  @override
  late final GeneratedColumn<String> receiptUrl = GeneratedColumn<String>(
    'receipt_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _barcodeValueMeta = const VerificationMeta(
    'barcodeValue',
  );
  @override
  late final GeneratedColumn<String> barcodeValue = GeneratedColumn<String>(
    'barcode_value',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _ocrTextMeta = const VerificationMeta(
    'ocrText',
  );
  @override
  late final GeneratedColumn<String> ocrText = GeneratedColumn<String>(
    'ocr_text',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _attachmentsMeta = const VerificationMeta(
    'attachments',
  );
  @override
  late final GeneratedColumn<String> attachments = GeneratedColumn<String>(
    'attachments',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _locationNameMeta = const VerificationMeta(
    'locationName',
  );
  @override
  late final GeneratedColumn<String> locationName = GeneratedColumn<String>(
    'location_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _tagsMeta = const VerificationMeta('tags');
  @override
  late final GeneratedColumn<String> tags = GeneratedColumn<String>(
    'tags',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isRecurringMeta = const VerificationMeta(
    'isRecurring',
  );
  @override
  late final GeneratedColumn<bool> isRecurring = GeneratedColumn<bool>(
    'is_recurring',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_recurring" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _recurringIdMeta = const VerificationMeta(
    'recurringId',
  );
  @override
  late final GeneratedColumn<String> recurringId = GeneratedColumn<String>(
    'recurring_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata = GeneratedColumn<String>(
    'metadata',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Map<String, dynamic>?>($ExpensesTable.$convertermetadatan);
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _baseRevisionMeta = const VerificationMeta(
    'baseRevision',
  );
  @override
  late final GeneratedColumn<int> baseRevision = GeneratedColumn<int>(
    'base_revision',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _operationIdMeta = const VerificationMeta(
    'operationId',
  );
  @override
  late final GeneratedColumn<String> operationId = GeneratedColumn<String>(
    'operation_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastModifiedByDeviceIdMeta =
      const VerificationMeta('lastModifiedByDeviceId');
  @override
  late final GeneratedColumn<String> lastModifiedByDeviceId =
      GeneratedColumn<String>(
        'last_modified_by_device_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _globalSeqMeta = const VerificationMeta(
    'globalSeq',
  );
  @override
  late final GeneratedColumn<int> globalSeq = GeneratedColumn<int>(
    'global_seq',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _subCategoryRawMeta = const VerificationMeta(
    'subCategoryRaw',
  );
  @override
  late final GeneratedColumn<String> subCategoryRaw = GeneratedColumn<String>(
    'sub_category_raw',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _semanticTokensMeta = const VerificationMeta(
    'semanticTokens',
  );
  @override
  late final GeneratedColumn<String> semanticTokens = GeneratedColumn<String>(
    'semantic_tokens',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _confidenceMeta = const VerificationMeta(
    'confidence',
  );
  @override
  late final GeneratedColumn<double> confidence = GeneratedColumn<double>(
    'confidence',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(1.0),
  );
  static const VerificationMeta _sourceMeta = const VerificationMeta('source');
  @override
  late final GeneratedColumn<String> source = GeneratedColumn<String>(
    'source',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('manual'),
  );
  static const VerificationMeta _isAiAssignedMeta = const VerificationMeta(
    'isAiAssigned',
  );
  @override
  late final GeneratedColumn<bool> isAiAssigned = GeneratedColumn<bool>(
    'is_ai_assigned',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_ai_assigned" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isVerifiedMeta = const VerificationMeta(
    'isVerified',
  );
  @override
  late final GeneratedColumn<bool> isVerified = GeneratedColumn<bool>(
    'is_verified',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_verified" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _moodMeta = const VerificationMeta('mood');
  @override
  late final GeneratedColumn<String> mood = GeneratedColumn<String>(
    'mood',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _socialContextMeta = const VerificationMeta(
    'socialContext',
  );
  @override
  late final GeneratedColumn<String> socialContext = GeneratedColumn<String>(
    'social_context',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _bankTransactionIdMeta = const VerificationMeta(
    'bankTransactionId',
  );
  @override
  late final GeneratedColumn<String> bankTransactionId =
      GeneratedColumn<String>(
        'bank_transaction_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
        defaultConstraints: GeneratedColumn.constraintIsAlways('UNIQUE'),
      );
  static const VerificationMeta _isTransferMeta = const VerificationMeta(
    'isTransfer',
  );
  @override
  late final GeneratedColumn<bool> isTransfer = GeneratedColumn<bool>(
    'is_transfer',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_transfer" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isReconciledMeta = const VerificationMeta(
    'isReconciled',
  );
  @override
  late final GeneratedColumn<bool> isReconciled = GeneratedColumn<bool>(
    'is_reconciled',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_reconciled" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _isRefundMeta = const VerificationMeta(
    'isRefund',
  );
  @override
  late final GeneratedColumn<bool> isRefund = GeneratedColumn<bool>(
    'is_refund',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_refund" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    budgetId,
    categoryId,
    subCategoryId,
    semiBudgetId,
    enteredBy,
    title,
    amount,
    currency,
    date,
    accountId,
    merchantName,
    paymentMethod,
    receiptUrl,
    barcodeValue,
    ocrText,
    attachments,
    notes,
    locationName,
    tags,
    isRecurring,
    recurringId,
    metadata,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    isDeleted,
    globalSeq,
    syncState,
    lamportClock,
    versionVector,
    subCategoryRaw,
    semanticTokens,
    confidence,
    source,
    isAiAssigned,
    isVerified,
    mood,
    socialContext,
    bankTransactionId,
    isTransfer,
    isReconciled,
    isRefund,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'expenses';
  @override
  VerificationContext validateIntegrity(
    Insertable<Expense> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('budget_id')) {
      context.handle(
        _budgetIdMeta,
        budgetId.isAcceptableOrUnknown(data['budget_id']!, _budgetIdMeta),
      );
    } else if (isInserting) {
      context.missing(_budgetIdMeta);
    }
    if (data.containsKey('category_id')) {
      context.handle(
        _categoryIdMeta,
        categoryId.isAcceptableOrUnknown(data['category_id']!, _categoryIdMeta),
      );
    }
    if (data.containsKey('sub_category_id')) {
      context.handle(
        _subCategoryIdMeta,
        subCategoryId.isAcceptableOrUnknown(
          data['sub_category_id']!,
          _subCategoryIdMeta,
        ),
      );
    }
    if (data.containsKey('semi_budget_id')) {
      context.handle(
        _semiBudgetIdMeta,
        semiBudgetId.isAcceptableOrUnknown(
          data['semi_budget_id']!,
          _semiBudgetIdMeta,
        ),
      );
    }
    if (data.containsKey('entered_by')) {
      context.handle(
        _enteredByMeta,
        enteredBy.isAcceptableOrUnknown(data['entered_by']!, _enteredByMeta),
      );
    } else if (isInserting) {
      context.missing(_enteredByMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(
        _amountMeta,
        amount.isAcceptableOrUnknown(data['amount']!, _amountMeta),
      );
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('currency')) {
      context.handle(
        _currencyMeta,
        currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta),
      );
    }
    if (data.containsKey('date')) {
      context.handle(
        _dateMeta,
        date.isAcceptableOrUnknown(data['date']!, _dateMeta),
      );
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('account_id')) {
      context.handle(
        _accountIdMeta,
        accountId.isAcceptableOrUnknown(data['account_id']!, _accountIdMeta),
      );
    }
    if (data.containsKey('merchant_name')) {
      context.handle(
        _merchantNameMeta,
        merchantName.isAcceptableOrUnknown(
          data['merchant_name']!,
          _merchantNameMeta,
        ),
      );
    }
    if (data.containsKey('payment_method')) {
      context.handle(
        _paymentMethodMeta,
        paymentMethod.isAcceptableOrUnknown(
          data['payment_method']!,
          _paymentMethodMeta,
        ),
      );
    }
    if (data.containsKey('receipt_url')) {
      context.handle(
        _receiptUrlMeta,
        receiptUrl.isAcceptableOrUnknown(data['receipt_url']!, _receiptUrlMeta),
      );
    }
    if (data.containsKey('barcode_value')) {
      context.handle(
        _barcodeValueMeta,
        barcodeValue.isAcceptableOrUnknown(
          data['barcode_value']!,
          _barcodeValueMeta,
        ),
      );
    }
    if (data.containsKey('ocr_text')) {
      context.handle(
        _ocrTextMeta,
        ocrText.isAcceptableOrUnknown(data['ocr_text']!, _ocrTextMeta),
      );
    }
    if (data.containsKey('attachments')) {
      context.handle(
        _attachmentsMeta,
        attachments.isAcceptableOrUnknown(
          data['attachments']!,
          _attachmentsMeta,
        ),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('location_name')) {
      context.handle(
        _locationNameMeta,
        locationName.isAcceptableOrUnknown(
          data['location_name']!,
          _locationNameMeta,
        ),
      );
    }
    if (data.containsKey('tags')) {
      context.handle(
        _tagsMeta,
        tags.isAcceptableOrUnknown(data['tags']!, _tagsMeta),
      );
    }
    if (data.containsKey('is_recurring')) {
      context.handle(
        _isRecurringMeta,
        isRecurring.isAcceptableOrUnknown(
          data['is_recurring']!,
          _isRecurringMeta,
        ),
      );
    }
    if (data.containsKey('recurring_id')) {
      context.handle(
        _recurringIdMeta,
        recurringId.isAcceptableOrUnknown(
          data['recurring_id']!,
          _recurringIdMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('base_revision')) {
      context.handle(
        _baseRevisionMeta,
        baseRevision.isAcceptableOrUnknown(
          data['base_revision']!,
          _baseRevisionMeta,
        ),
      );
    }
    if (data.containsKey('operation_id')) {
      context.handle(
        _operationIdMeta,
        operationId.isAcceptableOrUnknown(
          data['operation_id']!,
          _operationIdMeta,
        ),
      );
    }
    if (data.containsKey('last_modified_by_device_id')) {
      context.handle(
        _lastModifiedByDeviceIdMeta,
        lastModifiedByDeviceId.isAcceptableOrUnknown(
          data['last_modified_by_device_id']!,
          _lastModifiedByDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('global_seq')) {
      context.handle(
        _globalSeqMeta,
        globalSeq.isAcceptableOrUnknown(data['global_seq']!, _globalSeqMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    if (data.containsKey('sub_category_raw')) {
      context.handle(
        _subCategoryRawMeta,
        subCategoryRaw.isAcceptableOrUnknown(
          data['sub_category_raw']!,
          _subCategoryRawMeta,
        ),
      );
    }
    if (data.containsKey('semantic_tokens')) {
      context.handle(
        _semanticTokensMeta,
        semanticTokens.isAcceptableOrUnknown(
          data['semantic_tokens']!,
          _semanticTokensMeta,
        ),
      );
    }
    if (data.containsKey('confidence')) {
      context.handle(
        _confidenceMeta,
        confidence.isAcceptableOrUnknown(data['confidence']!, _confidenceMeta),
      );
    }
    if (data.containsKey('source')) {
      context.handle(
        _sourceMeta,
        source.isAcceptableOrUnknown(data['source']!, _sourceMeta),
      );
    }
    if (data.containsKey('is_ai_assigned')) {
      context.handle(
        _isAiAssignedMeta,
        isAiAssigned.isAcceptableOrUnknown(
          data['is_ai_assigned']!,
          _isAiAssignedMeta,
        ),
      );
    }
    if (data.containsKey('is_verified')) {
      context.handle(
        _isVerifiedMeta,
        isVerified.isAcceptableOrUnknown(data['is_verified']!, _isVerifiedMeta),
      );
    }
    if (data.containsKey('mood')) {
      context.handle(
        _moodMeta,
        mood.isAcceptableOrUnknown(data['mood']!, _moodMeta),
      );
    }
    if (data.containsKey('social_context')) {
      context.handle(
        _socialContextMeta,
        socialContext.isAcceptableOrUnknown(
          data['social_context']!,
          _socialContextMeta,
        ),
      );
    }
    if (data.containsKey('bank_transaction_id')) {
      context.handle(
        _bankTransactionIdMeta,
        bankTransactionId.isAcceptableOrUnknown(
          data['bank_transaction_id']!,
          _bankTransactionIdMeta,
        ),
      );
    }
    if (data.containsKey('is_transfer')) {
      context.handle(
        _isTransferMeta,
        isTransfer.isAcceptableOrUnknown(data['is_transfer']!, _isTransferMeta),
      );
    }
    if (data.containsKey('is_reconciled')) {
      context.handle(
        _isReconciledMeta,
        isReconciled.isAcceptableOrUnknown(
          data['is_reconciled']!,
          _isReconciledMeta,
        ),
      );
    }
    if (data.containsKey('is_refund')) {
      context.handle(
        _isRefundMeta,
        isRefund.isAcceptableOrUnknown(data['is_refund']!, _isRefundMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Expense map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Expense(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      budgetId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}budget_id'],
      )!,
      categoryId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category_id'],
      ),
      subCategoryId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sub_category_id'],
      ),
      semiBudgetId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}semi_budget_id'],
      ),
      enteredBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entered_by'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      amount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}amount'],
      )!,
      currency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}currency'],
      )!,
      date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date'],
      )!,
      accountId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}account_id'],
      ),
      merchantName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}merchant_name'],
      ),
      paymentMethod: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payment_method'],
      )!,
      receiptUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}receipt_url'],
      ),
      barcodeValue: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}barcode_value'],
      ),
      ocrText: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}ocr_text'],
      ),
      attachments: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}attachments'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      locationName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}location_name'],
      ),
      tags: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tags'],
      ),
      isRecurring: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_recurring'],
      )!,
      recurringId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}recurring_id'],
      ),
      metadata: $ExpensesTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      baseRevision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}base_revision'],
      ),
      operationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation_id'],
      ),
      lastModifiedByDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_modified_by_device_id'],
      ),
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      globalSeq: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}global_seq'],
      ),
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
      subCategoryRaw: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sub_category_raw'],
      ),
      semanticTokens: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}semantic_tokens'],
      ),
      confidence: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}confidence'],
      )!,
      source: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source'],
      )!,
      isAiAssigned: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_ai_assigned'],
      )!,
      isVerified: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_verified'],
      )!,
      mood: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}mood'],
      ),
      socialContext: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}social_context'],
      ),
      bankTransactionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}bank_transaction_id'],
      ),
      isTransfer: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_transfer'],
      )!,
      isReconciled: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_reconciled'],
      )!,
      isRefund: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_refund'],
      )!,
    );
  }

  @override
  $ExpensesTable createAlias(String alias) {
    return $ExpensesTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class Expense extends DataClass implements Insertable<Expense> {
  final String id;
  final String budgetId;
  final String? categoryId;
  final String? subCategoryId;
  final String? semiBudgetId;
  final String enteredBy;
  final String title;
  final int amount;
  final String currency;
  final DateTime date;
  final String? accountId;
  final String? merchantName;
  final String paymentMethod;
  final String? receiptUrl;
  final String? barcodeValue;
  final String? ocrText;
  final String? attachments;
  final String? notes;
  final String? locationName;
  final String? tags;
  final bool isRecurring;
  final String? recurringId;
  final Map<String, dynamic>? metadata;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final int? baseRevision;
  final String? operationId;
  final String? lastModifiedByDeviceId;
  final bool isDeleted;
  final int? globalSeq;
  final String syncState;
  final int lamportClock;
  final String? versionVector;
  final String? subCategoryRaw;
  final String? semanticTokens;
  final double confidence;
  final String source;
  final bool isAiAssigned;
  final bool isVerified;
  final String? mood;
  final String? socialContext;
  final String? bankTransactionId;
  final bool isTransfer;
  final bool isReconciled;
  final bool isRefund;
  const Expense({
    required this.id,
    required this.budgetId,
    this.categoryId,
    this.subCategoryId,
    this.semiBudgetId,
    required this.enteredBy,
    required this.title,
    required this.amount,
    required this.currency,
    required this.date,
    this.accountId,
    this.merchantName,
    required this.paymentMethod,
    this.receiptUrl,
    this.barcodeValue,
    this.ocrText,
    this.attachments,
    this.notes,
    this.locationName,
    this.tags,
    required this.isRecurring,
    this.recurringId,
    this.metadata,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    this.baseRevision,
    this.operationId,
    this.lastModifiedByDeviceId,
    required this.isDeleted,
    this.globalSeq,
    required this.syncState,
    required this.lamportClock,
    this.versionVector,
    this.subCategoryRaw,
    this.semanticTokens,
    required this.confidence,
    required this.source,
    required this.isAiAssigned,
    required this.isVerified,
    this.mood,
    this.socialContext,
    this.bankTransactionId,
    required this.isTransfer,
    required this.isReconciled,
    required this.isRefund,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['budget_id'] = Variable<String>(budgetId);
    if (!nullToAbsent || categoryId != null) {
      map['category_id'] = Variable<String>(categoryId);
    }
    if (!nullToAbsent || subCategoryId != null) {
      map['sub_category_id'] = Variable<String>(subCategoryId);
    }
    if (!nullToAbsent || semiBudgetId != null) {
      map['semi_budget_id'] = Variable<String>(semiBudgetId);
    }
    map['entered_by'] = Variable<String>(enteredBy);
    map['title'] = Variable<String>(title);
    map['amount'] = Variable<int>(amount);
    map['currency'] = Variable<String>(currency);
    map['date'] = Variable<DateTime>(date);
    if (!nullToAbsent || accountId != null) {
      map['account_id'] = Variable<String>(accountId);
    }
    if (!nullToAbsent || merchantName != null) {
      map['merchant_name'] = Variable<String>(merchantName);
    }
    map['payment_method'] = Variable<String>(paymentMethod);
    if (!nullToAbsent || receiptUrl != null) {
      map['receipt_url'] = Variable<String>(receiptUrl);
    }
    if (!nullToAbsent || barcodeValue != null) {
      map['barcode_value'] = Variable<String>(barcodeValue);
    }
    if (!nullToAbsent || ocrText != null) {
      map['ocr_text'] = Variable<String>(ocrText);
    }
    if (!nullToAbsent || attachments != null) {
      map['attachments'] = Variable<String>(attachments);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    if (!nullToAbsent || locationName != null) {
      map['location_name'] = Variable<String>(locationName);
    }
    if (!nullToAbsent || tags != null) {
      map['tags'] = Variable<String>(tags);
    }
    map['is_recurring'] = Variable<bool>(isRecurring);
    if (!nullToAbsent || recurringId != null) {
      map['recurring_id'] = Variable<String>(recurringId);
    }
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $ExpensesTable.$convertermetadatan.toSql(metadata),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    if (!nullToAbsent || baseRevision != null) {
      map['base_revision'] = Variable<int>(baseRevision);
    }
    if (!nullToAbsent || operationId != null) {
      map['operation_id'] = Variable<String>(operationId);
    }
    if (!nullToAbsent || lastModifiedByDeviceId != null) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId,
      );
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || globalSeq != null) {
      map['global_seq'] = Variable<int>(globalSeq);
    }
    map['sync_state'] = Variable<String>(syncState);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    if (!nullToAbsent || subCategoryRaw != null) {
      map['sub_category_raw'] = Variable<String>(subCategoryRaw);
    }
    if (!nullToAbsent || semanticTokens != null) {
      map['semantic_tokens'] = Variable<String>(semanticTokens);
    }
    map['confidence'] = Variable<double>(confidence);
    map['source'] = Variable<String>(source);
    map['is_ai_assigned'] = Variable<bool>(isAiAssigned);
    map['is_verified'] = Variable<bool>(isVerified);
    if (!nullToAbsent || mood != null) {
      map['mood'] = Variable<String>(mood);
    }
    if (!nullToAbsent || socialContext != null) {
      map['social_context'] = Variable<String>(socialContext);
    }
    if (!nullToAbsent || bankTransactionId != null) {
      map['bank_transaction_id'] = Variable<String>(bankTransactionId);
    }
    map['is_transfer'] = Variable<bool>(isTransfer);
    map['is_reconciled'] = Variable<bool>(isReconciled);
    map['is_refund'] = Variable<bool>(isRefund);
    return map;
  }

  ExpensesCompanion toCompanion(bool nullToAbsent) {
    return ExpensesCompanion(
      id: Value(id),
      budgetId: Value(budgetId),
      categoryId: categoryId == null && nullToAbsent
          ? const Value.absent()
          : Value(categoryId),
      subCategoryId: subCategoryId == null && nullToAbsent
          ? const Value.absent()
          : Value(subCategoryId),
      semiBudgetId: semiBudgetId == null && nullToAbsent
          ? const Value.absent()
          : Value(semiBudgetId),
      enteredBy: Value(enteredBy),
      title: Value(title),
      amount: Value(amount),
      currency: Value(currency),
      date: Value(date),
      accountId: accountId == null && nullToAbsent
          ? const Value.absent()
          : Value(accountId),
      merchantName: merchantName == null && nullToAbsent
          ? const Value.absent()
          : Value(merchantName),
      paymentMethod: Value(paymentMethod),
      receiptUrl: receiptUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(receiptUrl),
      barcodeValue: barcodeValue == null && nullToAbsent
          ? const Value.absent()
          : Value(barcodeValue),
      ocrText: ocrText == null && nullToAbsent
          ? const Value.absent()
          : Value(ocrText),
      attachments: attachments == null && nullToAbsent
          ? const Value.absent()
          : Value(attachments),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      locationName: locationName == null && nullToAbsent
          ? const Value.absent()
          : Value(locationName),
      tags: tags == null && nullToAbsent ? const Value.absent() : Value(tags),
      isRecurring: Value(isRecurring),
      recurringId: recurringId == null && nullToAbsent
          ? const Value.absent()
          : Value(recurringId),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      baseRevision: baseRevision == null && nullToAbsent
          ? const Value.absent()
          : Value(baseRevision),
      operationId: operationId == null && nullToAbsent
          ? const Value.absent()
          : Value(operationId),
      lastModifiedByDeviceId: lastModifiedByDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedByDeviceId),
      isDeleted: Value(isDeleted),
      globalSeq: globalSeq == null && nullToAbsent
          ? const Value.absent()
          : Value(globalSeq),
      syncState: Value(syncState),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
      subCategoryRaw: subCategoryRaw == null && nullToAbsent
          ? const Value.absent()
          : Value(subCategoryRaw),
      semanticTokens: semanticTokens == null && nullToAbsent
          ? const Value.absent()
          : Value(semanticTokens),
      confidence: Value(confidence),
      source: Value(source),
      isAiAssigned: Value(isAiAssigned),
      isVerified: Value(isVerified),
      mood: mood == null && nullToAbsent ? const Value.absent() : Value(mood),
      socialContext: socialContext == null && nullToAbsent
          ? const Value.absent()
          : Value(socialContext),
      bankTransactionId: bankTransactionId == null && nullToAbsent
          ? const Value.absent()
          : Value(bankTransactionId),
      isTransfer: Value(isTransfer),
      isReconciled: Value(isReconciled),
      isRefund: Value(isRefund),
    );
  }

  factory Expense.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Expense(
      id: serializer.fromJson<String>(json['id']),
      budgetId: serializer.fromJson<String>(json['budgetId']),
      categoryId: serializer.fromJson<String?>(json['categoryId']),
      subCategoryId: serializer.fromJson<String?>(json['subCategoryId']),
      semiBudgetId: serializer.fromJson<String?>(json['semiBudgetId']),
      enteredBy: serializer.fromJson<String>(json['enteredBy']),
      title: serializer.fromJson<String>(json['title']),
      amount: serializer.fromJson<int>(json['amount']),
      currency: serializer.fromJson<String>(json['currency']),
      date: serializer.fromJson<DateTime>(json['date']),
      accountId: serializer.fromJson<String?>(json['accountId']),
      merchantName: serializer.fromJson<String?>(json['merchantName']),
      paymentMethod: serializer.fromJson<String>(json['paymentMethod']),
      receiptUrl: serializer.fromJson<String?>(json['receiptUrl']),
      barcodeValue: serializer.fromJson<String?>(json['barcodeValue']),
      ocrText: serializer.fromJson<String?>(json['ocrText']),
      attachments: serializer.fromJson<String?>(json['attachments']),
      notes: serializer.fromJson<String?>(json['notes']),
      locationName: serializer.fromJson<String?>(json['locationName']),
      tags: serializer.fromJson<String?>(json['tags']),
      isRecurring: serializer.fromJson<bool>(json['isRecurring']),
      recurringId: serializer.fromJson<String?>(json['recurringId']),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      baseRevision: serializer.fromJson<int?>(json['baseRevision']),
      operationId: serializer.fromJson<String?>(json['operationId']),
      lastModifiedByDeviceId: serializer.fromJson<String?>(
        json['lastModifiedByDeviceId'],
      ),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      globalSeq: serializer.fromJson<int?>(json['globalSeq']),
      syncState: serializer.fromJson<String>(json['syncState']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
      subCategoryRaw: serializer.fromJson<String?>(json['subCategoryRaw']),
      semanticTokens: serializer.fromJson<String?>(json['semanticTokens']),
      confidence: serializer.fromJson<double>(json['confidence']),
      source: serializer.fromJson<String>(json['source']),
      isAiAssigned: serializer.fromJson<bool>(json['isAiAssigned']),
      isVerified: serializer.fromJson<bool>(json['isVerified']),
      mood: serializer.fromJson<String?>(json['mood']),
      socialContext: serializer.fromJson<String?>(json['socialContext']),
      bankTransactionId: serializer.fromJson<String?>(
        json['bankTransactionId'],
      ),
      isTransfer: serializer.fromJson<bool>(json['isTransfer']),
      isReconciled: serializer.fromJson<bool>(json['isReconciled']),
      isRefund: serializer.fromJson<bool>(json['isRefund']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'budgetId': serializer.toJson<String>(budgetId),
      'categoryId': serializer.toJson<String?>(categoryId),
      'subCategoryId': serializer.toJson<String?>(subCategoryId),
      'semiBudgetId': serializer.toJson<String?>(semiBudgetId),
      'enteredBy': serializer.toJson<String>(enteredBy),
      'title': serializer.toJson<String>(title),
      'amount': serializer.toJson<int>(amount),
      'currency': serializer.toJson<String>(currency),
      'date': serializer.toJson<DateTime>(date),
      'accountId': serializer.toJson<String?>(accountId),
      'merchantName': serializer.toJson<String?>(merchantName),
      'paymentMethod': serializer.toJson<String>(paymentMethod),
      'receiptUrl': serializer.toJson<String?>(receiptUrl),
      'barcodeValue': serializer.toJson<String?>(barcodeValue),
      'ocrText': serializer.toJson<String?>(ocrText),
      'attachments': serializer.toJson<String?>(attachments),
      'notes': serializer.toJson<String?>(notes),
      'locationName': serializer.toJson<String?>(locationName),
      'tags': serializer.toJson<String?>(tags),
      'isRecurring': serializer.toJson<bool>(isRecurring),
      'recurringId': serializer.toJson<String?>(recurringId),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'baseRevision': serializer.toJson<int?>(baseRevision),
      'operationId': serializer.toJson<String?>(operationId),
      'lastModifiedByDeviceId': serializer.toJson<String?>(
        lastModifiedByDeviceId,
      ),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'globalSeq': serializer.toJson<int?>(globalSeq),
      'syncState': serializer.toJson<String>(syncState),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
      'subCategoryRaw': serializer.toJson<String?>(subCategoryRaw),
      'semanticTokens': serializer.toJson<String?>(semanticTokens),
      'confidence': serializer.toJson<double>(confidence),
      'source': serializer.toJson<String>(source),
      'isAiAssigned': serializer.toJson<bool>(isAiAssigned),
      'isVerified': serializer.toJson<bool>(isVerified),
      'mood': serializer.toJson<String?>(mood),
      'socialContext': serializer.toJson<String?>(socialContext),
      'bankTransactionId': serializer.toJson<String?>(bankTransactionId),
      'isTransfer': serializer.toJson<bool>(isTransfer),
      'isReconciled': serializer.toJson<bool>(isReconciled),
      'isRefund': serializer.toJson<bool>(isRefund),
    };
  }

  Expense copyWith({
    String? id,
    String? budgetId,
    Value<String?> categoryId = const Value.absent(),
    Value<String?> subCategoryId = const Value.absent(),
    Value<String?> semiBudgetId = const Value.absent(),
    String? enteredBy,
    String? title,
    int? amount,
    String? currency,
    DateTime? date,
    Value<String?> accountId = const Value.absent(),
    Value<String?> merchantName = const Value.absent(),
    String? paymentMethod,
    Value<String?> receiptUrl = const Value.absent(),
    Value<String?> barcodeValue = const Value.absent(),
    Value<String?> ocrText = const Value.absent(),
    Value<String?> attachments = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    Value<String?> locationName = const Value.absent(),
    Value<String?> tags = const Value.absent(),
    bool? isRecurring,
    Value<String?> recurringId = const Value.absent(),
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    Value<int?> baseRevision = const Value.absent(),
    Value<String?> operationId = const Value.absent(),
    Value<String?> lastModifiedByDeviceId = const Value.absent(),
    bool? isDeleted,
    Value<int?> globalSeq = const Value.absent(),
    String? syncState,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
    Value<String?> subCategoryRaw = const Value.absent(),
    Value<String?> semanticTokens = const Value.absent(),
    double? confidence,
    String? source,
    bool? isAiAssigned,
    bool? isVerified,
    Value<String?> mood = const Value.absent(),
    Value<String?> socialContext = const Value.absent(),
    Value<String?> bankTransactionId = const Value.absent(),
    bool? isTransfer,
    bool? isReconciled,
    bool? isRefund,
  }) => Expense(
    id: id ?? this.id,
    budgetId: budgetId ?? this.budgetId,
    categoryId: categoryId.present ? categoryId.value : this.categoryId,
    subCategoryId: subCategoryId.present
        ? subCategoryId.value
        : this.subCategoryId,
    semiBudgetId: semiBudgetId.present ? semiBudgetId.value : this.semiBudgetId,
    enteredBy: enteredBy ?? this.enteredBy,
    title: title ?? this.title,
    amount: amount ?? this.amount,
    currency: currency ?? this.currency,
    date: date ?? this.date,
    accountId: accountId.present ? accountId.value : this.accountId,
    merchantName: merchantName.present ? merchantName.value : this.merchantName,
    paymentMethod: paymentMethod ?? this.paymentMethod,
    receiptUrl: receiptUrl.present ? receiptUrl.value : this.receiptUrl,
    barcodeValue: barcodeValue.present ? barcodeValue.value : this.barcodeValue,
    ocrText: ocrText.present ? ocrText.value : this.ocrText,
    attachments: attachments.present ? attachments.value : this.attachments,
    notes: notes.present ? notes.value : this.notes,
    locationName: locationName.present ? locationName.value : this.locationName,
    tags: tags.present ? tags.value : this.tags,
    isRecurring: isRecurring ?? this.isRecurring,
    recurringId: recurringId.present ? recurringId.value : this.recurringId,
    metadata: metadata.present ? metadata.value : this.metadata,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    baseRevision: baseRevision.present ? baseRevision.value : this.baseRevision,
    operationId: operationId.present ? operationId.value : this.operationId,
    lastModifiedByDeviceId: lastModifiedByDeviceId.present
        ? lastModifiedByDeviceId.value
        : this.lastModifiedByDeviceId,
    isDeleted: isDeleted ?? this.isDeleted,
    globalSeq: globalSeq.present ? globalSeq.value : this.globalSeq,
    syncState: syncState ?? this.syncState,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
    subCategoryRaw: subCategoryRaw.present
        ? subCategoryRaw.value
        : this.subCategoryRaw,
    semanticTokens: semanticTokens.present
        ? semanticTokens.value
        : this.semanticTokens,
    confidence: confidence ?? this.confidence,
    source: source ?? this.source,
    isAiAssigned: isAiAssigned ?? this.isAiAssigned,
    isVerified: isVerified ?? this.isVerified,
    mood: mood.present ? mood.value : this.mood,
    socialContext: socialContext.present
        ? socialContext.value
        : this.socialContext,
    bankTransactionId: bankTransactionId.present
        ? bankTransactionId.value
        : this.bankTransactionId,
    isTransfer: isTransfer ?? this.isTransfer,
    isReconciled: isReconciled ?? this.isReconciled,
    isRefund: isRefund ?? this.isRefund,
  );
  Expense copyWithCompanion(ExpensesCompanion data) {
    return Expense(
      id: data.id.present ? data.id.value : this.id,
      budgetId: data.budgetId.present ? data.budgetId.value : this.budgetId,
      categoryId: data.categoryId.present
          ? data.categoryId.value
          : this.categoryId,
      subCategoryId: data.subCategoryId.present
          ? data.subCategoryId.value
          : this.subCategoryId,
      semiBudgetId: data.semiBudgetId.present
          ? data.semiBudgetId.value
          : this.semiBudgetId,
      enteredBy: data.enteredBy.present ? data.enteredBy.value : this.enteredBy,
      title: data.title.present ? data.title.value : this.title,
      amount: data.amount.present ? data.amount.value : this.amount,
      currency: data.currency.present ? data.currency.value : this.currency,
      date: data.date.present ? data.date.value : this.date,
      accountId: data.accountId.present ? data.accountId.value : this.accountId,
      merchantName: data.merchantName.present
          ? data.merchantName.value
          : this.merchantName,
      paymentMethod: data.paymentMethod.present
          ? data.paymentMethod.value
          : this.paymentMethod,
      receiptUrl: data.receiptUrl.present
          ? data.receiptUrl.value
          : this.receiptUrl,
      barcodeValue: data.barcodeValue.present
          ? data.barcodeValue.value
          : this.barcodeValue,
      ocrText: data.ocrText.present ? data.ocrText.value : this.ocrText,
      attachments: data.attachments.present
          ? data.attachments.value
          : this.attachments,
      notes: data.notes.present ? data.notes.value : this.notes,
      locationName: data.locationName.present
          ? data.locationName.value
          : this.locationName,
      tags: data.tags.present ? data.tags.value : this.tags,
      isRecurring: data.isRecurring.present
          ? data.isRecurring.value
          : this.isRecurring,
      recurringId: data.recurringId.present
          ? data.recurringId.value
          : this.recurringId,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      baseRevision: data.baseRevision.present
          ? data.baseRevision.value
          : this.baseRevision,
      operationId: data.operationId.present
          ? data.operationId.value
          : this.operationId,
      lastModifiedByDeviceId: data.lastModifiedByDeviceId.present
          ? data.lastModifiedByDeviceId.value
          : this.lastModifiedByDeviceId,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      globalSeq: data.globalSeq.present ? data.globalSeq.value : this.globalSeq,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
      subCategoryRaw: data.subCategoryRaw.present
          ? data.subCategoryRaw.value
          : this.subCategoryRaw,
      semanticTokens: data.semanticTokens.present
          ? data.semanticTokens.value
          : this.semanticTokens,
      confidence: data.confidence.present
          ? data.confidence.value
          : this.confidence,
      source: data.source.present ? data.source.value : this.source,
      isAiAssigned: data.isAiAssigned.present
          ? data.isAiAssigned.value
          : this.isAiAssigned,
      isVerified: data.isVerified.present
          ? data.isVerified.value
          : this.isVerified,
      mood: data.mood.present ? data.mood.value : this.mood,
      socialContext: data.socialContext.present
          ? data.socialContext.value
          : this.socialContext,
      bankTransactionId: data.bankTransactionId.present
          ? data.bankTransactionId.value
          : this.bankTransactionId,
      isTransfer: data.isTransfer.present
          ? data.isTransfer.value
          : this.isTransfer,
      isReconciled: data.isReconciled.present
          ? data.isReconciled.value
          : this.isReconciled,
      isRefund: data.isRefund.present ? data.isRefund.value : this.isRefund,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Expense(')
          ..write('id: $id, ')
          ..write('budgetId: $budgetId, ')
          ..write('categoryId: $categoryId, ')
          ..write('subCategoryId: $subCategoryId, ')
          ..write('semiBudgetId: $semiBudgetId, ')
          ..write('enteredBy: $enteredBy, ')
          ..write('title: $title, ')
          ..write('amount: $amount, ')
          ..write('currency: $currency, ')
          ..write('date: $date, ')
          ..write('accountId: $accountId, ')
          ..write('merchantName: $merchantName, ')
          ..write('paymentMethod: $paymentMethod, ')
          ..write('receiptUrl: $receiptUrl, ')
          ..write('barcodeValue: $barcodeValue, ')
          ..write('ocrText: $ocrText, ')
          ..write('attachments: $attachments, ')
          ..write('notes: $notes, ')
          ..write('locationName: $locationName, ')
          ..write('tags: $tags, ')
          ..write('isRecurring: $isRecurring, ')
          ..write('recurringId: $recurringId, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('globalSeq: $globalSeq, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('subCategoryRaw: $subCategoryRaw, ')
          ..write('semanticTokens: $semanticTokens, ')
          ..write('confidence: $confidence, ')
          ..write('source: $source, ')
          ..write('isAiAssigned: $isAiAssigned, ')
          ..write('isVerified: $isVerified, ')
          ..write('mood: $mood, ')
          ..write('socialContext: $socialContext, ')
          ..write('bankTransactionId: $bankTransactionId, ')
          ..write('isTransfer: $isTransfer, ')
          ..write('isReconciled: $isReconciled, ')
          ..write('isRefund: $isRefund')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    budgetId,
    categoryId,
    subCategoryId,
    semiBudgetId,
    enteredBy,
    title,
    amount,
    currency,
    date,
    accountId,
    merchantName,
    paymentMethod,
    receiptUrl,
    barcodeValue,
    ocrText,
    attachments,
    notes,
    locationName,
    tags,
    isRecurring,
    recurringId,
    metadata,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    isDeleted,
    globalSeq,
    syncState,
    lamportClock,
    versionVector,
    subCategoryRaw,
    semanticTokens,
    confidence,
    source,
    isAiAssigned,
    isVerified,
    mood,
    socialContext,
    bankTransactionId,
    isTransfer,
    isReconciled,
    isRefund,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Expense &&
          other.id == this.id &&
          other.budgetId == this.budgetId &&
          other.categoryId == this.categoryId &&
          other.subCategoryId == this.subCategoryId &&
          other.semiBudgetId == this.semiBudgetId &&
          other.enteredBy == this.enteredBy &&
          other.title == this.title &&
          other.amount == this.amount &&
          other.currency == this.currency &&
          other.date == this.date &&
          other.accountId == this.accountId &&
          other.merchantName == this.merchantName &&
          other.paymentMethod == this.paymentMethod &&
          other.receiptUrl == this.receiptUrl &&
          other.barcodeValue == this.barcodeValue &&
          other.ocrText == this.ocrText &&
          other.attachments == this.attachments &&
          other.notes == this.notes &&
          other.locationName == this.locationName &&
          other.tags == this.tags &&
          other.isRecurring == this.isRecurring &&
          other.recurringId == this.recurringId &&
          other.metadata == this.metadata &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.baseRevision == this.baseRevision &&
          other.operationId == this.operationId &&
          other.lastModifiedByDeviceId == this.lastModifiedByDeviceId &&
          other.isDeleted == this.isDeleted &&
          other.globalSeq == this.globalSeq &&
          other.syncState == this.syncState &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector &&
          other.subCategoryRaw == this.subCategoryRaw &&
          other.semanticTokens == this.semanticTokens &&
          other.confidence == this.confidence &&
          other.source == this.source &&
          other.isAiAssigned == this.isAiAssigned &&
          other.isVerified == this.isVerified &&
          other.mood == this.mood &&
          other.socialContext == this.socialContext &&
          other.bankTransactionId == this.bankTransactionId &&
          other.isTransfer == this.isTransfer &&
          other.isReconciled == this.isReconciled &&
          other.isRefund == this.isRefund);
}

class ExpensesCompanion extends UpdateCompanion<Expense> {
  final Value<String> id;
  final Value<String> budgetId;
  final Value<String?> categoryId;
  final Value<String?> subCategoryId;
  final Value<String?> semiBudgetId;
  final Value<String> enteredBy;
  final Value<String> title;
  final Value<int> amount;
  final Value<String> currency;
  final Value<DateTime> date;
  final Value<String?> accountId;
  final Value<String?> merchantName;
  final Value<String> paymentMethod;
  final Value<String?> receiptUrl;
  final Value<String?> barcodeValue;
  final Value<String?> ocrText;
  final Value<String?> attachments;
  final Value<String?> notes;
  final Value<String?> locationName;
  final Value<String?> tags;
  final Value<bool> isRecurring;
  final Value<String?> recurringId;
  final Value<Map<String, dynamic>?> metadata;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<int?> baseRevision;
  final Value<String?> operationId;
  final Value<String?> lastModifiedByDeviceId;
  final Value<bool> isDeleted;
  final Value<int?> globalSeq;
  final Value<String> syncState;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<String?> subCategoryRaw;
  final Value<String?> semanticTokens;
  final Value<double> confidence;
  final Value<String> source;
  final Value<bool> isAiAssigned;
  final Value<bool> isVerified;
  final Value<String?> mood;
  final Value<String?> socialContext;
  final Value<String?> bankTransactionId;
  final Value<bool> isTransfer;
  final Value<bool> isReconciled;
  final Value<bool> isRefund;
  final Value<int> rowid;
  const ExpensesCompanion({
    this.id = const Value.absent(),
    this.budgetId = const Value.absent(),
    this.categoryId = const Value.absent(),
    this.subCategoryId = const Value.absent(),
    this.semiBudgetId = const Value.absent(),
    this.enteredBy = const Value.absent(),
    this.title = const Value.absent(),
    this.amount = const Value.absent(),
    this.currency = const Value.absent(),
    this.date = const Value.absent(),
    this.accountId = const Value.absent(),
    this.merchantName = const Value.absent(),
    this.paymentMethod = const Value.absent(),
    this.receiptUrl = const Value.absent(),
    this.barcodeValue = const Value.absent(),
    this.ocrText = const Value.absent(),
    this.attachments = const Value.absent(),
    this.notes = const Value.absent(),
    this.locationName = const Value.absent(),
    this.tags = const Value.absent(),
    this.isRecurring = const Value.absent(),
    this.recurringId = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.globalSeq = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.subCategoryRaw = const Value.absent(),
    this.semanticTokens = const Value.absent(),
    this.confidence = const Value.absent(),
    this.source = const Value.absent(),
    this.isAiAssigned = const Value.absent(),
    this.isVerified = const Value.absent(),
    this.mood = const Value.absent(),
    this.socialContext = const Value.absent(),
    this.bankTransactionId = const Value.absent(),
    this.isTransfer = const Value.absent(),
    this.isReconciled = const Value.absent(),
    this.isRefund = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ExpensesCompanion.insert({
    required String id,
    required String budgetId,
    this.categoryId = const Value.absent(),
    this.subCategoryId = const Value.absent(),
    this.semiBudgetId = const Value.absent(),
    required String enteredBy,
    required String title,
    required int amount,
    this.currency = const Value.absent(),
    required DateTime date,
    this.accountId = const Value.absent(),
    this.merchantName = const Value.absent(),
    this.paymentMethod = const Value.absent(),
    this.receiptUrl = const Value.absent(),
    this.barcodeValue = const Value.absent(),
    this.ocrText = const Value.absent(),
    this.attachments = const Value.absent(),
    this.notes = const Value.absent(),
    this.locationName = const Value.absent(),
    this.tags = const Value.absent(),
    this.isRecurring = const Value.absent(),
    this.recurringId = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.globalSeq = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.subCategoryRaw = const Value.absent(),
    this.semanticTokens = const Value.absent(),
    this.confidence = const Value.absent(),
    this.source = const Value.absent(),
    this.isAiAssigned = const Value.absent(),
    this.isVerified = const Value.absent(),
    this.mood = const Value.absent(),
    this.socialContext = const Value.absent(),
    this.bankTransactionId = const Value.absent(),
    this.isTransfer = const Value.absent(),
    this.isReconciled = const Value.absent(),
    this.isRefund = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       budgetId = Value(budgetId),
       enteredBy = Value(enteredBy),
       title = Value(title),
       amount = Value(amount),
       date = Value(date);
  static Insertable<Expense> custom({
    Expression<String>? id,
    Expression<String>? budgetId,
    Expression<String>? categoryId,
    Expression<String>? subCategoryId,
    Expression<String>? semiBudgetId,
    Expression<String>? enteredBy,
    Expression<String>? title,
    Expression<int>? amount,
    Expression<String>? currency,
    Expression<DateTime>? date,
    Expression<String>? accountId,
    Expression<String>? merchantName,
    Expression<String>? paymentMethod,
    Expression<String>? receiptUrl,
    Expression<String>? barcodeValue,
    Expression<String>? ocrText,
    Expression<String>? attachments,
    Expression<String>? notes,
    Expression<String>? locationName,
    Expression<String>? tags,
    Expression<bool>? isRecurring,
    Expression<String>? recurringId,
    Expression<String>? metadata,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<int>? baseRevision,
    Expression<String>? operationId,
    Expression<String>? lastModifiedByDeviceId,
    Expression<bool>? isDeleted,
    Expression<int>? globalSeq,
    Expression<String>? syncState,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<String>? subCategoryRaw,
    Expression<String>? semanticTokens,
    Expression<double>? confidence,
    Expression<String>? source,
    Expression<bool>? isAiAssigned,
    Expression<bool>? isVerified,
    Expression<String>? mood,
    Expression<String>? socialContext,
    Expression<String>? bankTransactionId,
    Expression<bool>? isTransfer,
    Expression<bool>? isReconciled,
    Expression<bool>? isRefund,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (budgetId != null) 'budget_id': budgetId,
      if (categoryId != null) 'category_id': categoryId,
      if (subCategoryId != null) 'sub_category_id': subCategoryId,
      if (semiBudgetId != null) 'semi_budget_id': semiBudgetId,
      if (enteredBy != null) 'entered_by': enteredBy,
      if (title != null) 'title': title,
      if (amount != null) 'amount': amount,
      if (currency != null) 'currency': currency,
      if (date != null) 'date': date,
      if (accountId != null) 'account_id': accountId,
      if (merchantName != null) 'merchant_name': merchantName,
      if (paymentMethod != null) 'payment_method': paymentMethod,
      if (receiptUrl != null) 'receipt_url': receiptUrl,
      if (barcodeValue != null) 'barcode_value': barcodeValue,
      if (ocrText != null) 'ocr_text': ocrText,
      if (attachments != null) 'attachments': attachments,
      if (notes != null) 'notes': notes,
      if (locationName != null) 'location_name': locationName,
      if (tags != null) 'tags': tags,
      if (isRecurring != null) 'is_recurring': isRecurring,
      if (recurringId != null) 'recurring_id': recurringId,
      if (metadata != null) 'metadata': metadata,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (baseRevision != null) 'base_revision': baseRevision,
      if (operationId != null) 'operation_id': operationId,
      if (lastModifiedByDeviceId != null)
        'last_modified_by_device_id': lastModifiedByDeviceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (globalSeq != null) 'global_seq': globalSeq,
      if (syncState != null) 'sync_state': syncState,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (subCategoryRaw != null) 'sub_category_raw': subCategoryRaw,
      if (semanticTokens != null) 'semantic_tokens': semanticTokens,
      if (confidence != null) 'confidence': confidence,
      if (source != null) 'source': source,
      if (isAiAssigned != null) 'is_ai_assigned': isAiAssigned,
      if (isVerified != null) 'is_verified': isVerified,
      if (mood != null) 'mood': mood,
      if (socialContext != null) 'social_context': socialContext,
      if (bankTransactionId != null) 'bank_transaction_id': bankTransactionId,
      if (isTransfer != null) 'is_transfer': isTransfer,
      if (isReconciled != null) 'is_reconciled': isReconciled,
      if (isRefund != null) 'is_refund': isRefund,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ExpensesCompanion copyWith({
    Value<String>? id,
    Value<String>? budgetId,
    Value<String?>? categoryId,
    Value<String?>? subCategoryId,
    Value<String?>? semiBudgetId,
    Value<String>? enteredBy,
    Value<String>? title,
    Value<int>? amount,
    Value<String>? currency,
    Value<DateTime>? date,
    Value<String?>? accountId,
    Value<String?>? merchantName,
    Value<String>? paymentMethod,
    Value<String?>? receiptUrl,
    Value<String?>? barcodeValue,
    Value<String?>? ocrText,
    Value<String?>? attachments,
    Value<String?>? notes,
    Value<String?>? locationName,
    Value<String?>? tags,
    Value<bool>? isRecurring,
    Value<String?>? recurringId,
    Value<Map<String, dynamic>?>? metadata,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<int?>? baseRevision,
    Value<String?>? operationId,
    Value<String?>? lastModifiedByDeviceId,
    Value<bool>? isDeleted,
    Value<int?>? globalSeq,
    Value<String>? syncState,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<String?>? subCategoryRaw,
    Value<String?>? semanticTokens,
    Value<double>? confidence,
    Value<String>? source,
    Value<bool>? isAiAssigned,
    Value<bool>? isVerified,
    Value<String?>? mood,
    Value<String?>? socialContext,
    Value<String?>? bankTransactionId,
    Value<bool>? isTransfer,
    Value<bool>? isReconciled,
    Value<bool>? isRefund,
    Value<int>? rowid,
  }) {
    return ExpensesCompanion(
      id: id ?? this.id,
      budgetId: budgetId ?? this.budgetId,
      categoryId: categoryId ?? this.categoryId,
      subCategoryId: subCategoryId ?? this.subCategoryId,
      semiBudgetId: semiBudgetId ?? this.semiBudgetId,
      enteredBy: enteredBy ?? this.enteredBy,
      title: title ?? this.title,
      amount: amount ?? this.amount,
      currency: currency ?? this.currency,
      date: date ?? this.date,
      accountId: accountId ?? this.accountId,
      merchantName: merchantName ?? this.merchantName,
      paymentMethod: paymentMethod ?? this.paymentMethod,
      receiptUrl: receiptUrl ?? this.receiptUrl,
      barcodeValue: barcodeValue ?? this.barcodeValue,
      ocrText: ocrText ?? this.ocrText,
      attachments: attachments ?? this.attachments,
      notes: notes ?? this.notes,
      locationName: locationName ?? this.locationName,
      tags: tags ?? this.tags,
      isRecurring: isRecurring ?? this.isRecurring,
      recurringId: recurringId ?? this.recurringId,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      baseRevision: baseRevision ?? this.baseRevision,
      operationId: operationId ?? this.operationId,
      lastModifiedByDeviceId:
          lastModifiedByDeviceId ?? this.lastModifiedByDeviceId,
      isDeleted: isDeleted ?? this.isDeleted,
      globalSeq: globalSeq ?? this.globalSeq,
      syncState: syncState ?? this.syncState,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      subCategoryRaw: subCategoryRaw ?? this.subCategoryRaw,
      semanticTokens: semanticTokens ?? this.semanticTokens,
      confidence: confidence ?? this.confidence,
      source: source ?? this.source,
      isAiAssigned: isAiAssigned ?? this.isAiAssigned,
      isVerified: isVerified ?? this.isVerified,
      mood: mood ?? this.mood,
      socialContext: socialContext ?? this.socialContext,
      bankTransactionId: bankTransactionId ?? this.bankTransactionId,
      isTransfer: isTransfer ?? this.isTransfer,
      isReconciled: isReconciled ?? this.isReconciled,
      isRefund: isRefund ?? this.isRefund,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (budgetId.present) {
      map['budget_id'] = Variable<String>(budgetId.value);
    }
    if (categoryId.present) {
      map['category_id'] = Variable<String>(categoryId.value);
    }
    if (subCategoryId.present) {
      map['sub_category_id'] = Variable<String>(subCategoryId.value);
    }
    if (semiBudgetId.present) {
      map['semi_budget_id'] = Variable<String>(semiBudgetId.value);
    }
    if (enteredBy.present) {
      map['entered_by'] = Variable<String>(enteredBy.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (amount.present) {
      map['amount'] = Variable<int>(amount.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (accountId.present) {
      map['account_id'] = Variable<String>(accountId.value);
    }
    if (merchantName.present) {
      map['merchant_name'] = Variable<String>(merchantName.value);
    }
    if (paymentMethod.present) {
      map['payment_method'] = Variable<String>(paymentMethod.value);
    }
    if (receiptUrl.present) {
      map['receipt_url'] = Variable<String>(receiptUrl.value);
    }
    if (barcodeValue.present) {
      map['barcode_value'] = Variable<String>(barcodeValue.value);
    }
    if (ocrText.present) {
      map['ocr_text'] = Variable<String>(ocrText.value);
    }
    if (attachments.present) {
      map['attachments'] = Variable<String>(attachments.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (locationName.present) {
      map['location_name'] = Variable<String>(locationName.value);
    }
    if (tags.present) {
      map['tags'] = Variable<String>(tags.value);
    }
    if (isRecurring.present) {
      map['is_recurring'] = Variable<bool>(isRecurring.value);
    }
    if (recurringId.present) {
      map['recurring_id'] = Variable<String>(recurringId.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $ExpensesTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (baseRevision.present) {
      map['base_revision'] = Variable<int>(baseRevision.value);
    }
    if (operationId.present) {
      map['operation_id'] = Variable<String>(operationId.value);
    }
    if (lastModifiedByDeviceId.present) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId.value,
      );
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (globalSeq.present) {
      map['global_seq'] = Variable<int>(globalSeq.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (subCategoryRaw.present) {
      map['sub_category_raw'] = Variable<String>(subCategoryRaw.value);
    }
    if (semanticTokens.present) {
      map['semantic_tokens'] = Variable<String>(semanticTokens.value);
    }
    if (confidence.present) {
      map['confidence'] = Variable<double>(confidence.value);
    }
    if (source.present) {
      map['source'] = Variable<String>(source.value);
    }
    if (isAiAssigned.present) {
      map['is_ai_assigned'] = Variable<bool>(isAiAssigned.value);
    }
    if (isVerified.present) {
      map['is_verified'] = Variable<bool>(isVerified.value);
    }
    if (mood.present) {
      map['mood'] = Variable<String>(mood.value);
    }
    if (socialContext.present) {
      map['social_context'] = Variable<String>(socialContext.value);
    }
    if (bankTransactionId.present) {
      map['bank_transaction_id'] = Variable<String>(bankTransactionId.value);
    }
    if (isTransfer.present) {
      map['is_transfer'] = Variable<bool>(isTransfer.value);
    }
    if (isReconciled.present) {
      map['is_reconciled'] = Variable<bool>(isReconciled.value);
    }
    if (isRefund.present) {
      map['is_refund'] = Variable<bool>(isRefund.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ExpensesCompanion(')
          ..write('id: $id, ')
          ..write('budgetId: $budgetId, ')
          ..write('categoryId: $categoryId, ')
          ..write('subCategoryId: $subCategoryId, ')
          ..write('semiBudgetId: $semiBudgetId, ')
          ..write('enteredBy: $enteredBy, ')
          ..write('title: $title, ')
          ..write('amount: $amount, ')
          ..write('currency: $currency, ')
          ..write('date: $date, ')
          ..write('accountId: $accountId, ')
          ..write('merchantName: $merchantName, ')
          ..write('paymentMethod: $paymentMethod, ')
          ..write('receiptUrl: $receiptUrl, ')
          ..write('barcodeValue: $barcodeValue, ')
          ..write('ocrText: $ocrText, ')
          ..write('attachments: $attachments, ')
          ..write('notes: $notes, ')
          ..write('locationName: $locationName, ')
          ..write('tags: $tags, ')
          ..write('isRecurring: $isRecurring, ')
          ..write('recurringId: $recurringId, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('globalSeq: $globalSeq, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('subCategoryRaw: $subCategoryRaw, ')
          ..write('semanticTokens: $semanticTokens, ')
          ..write('confidence: $confidence, ')
          ..write('source: $source, ')
          ..write('isAiAssigned: $isAiAssigned, ')
          ..write('isVerified: $isVerified, ')
          ..write('mood: $mood, ')
          ..write('socialContext: $socialContext, ')
          ..write('bankTransactionId: $bankTransactionId, ')
          ..write('isTransfer: $isTransfer, ')
          ..write('isReconciled: $isReconciled, ')
          ..write('isRefund: $isRefund, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BudgetMembersTable extends BudgetMembers
    with TableInfo<$BudgetMembersTable, BudgetMember> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BudgetMembersTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _budgetIdMeta = const VerificationMeta(
    'budgetId',
  );
  @override
  late final GeneratedColumn<String> budgetId = GeneratedColumn<String>(
    'budget_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES budgets (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _memberEmailMeta = const VerificationMeta(
    'memberEmail',
  );
  @override
  late final GeneratedColumn<String> memberEmail = GeneratedColumn<String>(
    'member_email',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _memberNameMeta = const VerificationMeta(
    'memberName',
  );
  @override
  late final GeneratedColumn<String> memberName = GeneratedColumn<String>(
    'member_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _roleMeta = const VerificationMeta('role');
  @override
  late final GeneratedColumn<String> role = GeneratedColumn<String>(
    'role',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('pending'),
  );
  static const VerificationMeta _invitedByMeta = const VerificationMeta(
    'invitedBy',
  );
  @override
  late final GeneratedColumn<String> invitedBy = GeneratedColumn<String>(
    'invited_by',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata =
      GeneratedColumn<String>(
        'metadata',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Map<String, dynamic>?>(
        $BudgetMembersTable.$convertermetadatan,
      );
  static const VerificationMeta _invitedAtMeta = const VerificationMeta(
    'invitedAt',
  );
  @override
  late final GeneratedColumn<DateTime> invitedAt = GeneratedColumn<DateTime>(
    'invited_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _acceptedAtMeta = const VerificationMeta(
    'acceptedAt',
  );
  @override
  late final GeneratedColumn<DateTime> acceptedAt = GeneratedColumn<DateTime>(
    'accepted_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _lastModifiedByDeviceIdMeta =
      const VerificationMeta('lastModifiedByDeviceId');
  @override
  late final GeneratedColumn<String> lastModifiedByDeviceId =
      GeneratedColumn<String>(
        'last_modified_by_device_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _spendingLimitMeta = const VerificationMeta(
    'spendingLimit',
  );
  @override
  late final GeneratedColumn<int> spendingLimit = GeneratedColumn<int>(
    'spending_limit',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    budgetId,
    userId,
    memberEmail,
    memberName,
    role,
    status,
    invitedBy,
    metadata,
    invitedAt,
    acceptedAt,
    createdAt,
    updatedAt,
    isDeleted,
    lastModifiedByDeviceId,
    revision,
    syncState,
    lamportClock,
    versionVector,
    spendingLimit,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'budget_members';
  @override
  VerificationContext validateIntegrity(
    Insertable<BudgetMember> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('budget_id')) {
      context.handle(
        _budgetIdMeta,
        budgetId.isAcceptableOrUnknown(data['budget_id']!, _budgetIdMeta),
      );
    } else if (isInserting) {
      context.missing(_budgetIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    }
    if (data.containsKey('member_email')) {
      context.handle(
        _memberEmailMeta,
        memberEmail.isAcceptableOrUnknown(
          data['member_email']!,
          _memberEmailMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_memberEmailMeta);
    }
    if (data.containsKey('member_name')) {
      context.handle(
        _memberNameMeta,
        memberName.isAcceptableOrUnknown(data['member_name']!, _memberNameMeta),
      );
    }
    if (data.containsKey('role')) {
      context.handle(
        _roleMeta,
        role.isAcceptableOrUnknown(data['role']!, _roleMeta),
      );
    } else if (isInserting) {
      context.missing(_roleMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('invited_by')) {
      context.handle(
        _invitedByMeta,
        invitedBy.isAcceptableOrUnknown(data['invited_by']!, _invitedByMeta),
      );
    }
    if (data.containsKey('invited_at')) {
      context.handle(
        _invitedAtMeta,
        invitedAt.isAcceptableOrUnknown(data['invited_at']!, _invitedAtMeta),
      );
    }
    if (data.containsKey('accepted_at')) {
      context.handle(
        _acceptedAtMeta,
        acceptedAt.isAcceptableOrUnknown(data['accepted_at']!, _acceptedAtMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('last_modified_by_device_id')) {
      context.handle(
        _lastModifiedByDeviceIdMeta,
        lastModifiedByDeviceId.isAcceptableOrUnknown(
          data['last_modified_by_device_id']!,
          _lastModifiedByDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    if (data.containsKey('spending_limit')) {
      context.handle(
        _spendingLimitMeta,
        spendingLimit.isAcceptableOrUnknown(
          data['spending_limit']!,
          _spendingLimitMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BudgetMember map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BudgetMember(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      budgetId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}budget_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      ),
      memberEmail: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}member_email'],
      )!,
      memberName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}member_name'],
      ),
      role: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}role'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      invitedBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}invited_by'],
      ),
      metadata: $BudgetMembersTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      invitedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}invited_at'],
      )!,
      acceptedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}accepted_at'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      lastModifiedByDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_modified_by_device_id'],
      ),
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
      spendingLimit: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}spending_limit'],
      ),
    );
  }

  @override
  $BudgetMembersTable createAlias(String alias) {
    return $BudgetMembersTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class BudgetMember extends DataClass implements Insertable<BudgetMember> {
  final String id;
  final String budgetId;
  final String? userId;
  final String memberEmail;
  final String? memberName;
  final String role;
  final String status;
  final String? invitedBy;
  final Map<String, dynamic>? metadata;
  final DateTime invitedAt;
  final DateTime? acceptedAt;
  final DateTime createdAt;
  final DateTime updatedAt;
  final bool isDeleted;
  final String? lastModifiedByDeviceId;
  final int revision;
  final String syncState;
  final int lamportClock;
  final String? versionVector;
  final int? spendingLimit;
  const BudgetMember({
    required this.id,
    required this.budgetId,
    this.userId,
    required this.memberEmail,
    this.memberName,
    required this.role,
    required this.status,
    this.invitedBy,
    this.metadata,
    required this.invitedAt,
    this.acceptedAt,
    required this.createdAt,
    required this.updatedAt,
    required this.isDeleted,
    this.lastModifiedByDeviceId,
    required this.revision,
    required this.syncState,
    required this.lamportClock,
    this.versionVector,
    this.spendingLimit,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['budget_id'] = Variable<String>(budgetId);
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<String>(userId);
    }
    map['member_email'] = Variable<String>(memberEmail);
    if (!nullToAbsent || memberName != null) {
      map['member_name'] = Variable<String>(memberName);
    }
    map['role'] = Variable<String>(role);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || invitedBy != null) {
      map['invited_by'] = Variable<String>(invitedBy);
    }
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $BudgetMembersTable.$convertermetadatan.toSql(metadata),
      );
    }
    map['invited_at'] = Variable<DateTime>(invitedAt);
    if (!nullToAbsent || acceptedAt != null) {
      map['accepted_at'] = Variable<DateTime>(acceptedAt);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['is_deleted'] = Variable<bool>(isDeleted);
    if (!nullToAbsent || lastModifiedByDeviceId != null) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId,
      );
    }
    map['revision'] = Variable<int>(revision);
    map['sync_state'] = Variable<String>(syncState);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    if (!nullToAbsent || spendingLimit != null) {
      map['spending_limit'] = Variable<int>(spendingLimit);
    }
    return map;
  }

  BudgetMembersCompanion toCompanion(bool nullToAbsent) {
    return BudgetMembersCompanion(
      id: Value(id),
      budgetId: Value(budgetId),
      userId: userId == null && nullToAbsent
          ? const Value.absent()
          : Value(userId),
      memberEmail: Value(memberEmail),
      memberName: memberName == null && nullToAbsent
          ? const Value.absent()
          : Value(memberName),
      role: Value(role),
      status: Value(status),
      invitedBy: invitedBy == null && nullToAbsent
          ? const Value.absent()
          : Value(invitedBy),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      invitedAt: Value(invitedAt),
      acceptedAt: acceptedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(acceptedAt),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      isDeleted: Value(isDeleted),
      lastModifiedByDeviceId: lastModifiedByDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedByDeviceId),
      revision: Value(revision),
      syncState: Value(syncState),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
      spendingLimit: spendingLimit == null && nullToAbsent
          ? const Value.absent()
          : Value(spendingLimit),
    );
  }

  factory BudgetMember.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BudgetMember(
      id: serializer.fromJson<String>(json['id']),
      budgetId: serializer.fromJson<String>(json['budgetId']),
      userId: serializer.fromJson<String?>(json['userId']),
      memberEmail: serializer.fromJson<String>(json['memberEmail']),
      memberName: serializer.fromJson<String?>(json['memberName']),
      role: serializer.fromJson<String>(json['role']),
      status: serializer.fromJson<String>(json['status']),
      invitedBy: serializer.fromJson<String?>(json['invitedBy']),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      invitedAt: serializer.fromJson<DateTime>(json['invitedAt']),
      acceptedAt: serializer.fromJson<DateTime?>(json['acceptedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      lastModifiedByDeviceId: serializer.fromJson<String?>(
        json['lastModifiedByDeviceId'],
      ),
      revision: serializer.fromJson<int>(json['revision']),
      syncState: serializer.fromJson<String>(json['syncState']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
      spendingLimit: serializer.fromJson<int?>(json['spendingLimit']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'budgetId': serializer.toJson<String>(budgetId),
      'userId': serializer.toJson<String?>(userId),
      'memberEmail': serializer.toJson<String>(memberEmail),
      'memberName': serializer.toJson<String?>(memberName),
      'role': serializer.toJson<String>(role),
      'status': serializer.toJson<String>(status),
      'invitedBy': serializer.toJson<String?>(invitedBy),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'invitedAt': serializer.toJson<DateTime>(invitedAt),
      'acceptedAt': serializer.toJson<DateTime?>(acceptedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'lastModifiedByDeviceId': serializer.toJson<String?>(
        lastModifiedByDeviceId,
      ),
      'revision': serializer.toJson<int>(revision),
      'syncState': serializer.toJson<String>(syncState),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
      'spendingLimit': serializer.toJson<int?>(spendingLimit),
    };
  }

  BudgetMember copyWith({
    String? id,
    String? budgetId,
    Value<String?> userId = const Value.absent(),
    String? memberEmail,
    Value<String?> memberName = const Value.absent(),
    String? role,
    String? status,
    Value<String?> invitedBy = const Value.absent(),
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    DateTime? invitedAt,
    Value<DateTime?> acceptedAt = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    bool? isDeleted,
    Value<String?> lastModifiedByDeviceId = const Value.absent(),
    int? revision,
    String? syncState,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
    Value<int?> spendingLimit = const Value.absent(),
  }) => BudgetMember(
    id: id ?? this.id,
    budgetId: budgetId ?? this.budgetId,
    userId: userId.present ? userId.value : this.userId,
    memberEmail: memberEmail ?? this.memberEmail,
    memberName: memberName.present ? memberName.value : this.memberName,
    role: role ?? this.role,
    status: status ?? this.status,
    invitedBy: invitedBy.present ? invitedBy.value : this.invitedBy,
    metadata: metadata.present ? metadata.value : this.metadata,
    invitedAt: invitedAt ?? this.invitedAt,
    acceptedAt: acceptedAt.present ? acceptedAt.value : this.acceptedAt,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    isDeleted: isDeleted ?? this.isDeleted,
    lastModifiedByDeviceId: lastModifiedByDeviceId.present
        ? lastModifiedByDeviceId.value
        : this.lastModifiedByDeviceId,
    revision: revision ?? this.revision,
    syncState: syncState ?? this.syncState,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
    spendingLimit: spendingLimit.present
        ? spendingLimit.value
        : this.spendingLimit,
  );
  BudgetMember copyWithCompanion(BudgetMembersCompanion data) {
    return BudgetMember(
      id: data.id.present ? data.id.value : this.id,
      budgetId: data.budgetId.present ? data.budgetId.value : this.budgetId,
      userId: data.userId.present ? data.userId.value : this.userId,
      memberEmail: data.memberEmail.present
          ? data.memberEmail.value
          : this.memberEmail,
      memberName: data.memberName.present
          ? data.memberName.value
          : this.memberName,
      role: data.role.present ? data.role.value : this.role,
      status: data.status.present ? data.status.value : this.status,
      invitedBy: data.invitedBy.present ? data.invitedBy.value : this.invitedBy,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      invitedAt: data.invitedAt.present ? data.invitedAt.value : this.invitedAt,
      acceptedAt: data.acceptedAt.present
          ? data.acceptedAt.value
          : this.acceptedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      lastModifiedByDeviceId: data.lastModifiedByDeviceId.present
          ? data.lastModifiedByDeviceId.value
          : this.lastModifiedByDeviceId,
      revision: data.revision.present ? data.revision.value : this.revision,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
      spendingLimit: data.spendingLimit.present
          ? data.spendingLimit.value
          : this.spendingLimit,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BudgetMember(')
          ..write('id: $id, ')
          ..write('budgetId: $budgetId, ')
          ..write('userId: $userId, ')
          ..write('memberEmail: $memberEmail, ')
          ..write('memberName: $memberName, ')
          ..write('role: $role, ')
          ..write('status: $status, ')
          ..write('invitedBy: $invitedBy, ')
          ..write('metadata: $metadata, ')
          ..write('invitedAt: $invitedAt, ')
          ..write('acceptedAt: $acceptedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('spendingLimit: $spendingLimit')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    budgetId,
    userId,
    memberEmail,
    memberName,
    role,
    status,
    invitedBy,
    metadata,
    invitedAt,
    acceptedAt,
    createdAt,
    updatedAt,
    isDeleted,
    lastModifiedByDeviceId,
    revision,
    syncState,
    lamportClock,
    versionVector,
    spendingLimit,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BudgetMember &&
          other.id == this.id &&
          other.budgetId == this.budgetId &&
          other.userId == this.userId &&
          other.memberEmail == this.memberEmail &&
          other.memberName == this.memberName &&
          other.role == this.role &&
          other.status == this.status &&
          other.invitedBy == this.invitedBy &&
          other.metadata == this.metadata &&
          other.invitedAt == this.invitedAt &&
          other.acceptedAt == this.acceptedAt &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.isDeleted == this.isDeleted &&
          other.lastModifiedByDeviceId == this.lastModifiedByDeviceId &&
          other.revision == this.revision &&
          other.syncState == this.syncState &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector &&
          other.spendingLimit == this.spendingLimit);
}

class BudgetMembersCompanion extends UpdateCompanion<BudgetMember> {
  final Value<String> id;
  final Value<String> budgetId;
  final Value<String?> userId;
  final Value<String> memberEmail;
  final Value<String?> memberName;
  final Value<String> role;
  final Value<String> status;
  final Value<String?> invitedBy;
  final Value<Map<String, dynamic>?> metadata;
  final Value<DateTime> invitedAt;
  final Value<DateTime?> acceptedAt;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<bool> isDeleted;
  final Value<String?> lastModifiedByDeviceId;
  final Value<int> revision;
  final Value<String> syncState;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int?> spendingLimit;
  final Value<int> rowid;
  const BudgetMembersCompanion({
    this.id = const Value.absent(),
    this.budgetId = const Value.absent(),
    this.userId = const Value.absent(),
    this.memberEmail = const Value.absent(),
    this.memberName = const Value.absent(),
    this.role = const Value.absent(),
    this.status = const Value.absent(),
    this.invitedBy = const Value.absent(),
    this.metadata = const Value.absent(),
    this.invitedAt = const Value.absent(),
    this.acceptedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.spendingLimit = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BudgetMembersCompanion.insert({
    required String id,
    required String budgetId,
    this.userId = const Value.absent(),
    required String memberEmail,
    this.memberName = const Value.absent(),
    required String role,
    this.status = const Value.absent(),
    this.invitedBy = const Value.absent(),
    this.metadata = const Value.absent(),
    this.invitedAt = const Value.absent(),
    this.acceptedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.spendingLimit = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       budgetId = Value(budgetId),
       memberEmail = Value(memberEmail),
       role = Value(role);
  static Insertable<BudgetMember> custom({
    Expression<String>? id,
    Expression<String>? budgetId,
    Expression<String>? userId,
    Expression<String>? memberEmail,
    Expression<String>? memberName,
    Expression<String>? role,
    Expression<String>? status,
    Expression<String>? invitedBy,
    Expression<String>? metadata,
    Expression<DateTime>? invitedAt,
    Expression<DateTime>? acceptedAt,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<bool>? isDeleted,
    Expression<String>? lastModifiedByDeviceId,
    Expression<int>? revision,
    Expression<String>? syncState,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? spendingLimit,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (budgetId != null) 'budget_id': budgetId,
      if (userId != null) 'user_id': userId,
      if (memberEmail != null) 'member_email': memberEmail,
      if (memberName != null) 'member_name': memberName,
      if (role != null) 'role': role,
      if (status != null) 'status': status,
      if (invitedBy != null) 'invited_by': invitedBy,
      if (metadata != null) 'metadata': metadata,
      if (invitedAt != null) 'invited_at': invitedAt,
      if (acceptedAt != null) 'accepted_at': acceptedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (lastModifiedByDeviceId != null)
        'last_modified_by_device_id': lastModifiedByDeviceId,
      if (revision != null) 'revision': revision,
      if (syncState != null) 'sync_state': syncState,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (spendingLimit != null) 'spending_limit': spendingLimit,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BudgetMembersCompanion copyWith({
    Value<String>? id,
    Value<String>? budgetId,
    Value<String?>? userId,
    Value<String>? memberEmail,
    Value<String?>? memberName,
    Value<String>? role,
    Value<String>? status,
    Value<String?>? invitedBy,
    Value<Map<String, dynamic>?>? metadata,
    Value<DateTime>? invitedAt,
    Value<DateTime?>? acceptedAt,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<bool>? isDeleted,
    Value<String?>? lastModifiedByDeviceId,
    Value<int>? revision,
    Value<String>? syncState,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int?>? spendingLimit,
    Value<int>? rowid,
  }) {
    return BudgetMembersCompanion(
      id: id ?? this.id,
      budgetId: budgetId ?? this.budgetId,
      userId: userId ?? this.userId,
      memberEmail: memberEmail ?? this.memberEmail,
      memberName: memberName ?? this.memberName,
      role: role ?? this.role,
      status: status ?? this.status,
      invitedBy: invitedBy ?? this.invitedBy,
      metadata: metadata ?? this.metadata,
      invitedAt: invitedAt ?? this.invitedAt,
      acceptedAt: acceptedAt ?? this.acceptedAt,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      isDeleted: isDeleted ?? this.isDeleted,
      lastModifiedByDeviceId:
          lastModifiedByDeviceId ?? this.lastModifiedByDeviceId,
      revision: revision ?? this.revision,
      syncState: syncState ?? this.syncState,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      spendingLimit: spendingLimit ?? this.spendingLimit,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (budgetId.present) {
      map['budget_id'] = Variable<String>(budgetId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (memberEmail.present) {
      map['member_email'] = Variable<String>(memberEmail.value);
    }
    if (memberName.present) {
      map['member_name'] = Variable<String>(memberName.value);
    }
    if (role.present) {
      map['role'] = Variable<String>(role.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (invitedBy.present) {
      map['invited_by'] = Variable<String>(invitedBy.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $BudgetMembersTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (invitedAt.present) {
      map['invited_at'] = Variable<DateTime>(invitedAt.value);
    }
    if (acceptedAt.present) {
      map['accepted_at'] = Variable<DateTime>(acceptedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (lastModifiedByDeviceId.present) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId.value,
      );
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (spendingLimit.present) {
      map['spending_limit'] = Variable<int>(spendingLimit.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BudgetMembersCompanion(')
          ..write('id: $id, ')
          ..write('budgetId: $budgetId, ')
          ..write('userId: $userId, ')
          ..write('memberEmail: $memberEmail, ')
          ..write('memberName: $memberName, ')
          ..write('role: $role, ')
          ..write('status: $status, ')
          ..write('invitedBy: $invitedBy, ')
          ..write('metadata: $metadata, ')
          ..write('invitedAt: $invitedAt, ')
          ..write('acceptedAt: $acceptedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('spendingLimit: $spendingLimit, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ActivityLogsTable extends ActivityLogs
    with TableInfo<$ActivityLogsTable, ActivityLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ActivityLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _budgetIdMeta = const VerificationMeta(
    'budgetId',
  );
  @override
  late final GeneratedColumn<String> budgetId = GeneratedColumn<String>(
    'budget_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES budgets (id)',
    ),
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
    'action',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityIdMeta = const VerificationMeta(
    'entityId',
  );
  @override
  late final GeneratedColumn<String> entityId = GeneratedColumn<String>(
    'entity_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  details = GeneratedColumn<String>(
    'details',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Map<String, dynamic>?>($ActivityLogsTable.$converterdetailsn);
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    budgetId,
    userId,
    action,
    entityType,
    entityId,
    details,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'activity_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<ActivityLog> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('budget_id')) {
      context.handle(
        _budgetIdMeta,
        budgetId.isAcceptableOrUnknown(data['budget_id']!, _budgetIdMeta),
      );
    } else if (isInserting) {
      context.missing(_budgetIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('action')) {
      context.handle(
        _actionMeta,
        action.isAcceptableOrUnknown(data['action']!, _actionMeta),
      );
    } else if (isInserting) {
      context.missing(_actionMeta);
    }
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('entity_id')) {
      context.handle(
        _entityIdMeta,
        entityId.isAcceptableOrUnknown(data['entity_id']!, _entityIdMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ActivityLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ActivityLog(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      budgetId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}budget_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      action: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}action'],
      )!,
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      entityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_id'],
      ),
      details: $ActivityLogsTable.$converterdetailsn.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}details'],
        ),
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $ActivityLogsTable createAlias(String alias) {
    return $ActivityLogsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $converterdetails =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $converterdetailsn =
      NullAwareTypeConverter.wrap($converterdetails);
}

class ActivityLog extends DataClass implements Insertable<ActivityLog> {
  final String id;
  final String budgetId;
  final String userId;
  final String action;
  final String entityType;
  final String? entityId;
  final Map<String, dynamic>? details;
  final DateTime createdAt;
  const ActivityLog({
    required this.id,
    required this.budgetId,
    required this.userId,
    required this.action,
    required this.entityType,
    this.entityId,
    this.details,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['budget_id'] = Variable<String>(budgetId);
    map['user_id'] = Variable<String>(userId);
    map['action'] = Variable<String>(action);
    map['entity_type'] = Variable<String>(entityType);
    if (!nullToAbsent || entityId != null) {
      map['entity_id'] = Variable<String>(entityId);
    }
    if (!nullToAbsent || details != null) {
      map['details'] = Variable<String>(
        $ActivityLogsTable.$converterdetailsn.toSql(details),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ActivityLogsCompanion toCompanion(bool nullToAbsent) {
    return ActivityLogsCompanion(
      id: Value(id),
      budgetId: Value(budgetId),
      userId: Value(userId),
      action: Value(action),
      entityType: Value(entityType),
      entityId: entityId == null && nullToAbsent
          ? const Value.absent()
          : Value(entityId),
      details: details == null && nullToAbsent
          ? const Value.absent()
          : Value(details),
      createdAt: Value(createdAt),
    );
  }

  factory ActivityLog.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ActivityLog(
      id: serializer.fromJson<String>(json['id']),
      budgetId: serializer.fromJson<String>(json['budgetId']),
      userId: serializer.fromJson<String>(json['userId']),
      action: serializer.fromJson<String>(json['action']),
      entityType: serializer.fromJson<String>(json['entityType']),
      entityId: serializer.fromJson<String?>(json['entityId']),
      details: serializer.fromJson<Map<String, dynamic>?>(json['details']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'budgetId': serializer.toJson<String>(budgetId),
      'userId': serializer.toJson<String>(userId),
      'action': serializer.toJson<String>(action),
      'entityType': serializer.toJson<String>(entityType),
      'entityId': serializer.toJson<String?>(entityId),
      'details': serializer.toJson<Map<String, dynamic>?>(details),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  ActivityLog copyWith({
    String? id,
    String? budgetId,
    String? userId,
    String? action,
    String? entityType,
    Value<String?> entityId = const Value.absent(),
    Value<Map<String, dynamic>?> details = const Value.absent(),
    DateTime? createdAt,
  }) => ActivityLog(
    id: id ?? this.id,
    budgetId: budgetId ?? this.budgetId,
    userId: userId ?? this.userId,
    action: action ?? this.action,
    entityType: entityType ?? this.entityType,
    entityId: entityId.present ? entityId.value : this.entityId,
    details: details.present ? details.value : this.details,
    createdAt: createdAt ?? this.createdAt,
  );
  ActivityLog copyWithCompanion(ActivityLogsCompanion data) {
    return ActivityLog(
      id: data.id.present ? data.id.value : this.id,
      budgetId: data.budgetId.present ? data.budgetId.value : this.budgetId,
      userId: data.userId.present ? data.userId.value : this.userId,
      action: data.action.present ? data.action.value : this.action,
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      entityId: data.entityId.present ? data.entityId.value : this.entityId,
      details: data.details.present ? data.details.value : this.details,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ActivityLog(')
          ..write('id: $id, ')
          ..write('budgetId: $budgetId, ')
          ..write('userId: $userId, ')
          ..write('action: $action, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('details: $details, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    budgetId,
    userId,
    action,
    entityType,
    entityId,
    details,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ActivityLog &&
          other.id == this.id &&
          other.budgetId == this.budgetId &&
          other.userId == this.userId &&
          other.action == this.action &&
          other.entityType == this.entityType &&
          other.entityId == this.entityId &&
          other.details == this.details &&
          other.createdAt == this.createdAt);
}

class ActivityLogsCompanion extends UpdateCompanion<ActivityLog> {
  final Value<String> id;
  final Value<String> budgetId;
  final Value<String> userId;
  final Value<String> action;
  final Value<String> entityType;
  final Value<String?> entityId;
  final Value<Map<String, dynamic>?> details;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const ActivityLogsCompanion({
    this.id = const Value.absent(),
    this.budgetId = const Value.absent(),
    this.userId = const Value.absent(),
    this.action = const Value.absent(),
    this.entityType = const Value.absent(),
    this.entityId = const Value.absent(),
    this.details = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ActivityLogsCompanion.insert({
    required String id,
    required String budgetId,
    required String userId,
    required String action,
    required String entityType,
    this.entityId = const Value.absent(),
    this.details = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       budgetId = Value(budgetId),
       userId = Value(userId),
       action = Value(action),
       entityType = Value(entityType);
  static Insertable<ActivityLog> custom({
    Expression<String>? id,
    Expression<String>? budgetId,
    Expression<String>? userId,
    Expression<String>? action,
    Expression<String>? entityType,
    Expression<String>? entityId,
    Expression<String>? details,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (budgetId != null) 'budget_id': budgetId,
      if (userId != null) 'user_id': userId,
      if (action != null) 'action': action,
      if (entityType != null) 'entity_type': entityType,
      if (entityId != null) 'entity_id': entityId,
      if (details != null) 'details': details,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ActivityLogsCompanion copyWith({
    Value<String>? id,
    Value<String>? budgetId,
    Value<String>? userId,
    Value<String>? action,
    Value<String>? entityType,
    Value<String?>? entityId,
    Value<Map<String, dynamic>?>? details,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return ActivityLogsCompanion(
      id: id ?? this.id,
      budgetId: budgetId ?? this.budgetId,
      userId: userId ?? this.userId,
      action: action ?? this.action,
      entityType: entityType ?? this.entityType,
      entityId: entityId ?? this.entityId,
      details: details ?? this.details,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (budgetId.present) {
      map['budget_id'] = Variable<String>(budgetId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (entityId.present) {
      map['entity_id'] = Variable<String>(entityId.value);
    }
    if (details.present) {
      map['details'] = Variable<String>(
        $ActivityLogsTable.$converterdetailsn.toSql(details.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ActivityLogsCompanion(')
          ..write('id: $id, ')
          ..write('budgetId: $budgetId, ')
          ..write('userId: $userId, ')
          ..write('action: $action, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('details: $details, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AuditLogsTable extends AuditLogs
    with TableInfo<$AuditLogsTable, AuditLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AuditLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityIdMeta = const VerificationMeta(
    'entityId',
  );
  @override
  late final GeneratedColumn<String> entityId = GeneratedColumn<String>(
    'entity_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
    'action',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _oldValueMeta = const VerificationMeta(
    'oldValue',
  );
  @override
  late final GeneratedColumn<String> oldValue = GeneratedColumn<String>(
    'old_value',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _newValueMeta = const VerificationMeta(
    'newValue',
  );
  @override
  late final GeneratedColumn<String> newValue = GeneratedColumn<String>(
    'new_value',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _correlationIdMeta = const VerificationMeta(
    'correlationId',
  );
  @override
  late final GeneratedColumn<String> correlationId = GeneratedColumn<String>(
    'correlation_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _deviceIdMeta = const VerificationMeta(
    'deviceId',
  );
  @override
  late final GeneratedColumn<String> deviceId = GeneratedColumn<String>(
    'device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata = GeneratedColumn<String>(
    'metadata',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Map<String, dynamic>?>($AuditLogsTable.$convertermetadatan);
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    entityType,
    entityId,
    action,
    userId,
    oldValue,
    newValue,
    correlationId,
    deviceId,
    metadata,
    createdAt,
    syncState,
    revision,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'audit_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<AuditLog> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('entity_id')) {
      context.handle(
        _entityIdMeta,
        entityId.isAcceptableOrUnknown(data['entity_id']!, _entityIdMeta),
      );
    } else if (isInserting) {
      context.missing(_entityIdMeta);
    }
    if (data.containsKey('action')) {
      context.handle(
        _actionMeta,
        action.isAcceptableOrUnknown(data['action']!, _actionMeta),
      );
    } else if (isInserting) {
      context.missing(_actionMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('old_value')) {
      context.handle(
        _oldValueMeta,
        oldValue.isAcceptableOrUnknown(data['old_value']!, _oldValueMeta),
      );
    }
    if (data.containsKey('new_value')) {
      context.handle(
        _newValueMeta,
        newValue.isAcceptableOrUnknown(data['new_value']!, _newValueMeta),
      );
    }
    if (data.containsKey('correlation_id')) {
      context.handle(
        _correlationIdMeta,
        correlationId.isAcceptableOrUnknown(
          data['correlation_id']!,
          _correlationIdMeta,
        ),
      );
    }
    if (data.containsKey('device_id')) {
      context.handle(
        _deviceIdMeta,
        deviceId.isAcceptableOrUnknown(data['device_id']!, _deviceIdMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AuditLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AuditLog(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      entityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_id'],
      )!,
      action: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}action'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      oldValue: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}old_value'],
      ),
      newValue: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}new_value'],
      ),
      correlationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}correlation_id'],
      ),
      deviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}device_id'],
      ),
      metadata: $AuditLogsTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $AuditLogsTable createAlias(String alias) {
    return $AuditLogsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class AuditLog extends DataClass implements Insertable<AuditLog> {
  final String id;
  final String entityType;
  final String entityId;
  final String action;
  final String userId;
  final String? oldValue;
  final String? newValue;

  /// Correlation ID (UUID) linked to a specific UI operation or Sync session
  final String? correlationId;
  final String? deviceId;
  final Map<String, dynamic>? metadata;
  final DateTime createdAt;
  final String syncState;
  final int revision;
  final int lamportClock;
  final String? versionVector;
  const AuditLog({
    required this.id,
    required this.entityType,
    required this.entityId,
    required this.action,
    required this.userId,
    this.oldValue,
    this.newValue,
    this.correlationId,
    this.deviceId,
    this.metadata,
    required this.createdAt,
    required this.syncState,
    required this.revision,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['entity_type'] = Variable<String>(entityType);
    map['entity_id'] = Variable<String>(entityId);
    map['action'] = Variable<String>(action);
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || oldValue != null) {
      map['old_value'] = Variable<String>(oldValue);
    }
    if (!nullToAbsent || newValue != null) {
      map['new_value'] = Variable<String>(newValue);
    }
    if (!nullToAbsent || correlationId != null) {
      map['correlation_id'] = Variable<String>(correlationId);
    }
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $AuditLogsTable.$convertermetadatan.toSql(metadata),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['sync_state'] = Variable<String>(syncState);
    map['revision'] = Variable<int>(revision);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  AuditLogsCompanion toCompanion(bool nullToAbsent) {
    return AuditLogsCompanion(
      id: Value(id),
      entityType: Value(entityType),
      entityId: Value(entityId),
      action: Value(action),
      userId: Value(userId),
      oldValue: oldValue == null && nullToAbsent
          ? const Value.absent()
          : Value(oldValue),
      newValue: newValue == null && nullToAbsent
          ? const Value.absent()
          : Value(newValue),
      correlationId: correlationId == null && nullToAbsent
          ? const Value.absent()
          : Value(correlationId),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      createdAt: Value(createdAt),
      syncState: Value(syncState),
      revision: Value(revision),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory AuditLog.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AuditLog(
      id: serializer.fromJson<String>(json['id']),
      entityType: serializer.fromJson<String>(json['entityType']),
      entityId: serializer.fromJson<String>(json['entityId']),
      action: serializer.fromJson<String>(json['action']),
      userId: serializer.fromJson<String>(json['userId']),
      oldValue: serializer.fromJson<String?>(json['oldValue']),
      newValue: serializer.fromJson<String?>(json['newValue']),
      correlationId: serializer.fromJson<String?>(json['correlationId']),
      deviceId: serializer.fromJson<String?>(json['deviceId']),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      syncState: serializer.fromJson<String>(json['syncState']),
      revision: serializer.fromJson<int>(json['revision']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'entityType': serializer.toJson<String>(entityType),
      'entityId': serializer.toJson<String>(entityId),
      'action': serializer.toJson<String>(action),
      'userId': serializer.toJson<String>(userId),
      'oldValue': serializer.toJson<String?>(oldValue),
      'newValue': serializer.toJson<String?>(newValue),
      'correlationId': serializer.toJson<String?>(correlationId),
      'deviceId': serializer.toJson<String?>(deviceId),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'syncState': serializer.toJson<String>(syncState),
      'revision': serializer.toJson<int>(revision),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  AuditLog copyWith({
    String? id,
    String? entityType,
    String? entityId,
    String? action,
    String? userId,
    Value<String?> oldValue = const Value.absent(),
    Value<String?> newValue = const Value.absent(),
    Value<String?> correlationId = const Value.absent(),
    Value<String?> deviceId = const Value.absent(),
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    DateTime? createdAt,
    String? syncState,
    int? revision,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => AuditLog(
    id: id ?? this.id,
    entityType: entityType ?? this.entityType,
    entityId: entityId ?? this.entityId,
    action: action ?? this.action,
    userId: userId ?? this.userId,
    oldValue: oldValue.present ? oldValue.value : this.oldValue,
    newValue: newValue.present ? newValue.value : this.newValue,
    correlationId: correlationId.present
        ? correlationId.value
        : this.correlationId,
    deviceId: deviceId.present ? deviceId.value : this.deviceId,
    metadata: metadata.present ? metadata.value : this.metadata,
    createdAt: createdAt ?? this.createdAt,
    syncState: syncState ?? this.syncState,
    revision: revision ?? this.revision,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  AuditLog copyWithCompanion(AuditLogsCompanion data) {
    return AuditLog(
      id: data.id.present ? data.id.value : this.id,
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      entityId: data.entityId.present ? data.entityId.value : this.entityId,
      action: data.action.present ? data.action.value : this.action,
      userId: data.userId.present ? data.userId.value : this.userId,
      oldValue: data.oldValue.present ? data.oldValue.value : this.oldValue,
      newValue: data.newValue.present ? data.newValue.value : this.newValue,
      correlationId: data.correlationId.present
          ? data.correlationId.value
          : this.correlationId,
      deviceId: data.deviceId.present ? data.deviceId.value : this.deviceId,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      revision: data.revision.present ? data.revision.value : this.revision,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AuditLog(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('action: $action, ')
          ..write('userId: $userId, ')
          ..write('oldValue: $oldValue, ')
          ..write('newValue: $newValue, ')
          ..write('correlationId: $correlationId, ')
          ..write('deviceId: $deviceId, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('syncState: $syncState, ')
          ..write('revision: $revision, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    entityType,
    entityId,
    action,
    userId,
    oldValue,
    newValue,
    correlationId,
    deviceId,
    metadata,
    createdAt,
    syncState,
    revision,
    lamportClock,
    versionVector,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AuditLog &&
          other.id == this.id &&
          other.entityType == this.entityType &&
          other.entityId == this.entityId &&
          other.action == this.action &&
          other.userId == this.userId &&
          other.oldValue == this.oldValue &&
          other.newValue == this.newValue &&
          other.correlationId == this.correlationId &&
          other.deviceId == this.deviceId &&
          other.metadata == this.metadata &&
          other.createdAt == this.createdAt &&
          other.syncState == this.syncState &&
          other.revision == this.revision &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class AuditLogsCompanion extends UpdateCompanion<AuditLog> {
  final Value<String> id;
  final Value<String> entityType;
  final Value<String> entityId;
  final Value<String> action;
  final Value<String> userId;
  final Value<String?> oldValue;
  final Value<String?> newValue;
  final Value<String?> correlationId;
  final Value<String?> deviceId;
  final Value<Map<String, dynamic>?> metadata;
  final Value<DateTime> createdAt;
  final Value<String> syncState;
  final Value<int> revision;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const AuditLogsCompanion({
    this.id = const Value.absent(),
    this.entityType = const Value.absent(),
    this.entityId = const Value.absent(),
    this.action = const Value.absent(),
    this.userId = const Value.absent(),
    this.oldValue = const Value.absent(),
    this.newValue = const Value.absent(),
    this.correlationId = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.syncState = const Value.absent(),
    this.revision = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AuditLogsCompanion.insert({
    required String id,
    required String entityType,
    required String entityId,
    required String action,
    required String userId,
    this.oldValue = const Value.absent(),
    this.newValue = const Value.absent(),
    this.correlationId = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.syncState = const Value.absent(),
    this.revision = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       entityType = Value(entityType),
       entityId = Value(entityId),
       action = Value(action),
       userId = Value(userId);
  static Insertable<AuditLog> custom({
    Expression<String>? id,
    Expression<String>? entityType,
    Expression<String>? entityId,
    Expression<String>? action,
    Expression<String>? userId,
    Expression<String>? oldValue,
    Expression<String>? newValue,
    Expression<String>? correlationId,
    Expression<String>? deviceId,
    Expression<String>? metadata,
    Expression<DateTime>? createdAt,
    Expression<String>? syncState,
    Expression<int>? revision,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (entityType != null) 'entity_type': entityType,
      if (entityId != null) 'entity_id': entityId,
      if (action != null) 'action': action,
      if (userId != null) 'user_id': userId,
      if (oldValue != null) 'old_value': oldValue,
      if (newValue != null) 'new_value': newValue,
      if (correlationId != null) 'correlation_id': correlationId,
      if (deviceId != null) 'device_id': deviceId,
      if (metadata != null) 'metadata': metadata,
      if (createdAt != null) 'created_at': createdAt,
      if (syncState != null) 'sync_state': syncState,
      if (revision != null) 'revision': revision,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AuditLogsCompanion copyWith({
    Value<String>? id,
    Value<String>? entityType,
    Value<String>? entityId,
    Value<String>? action,
    Value<String>? userId,
    Value<String?>? oldValue,
    Value<String?>? newValue,
    Value<String?>? correlationId,
    Value<String?>? deviceId,
    Value<Map<String, dynamic>?>? metadata,
    Value<DateTime>? createdAt,
    Value<String>? syncState,
    Value<int>? revision,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return AuditLogsCompanion(
      id: id ?? this.id,
      entityType: entityType ?? this.entityType,
      entityId: entityId ?? this.entityId,
      action: action ?? this.action,
      userId: userId ?? this.userId,
      oldValue: oldValue ?? this.oldValue,
      newValue: newValue ?? this.newValue,
      correlationId: correlationId ?? this.correlationId,
      deviceId: deviceId ?? this.deviceId,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      syncState: syncState ?? this.syncState,
      revision: revision ?? this.revision,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (entityId.present) {
      map['entity_id'] = Variable<String>(entityId.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (oldValue.present) {
      map['old_value'] = Variable<String>(oldValue.value);
    }
    if (newValue.present) {
      map['new_value'] = Variable<String>(newValue.value);
    }
    if (correlationId.present) {
      map['correlation_id'] = Variable<String>(correlationId.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $AuditLogsTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AuditLogsCompanion(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('action: $action, ')
          ..write('userId: $userId, ')
          ..write('oldValue: $oldValue, ')
          ..write('newValue: $newValue, ')
          ..write('correlationId: $correlationId, ')
          ..write('deviceId: $deviceId, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('syncState: $syncState, ')
          ..write('revision: $revision, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SyncQueueTable extends SyncQueue
    with TableInfo<$SyncQueueTable, SyncQueueData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncQueueTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _syncTableNameMeta = const VerificationMeta(
    'syncTableName',
  );
  @override
  late final GeneratedColumn<String> syncTableName = GeneratedColumn<String>(
    'sync_table_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _recordIdMeta = const VerificationMeta(
    'recordId',
  );
  @override
  late final GeneratedColumn<String> recordId = GeneratedColumn<String>(
    'record_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _operationMeta = const VerificationMeta(
    'operation',
  );
  @override
  late final GeneratedColumn<String> operation = GeneratedColumn<String>(
    'operation',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _payloadMeta = const VerificationMeta(
    'payload',
  );
  @override
  late final GeneratedColumn<String> payload = GeneratedColumn<String>(
    'payload',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _retryCountMeta = const VerificationMeta(
    'retryCount',
  );
  @override
  late final GeneratedColumn<int> retryCount = GeneratedColumn<int>(
    'retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isSyncedMeta = const VerificationMeta(
    'isSynced',
  );
  @override
  late final GeneratedColumn<bool> isSynced = GeneratedColumn<bool>(
    'is_synced',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_synced" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    syncTableName,
    recordId,
    operation,
    payload,
    timestamp,
    retryCount,
    isSynced,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sync_queue';
  @override
  VerificationContext validateIntegrity(
    Insertable<SyncQueueData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('sync_table_name')) {
      context.handle(
        _syncTableNameMeta,
        syncTableName.isAcceptableOrUnknown(
          data['sync_table_name']!,
          _syncTableNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_syncTableNameMeta);
    }
    if (data.containsKey('record_id')) {
      context.handle(
        _recordIdMeta,
        recordId.isAcceptableOrUnknown(data['record_id']!, _recordIdMeta),
      );
    } else if (isInserting) {
      context.missing(_recordIdMeta);
    }
    if (data.containsKey('operation')) {
      context.handle(
        _operationMeta,
        operation.isAcceptableOrUnknown(data['operation']!, _operationMeta),
      );
    } else if (isInserting) {
      context.missing(_operationMeta);
    }
    if (data.containsKey('payload')) {
      context.handle(
        _payloadMeta,
        payload.isAcceptableOrUnknown(data['payload']!, _payloadMeta),
      );
    } else if (isInserting) {
      context.missing(_payloadMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    }
    if (data.containsKey('retry_count')) {
      context.handle(
        _retryCountMeta,
        retryCount.isAcceptableOrUnknown(data['retry_count']!, _retryCountMeta),
      );
    }
    if (data.containsKey('is_synced')) {
      context.handle(
        _isSyncedMeta,
        isSynced.isAcceptableOrUnknown(data['is_synced']!, _isSyncedMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SyncQueueData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SyncQueueData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      syncTableName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_table_name'],
      )!,
      recordId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}record_id'],
      )!,
      operation: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation'],
      )!,
      payload: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payload'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
      retryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}retry_count'],
      )!,
      isSynced: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_synced'],
      )!,
    );
  }

  @override
  $SyncQueueTable createAlias(String alias) {
    return $SyncQueueTable(attachedDatabase, alias);
  }
}

class SyncQueueData extends DataClass implements Insertable<SyncQueueData> {
  final int id;
  final String syncTableName;
  final String recordId;
  final String operation;
  final String payload;
  final DateTime timestamp;
  final int retryCount;
  final bool isSynced;
  const SyncQueueData({
    required this.id,
    required this.syncTableName,
    required this.recordId,
    required this.operation,
    required this.payload,
    required this.timestamp,
    required this.retryCount,
    required this.isSynced,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['sync_table_name'] = Variable<String>(syncTableName);
    map['record_id'] = Variable<String>(recordId);
    map['operation'] = Variable<String>(operation);
    map['payload'] = Variable<String>(payload);
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['retry_count'] = Variable<int>(retryCount);
    map['is_synced'] = Variable<bool>(isSynced);
    return map;
  }

  SyncQueueCompanion toCompanion(bool nullToAbsent) {
    return SyncQueueCompanion(
      id: Value(id),
      syncTableName: Value(syncTableName),
      recordId: Value(recordId),
      operation: Value(operation),
      payload: Value(payload),
      timestamp: Value(timestamp),
      retryCount: Value(retryCount),
      isSynced: Value(isSynced),
    );
  }

  factory SyncQueueData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SyncQueueData(
      id: serializer.fromJson<int>(json['id']),
      syncTableName: serializer.fromJson<String>(json['syncTableName']),
      recordId: serializer.fromJson<String>(json['recordId']),
      operation: serializer.fromJson<String>(json['operation']),
      payload: serializer.fromJson<String>(json['payload']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      retryCount: serializer.fromJson<int>(json['retryCount']),
      isSynced: serializer.fromJson<bool>(json['isSynced']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'syncTableName': serializer.toJson<String>(syncTableName),
      'recordId': serializer.toJson<String>(recordId),
      'operation': serializer.toJson<String>(operation),
      'payload': serializer.toJson<String>(payload),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'retryCount': serializer.toJson<int>(retryCount),
      'isSynced': serializer.toJson<bool>(isSynced),
    };
  }

  SyncQueueData copyWith({
    int? id,
    String? syncTableName,
    String? recordId,
    String? operation,
    String? payload,
    DateTime? timestamp,
    int? retryCount,
    bool? isSynced,
  }) => SyncQueueData(
    id: id ?? this.id,
    syncTableName: syncTableName ?? this.syncTableName,
    recordId: recordId ?? this.recordId,
    operation: operation ?? this.operation,
    payload: payload ?? this.payload,
    timestamp: timestamp ?? this.timestamp,
    retryCount: retryCount ?? this.retryCount,
    isSynced: isSynced ?? this.isSynced,
  );
  SyncQueueData copyWithCompanion(SyncQueueCompanion data) {
    return SyncQueueData(
      id: data.id.present ? data.id.value : this.id,
      syncTableName: data.syncTableName.present
          ? data.syncTableName.value
          : this.syncTableName,
      recordId: data.recordId.present ? data.recordId.value : this.recordId,
      operation: data.operation.present ? data.operation.value : this.operation,
      payload: data.payload.present ? data.payload.value : this.payload,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      retryCount: data.retryCount.present
          ? data.retryCount.value
          : this.retryCount,
      isSynced: data.isSynced.present ? data.isSynced.value : this.isSynced,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SyncQueueData(')
          ..write('id: $id, ')
          ..write('syncTableName: $syncTableName, ')
          ..write('recordId: $recordId, ')
          ..write('operation: $operation, ')
          ..write('payload: $payload, ')
          ..write('timestamp: $timestamp, ')
          ..write('retryCount: $retryCount, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    syncTableName,
    recordId,
    operation,
    payload,
    timestamp,
    retryCount,
    isSynced,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SyncQueueData &&
          other.id == this.id &&
          other.syncTableName == this.syncTableName &&
          other.recordId == this.recordId &&
          other.operation == this.operation &&
          other.payload == this.payload &&
          other.timestamp == this.timestamp &&
          other.retryCount == this.retryCount &&
          other.isSynced == this.isSynced);
}

class SyncQueueCompanion extends UpdateCompanion<SyncQueueData> {
  final Value<int> id;
  final Value<String> syncTableName;
  final Value<String> recordId;
  final Value<String> operation;
  final Value<String> payload;
  final Value<DateTime> timestamp;
  final Value<int> retryCount;
  final Value<bool> isSynced;
  const SyncQueueCompanion({
    this.id = const Value.absent(),
    this.syncTableName = const Value.absent(),
    this.recordId = const Value.absent(),
    this.operation = const Value.absent(),
    this.payload = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.retryCount = const Value.absent(),
    this.isSynced = const Value.absent(),
  });
  SyncQueueCompanion.insert({
    this.id = const Value.absent(),
    required String syncTableName,
    required String recordId,
    required String operation,
    required String payload,
    this.timestamp = const Value.absent(),
    this.retryCount = const Value.absent(),
    this.isSynced = const Value.absent(),
  }) : syncTableName = Value(syncTableName),
       recordId = Value(recordId),
       operation = Value(operation),
       payload = Value(payload);
  static Insertable<SyncQueueData> custom({
    Expression<int>? id,
    Expression<String>? syncTableName,
    Expression<String>? recordId,
    Expression<String>? operation,
    Expression<String>? payload,
    Expression<DateTime>? timestamp,
    Expression<int>? retryCount,
    Expression<bool>? isSynced,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (syncTableName != null) 'sync_table_name': syncTableName,
      if (recordId != null) 'record_id': recordId,
      if (operation != null) 'operation': operation,
      if (payload != null) 'payload': payload,
      if (timestamp != null) 'timestamp': timestamp,
      if (retryCount != null) 'retry_count': retryCount,
      if (isSynced != null) 'is_synced': isSynced,
    });
  }

  SyncQueueCompanion copyWith({
    Value<int>? id,
    Value<String>? syncTableName,
    Value<String>? recordId,
    Value<String>? operation,
    Value<String>? payload,
    Value<DateTime>? timestamp,
    Value<int>? retryCount,
    Value<bool>? isSynced,
  }) {
    return SyncQueueCompanion(
      id: id ?? this.id,
      syncTableName: syncTableName ?? this.syncTableName,
      recordId: recordId ?? this.recordId,
      operation: operation ?? this.operation,
      payload: payload ?? this.payload,
      timestamp: timestamp ?? this.timestamp,
      retryCount: retryCount ?? this.retryCount,
      isSynced: isSynced ?? this.isSynced,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (syncTableName.present) {
      map['sync_table_name'] = Variable<String>(syncTableName.value);
    }
    if (recordId.present) {
      map['record_id'] = Variable<String>(recordId.value);
    }
    if (operation.present) {
      map['operation'] = Variable<String>(operation.value);
    }
    if (payload.present) {
      map['payload'] = Variable<String>(payload.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (retryCount.present) {
      map['retry_count'] = Variable<int>(retryCount.value);
    }
    if (isSynced.present) {
      map['is_synced'] = Variable<bool>(isSynced.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncQueueCompanion(')
          ..write('id: $id, ')
          ..write('syncTableName: $syncTableName, ')
          ..write('recordId: $recordId, ')
          ..write('operation: $operation, ')
          ..write('payload: $payload, ')
          ..write('timestamp: $timestamp, ')
          ..write('retryCount: $retryCount, ')
          ..write('isSynced: $isSynced')
          ..write(')'))
        .toString();
  }
}

class $RecurringExpensesTable extends RecurringExpenses
    with TableInfo<$RecurringExpensesTable, RecurringExpense> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RecurringExpensesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<int> amount = GeneratedColumn<int>(
    'amount',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _frequencyMeta = const VerificationMeta(
    'frequency',
  );
  @override
  late final GeneratedColumn<String> frequency = GeneratedColumn<String>(
    'frequency',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dayOfMonthMeta = const VerificationMeta(
    'dayOfMonth',
  );
  @override
  late final GeneratedColumn<int> dayOfMonth = GeneratedColumn<int>(
    'day_of_month',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _dayOfWeekMeta = const VerificationMeta(
    'dayOfWeek',
  );
  @override
  late final GeneratedColumn<int> dayOfWeek = GeneratedColumn<int>(
    'day_of_week',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _categoryMeta = const VerificationMeta(
    'category',
  );
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
    'category',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _paymentMethodMeta = const VerificationMeta(
    'paymentMethod',
  );
  @override
  late final GeneratedColumn<String> paymentMethod = GeneratedColumn<String>(
    'payment_method',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('card'),
  );
  static const VerificationMeta _nextDueDateMeta = const VerificationMeta(
    'nextDueDate',
  );
  @override
  late final GeneratedColumn<DateTime> nextDueDate = GeneratedColumn<DateTime>(
    'next_due_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata =
      GeneratedColumn<String>(
        'metadata',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Map<String, dynamic>?>(
        $RecurringExpensesTable.$convertermetadatan,
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _baseRevisionMeta = const VerificationMeta(
    'baseRevision',
  );
  @override
  late final GeneratedColumn<int> baseRevision = GeneratedColumn<int>(
    'base_revision',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _operationIdMeta = const VerificationMeta(
    'operationId',
  );
  @override
  late final GeneratedColumn<String> operationId = GeneratedColumn<String>(
    'operation_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastModifiedByDeviceIdMeta =
      const VerificationMeta('lastModifiedByDeviceId');
  @override
  late final GeneratedColumn<String> lastModifiedByDeviceId =
      GeneratedColumn<String>(
        'last_modified_by_device_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    title,
    amount,
    frequency,
    dayOfMonth,
    dayOfWeek,
    category,
    paymentMethod,
    nextDueDate,
    isActive,
    metadata,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    syncState,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'recurring_expenses';
  @override
  VerificationContext validateIntegrity(
    Insertable<RecurringExpense> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(
        _amountMeta,
        amount.isAcceptableOrUnknown(data['amount']!, _amountMeta),
      );
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('frequency')) {
      context.handle(
        _frequencyMeta,
        frequency.isAcceptableOrUnknown(data['frequency']!, _frequencyMeta),
      );
    } else if (isInserting) {
      context.missing(_frequencyMeta);
    }
    if (data.containsKey('day_of_month')) {
      context.handle(
        _dayOfMonthMeta,
        dayOfMonth.isAcceptableOrUnknown(
          data['day_of_month']!,
          _dayOfMonthMeta,
        ),
      );
    }
    if (data.containsKey('day_of_week')) {
      context.handle(
        _dayOfWeekMeta,
        dayOfWeek.isAcceptableOrUnknown(data['day_of_week']!, _dayOfWeekMeta),
      );
    }
    if (data.containsKey('category')) {
      context.handle(
        _categoryMeta,
        category.isAcceptableOrUnknown(data['category']!, _categoryMeta),
      );
    }
    if (data.containsKey('payment_method')) {
      context.handle(
        _paymentMethodMeta,
        paymentMethod.isAcceptableOrUnknown(
          data['payment_method']!,
          _paymentMethodMeta,
        ),
      );
    }
    if (data.containsKey('next_due_date')) {
      context.handle(
        _nextDueDateMeta,
        nextDueDate.isAcceptableOrUnknown(
          data['next_due_date']!,
          _nextDueDateMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_nextDueDateMeta);
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('base_revision')) {
      context.handle(
        _baseRevisionMeta,
        baseRevision.isAcceptableOrUnknown(
          data['base_revision']!,
          _baseRevisionMeta,
        ),
      );
    }
    if (data.containsKey('operation_id')) {
      context.handle(
        _operationIdMeta,
        operationId.isAcceptableOrUnknown(
          data['operation_id']!,
          _operationIdMeta,
        ),
      );
    }
    if (data.containsKey('last_modified_by_device_id')) {
      context.handle(
        _lastModifiedByDeviceIdMeta,
        lastModifiedByDeviceId.isAcceptableOrUnknown(
          data['last_modified_by_device_id']!,
          _lastModifiedByDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  RecurringExpense map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RecurringExpense(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      amount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}amount'],
      )!,
      frequency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}frequency'],
      )!,
      dayOfMonth: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}day_of_month'],
      ),
      dayOfWeek: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}day_of_week'],
      ),
      category: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category'],
      ),
      paymentMethod: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payment_method'],
      )!,
      nextDueDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}next_due_date'],
      )!,
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      metadata: $RecurringExpensesTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      baseRevision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}base_revision'],
      ),
      operationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation_id'],
      ),
      lastModifiedByDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_modified_by_device_id'],
      ),
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $RecurringExpensesTable createAlias(String alias) {
    return $RecurringExpensesTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class RecurringExpense extends DataClass
    implements Insertable<RecurringExpense> {
  final String id;
  final String userId;
  final String title;
  final int amount;
  final String frequency;
  final int? dayOfMonth;
  final int? dayOfWeek;
  final String? category;
  final String paymentMethod;
  final DateTime nextDueDate;
  final bool isActive;
  final Map<String, dynamic>? metadata;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final int? baseRevision;
  final String? operationId;
  final String? lastModifiedByDeviceId;
  final String syncState;
  final int lamportClock;
  final String? versionVector;
  const RecurringExpense({
    required this.id,
    required this.userId,
    required this.title,
    required this.amount,
    required this.frequency,
    this.dayOfMonth,
    this.dayOfWeek,
    this.category,
    required this.paymentMethod,
    required this.nextDueDate,
    required this.isActive,
    this.metadata,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    this.baseRevision,
    this.operationId,
    this.lastModifiedByDeviceId,
    required this.syncState,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['title'] = Variable<String>(title);
    map['amount'] = Variable<int>(amount);
    map['frequency'] = Variable<String>(frequency);
    if (!nullToAbsent || dayOfMonth != null) {
      map['day_of_month'] = Variable<int>(dayOfMonth);
    }
    if (!nullToAbsent || dayOfWeek != null) {
      map['day_of_week'] = Variable<int>(dayOfWeek);
    }
    if (!nullToAbsent || category != null) {
      map['category'] = Variable<String>(category);
    }
    map['payment_method'] = Variable<String>(paymentMethod);
    map['next_due_date'] = Variable<DateTime>(nextDueDate);
    map['is_active'] = Variable<bool>(isActive);
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $RecurringExpensesTable.$convertermetadatan.toSql(metadata),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    if (!nullToAbsent || baseRevision != null) {
      map['base_revision'] = Variable<int>(baseRevision);
    }
    if (!nullToAbsent || operationId != null) {
      map['operation_id'] = Variable<String>(operationId);
    }
    if (!nullToAbsent || lastModifiedByDeviceId != null) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId,
      );
    }
    map['sync_state'] = Variable<String>(syncState);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  RecurringExpensesCompanion toCompanion(bool nullToAbsent) {
    return RecurringExpensesCompanion(
      id: Value(id),
      userId: Value(userId),
      title: Value(title),
      amount: Value(amount),
      frequency: Value(frequency),
      dayOfMonth: dayOfMonth == null && nullToAbsent
          ? const Value.absent()
          : Value(dayOfMonth),
      dayOfWeek: dayOfWeek == null && nullToAbsent
          ? const Value.absent()
          : Value(dayOfWeek),
      category: category == null && nullToAbsent
          ? const Value.absent()
          : Value(category),
      paymentMethod: Value(paymentMethod),
      nextDueDate: Value(nextDueDate),
      isActive: Value(isActive),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      baseRevision: baseRevision == null && nullToAbsent
          ? const Value.absent()
          : Value(baseRevision),
      operationId: operationId == null && nullToAbsent
          ? const Value.absent()
          : Value(operationId),
      lastModifiedByDeviceId: lastModifiedByDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedByDeviceId),
      syncState: Value(syncState),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory RecurringExpense.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RecurringExpense(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      title: serializer.fromJson<String>(json['title']),
      amount: serializer.fromJson<int>(json['amount']),
      frequency: serializer.fromJson<String>(json['frequency']),
      dayOfMonth: serializer.fromJson<int?>(json['dayOfMonth']),
      dayOfWeek: serializer.fromJson<int?>(json['dayOfWeek']),
      category: serializer.fromJson<String?>(json['category']),
      paymentMethod: serializer.fromJson<String>(json['paymentMethod']),
      nextDueDate: serializer.fromJson<DateTime>(json['nextDueDate']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      baseRevision: serializer.fromJson<int?>(json['baseRevision']),
      operationId: serializer.fromJson<String?>(json['operationId']),
      lastModifiedByDeviceId: serializer.fromJson<String?>(
        json['lastModifiedByDeviceId'],
      ),
      syncState: serializer.fromJson<String>(json['syncState']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'title': serializer.toJson<String>(title),
      'amount': serializer.toJson<int>(amount),
      'frequency': serializer.toJson<String>(frequency),
      'dayOfMonth': serializer.toJson<int?>(dayOfMonth),
      'dayOfWeek': serializer.toJson<int?>(dayOfWeek),
      'category': serializer.toJson<String?>(category),
      'paymentMethod': serializer.toJson<String>(paymentMethod),
      'nextDueDate': serializer.toJson<DateTime>(nextDueDate),
      'isActive': serializer.toJson<bool>(isActive),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'baseRevision': serializer.toJson<int?>(baseRevision),
      'operationId': serializer.toJson<String?>(operationId),
      'lastModifiedByDeviceId': serializer.toJson<String?>(
        lastModifiedByDeviceId,
      ),
      'syncState': serializer.toJson<String>(syncState),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  RecurringExpense copyWith({
    String? id,
    String? userId,
    String? title,
    int? amount,
    String? frequency,
    Value<int?> dayOfMonth = const Value.absent(),
    Value<int?> dayOfWeek = const Value.absent(),
    Value<String?> category = const Value.absent(),
    String? paymentMethod,
    DateTime? nextDueDate,
    bool? isActive,
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    Value<int?> baseRevision = const Value.absent(),
    Value<String?> operationId = const Value.absent(),
    Value<String?> lastModifiedByDeviceId = const Value.absent(),
    String? syncState,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => RecurringExpense(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    title: title ?? this.title,
    amount: amount ?? this.amount,
    frequency: frequency ?? this.frequency,
    dayOfMonth: dayOfMonth.present ? dayOfMonth.value : this.dayOfMonth,
    dayOfWeek: dayOfWeek.present ? dayOfWeek.value : this.dayOfWeek,
    category: category.present ? category.value : this.category,
    paymentMethod: paymentMethod ?? this.paymentMethod,
    nextDueDate: nextDueDate ?? this.nextDueDate,
    isActive: isActive ?? this.isActive,
    metadata: metadata.present ? metadata.value : this.metadata,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    baseRevision: baseRevision.present ? baseRevision.value : this.baseRevision,
    operationId: operationId.present ? operationId.value : this.operationId,
    lastModifiedByDeviceId: lastModifiedByDeviceId.present
        ? lastModifiedByDeviceId.value
        : this.lastModifiedByDeviceId,
    syncState: syncState ?? this.syncState,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  RecurringExpense copyWithCompanion(RecurringExpensesCompanion data) {
    return RecurringExpense(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      title: data.title.present ? data.title.value : this.title,
      amount: data.amount.present ? data.amount.value : this.amount,
      frequency: data.frequency.present ? data.frequency.value : this.frequency,
      dayOfMonth: data.dayOfMonth.present
          ? data.dayOfMonth.value
          : this.dayOfMonth,
      dayOfWeek: data.dayOfWeek.present ? data.dayOfWeek.value : this.dayOfWeek,
      category: data.category.present ? data.category.value : this.category,
      paymentMethod: data.paymentMethod.present
          ? data.paymentMethod.value
          : this.paymentMethod,
      nextDueDate: data.nextDueDate.present
          ? data.nextDueDate.value
          : this.nextDueDate,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      baseRevision: data.baseRevision.present
          ? data.baseRevision.value
          : this.baseRevision,
      operationId: data.operationId.present
          ? data.operationId.value
          : this.operationId,
      lastModifiedByDeviceId: data.lastModifiedByDeviceId.present
          ? data.lastModifiedByDeviceId.value
          : this.lastModifiedByDeviceId,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RecurringExpense(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('title: $title, ')
          ..write('amount: $amount, ')
          ..write('frequency: $frequency, ')
          ..write('dayOfMonth: $dayOfMonth, ')
          ..write('dayOfWeek: $dayOfWeek, ')
          ..write('category: $category, ')
          ..write('paymentMethod: $paymentMethod, ')
          ..write('nextDueDate: $nextDueDate, ')
          ..write('isActive: $isActive, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    userId,
    title,
    amount,
    frequency,
    dayOfMonth,
    dayOfWeek,
    category,
    paymentMethod,
    nextDueDate,
    isActive,
    metadata,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    syncState,
    lamportClock,
    versionVector,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RecurringExpense &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.title == this.title &&
          other.amount == this.amount &&
          other.frequency == this.frequency &&
          other.dayOfMonth == this.dayOfMonth &&
          other.dayOfWeek == this.dayOfWeek &&
          other.category == this.category &&
          other.paymentMethod == this.paymentMethod &&
          other.nextDueDate == this.nextDueDate &&
          other.isActive == this.isActive &&
          other.metadata == this.metadata &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.baseRevision == this.baseRevision &&
          other.operationId == this.operationId &&
          other.lastModifiedByDeviceId == this.lastModifiedByDeviceId &&
          other.syncState == this.syncState &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class RecurringExpensesCompanion extends UpdateCompanion<RecurringExpense> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String> title;
  final Value<int> amount;
  final Value<String> frequency;
  final Value<int?> dayOfMonth;
  final Value<int?> dayOfWeek;
  final Value<String?> category;
  final Value<String> paymentMethod;
  final Value<DateTime> nextDueDate;
  final Value<bool> isActive;
  final Value<Map<String, dynamic>?> metadata;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<int?> baseRevision;
  final Value<String?> operationId;
  final Value<String?> lastModifiedByDeviceId;
  final Value<String> syncState;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const RecurringExpensesCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.title = const Value.absent(),
    this.amount = const Value.absent(),
    this.frequency = const Value.absent(),
    this.dayOfMonth = const Value.absent(),
    this.dayOfWeek = const Value.absent(),
    this.category = const Value.absent(),
    this.paymentMethod = const Value.absent(),
    this.nextDueDate = const Value.absent(),
    this.isActive = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  RecurringExpensesCompanion.insert({
    required String id,
    required String userId,
    required String title,
    required int amount,
    required String frequency,
    this.dayOfMonth = const Value.absent(),
    this.dayOfWeek = const Value.absent(),
    this.category = const Value.absent(),
    this.paymentMethod = const Value.absent(),
    required DateTime nextDueDate,
    this.isActive = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       title = Value(title),
       amount = Value(amount),
       frequency = Value(frequency),
       nextDueDate = Value(nextDueDate);
  static Insertable<RecurringExpense> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? title,
    Expression<int>? amount,
    Expression<String>? frequency,
    Expression<int>? dayOfMonth,
    Expression<int>? dayOfWeek,
    Expression<String>? category,
    Expression<String>? paymentMethod,
    Expression<DateTime>? nextDueDate,
    Expression<bool>? isActive,
    Expression<String>? metadata,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<int>? baseRevision,
    Expression<String>? operationId,
    Expression<String>? lastModifiedByDeviceId,
    Expression<String>? syncState,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (title != null) 'title': title,
      if (amount != null) 'amount': amount,
      if (frequency != null) 'frequency': frequency,
      if (dayOfMonth != null) 'day_of_month': dayOfMonth,
      if (dayOfWeek != null) 'day_of_week': dayOfWeek,
      if (category != null) 'category': category,
      if (paymentMethod != null) 'payment_method': paymentMethod,
      if (nextDueDate != null) 'next_due_date': nextDueDate,
      if (isActive != null) 'is_active': isActive,
      if (metadata != null) 'metadata': metadata,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (baseRevision != null) 'base_revision': baseRevision,
      if (operationId != null) 'operation_id': operationId,
      if (lastModifiedByDeviceId != null)
        'last_modified_by_device_id': lastModifiedByDeviceId,
      if (syncState != null) 'sync_state': syncState,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  RecurringExpensesCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String>? title,
    Value<int>? amount,
    Value<String>? frequency,
    Value<int?>? dayOfMonth,
    Value<int?>? dayOfWeek,
    Value<String?>? category,
    Value<String>? paymentMethod,
    Value<DateTime>? nextDueDate,
    Value<bool>? isActive,
    Value<Map<String, dynamic>?>? metadata,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<int?>? baseRevision,
    Value<String?>? operationId,
    Value<String?>? lastModifiedByDeviceId,
    Value<String>? syncState,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return RecurringExpensesCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      title: title ?? this.title,
      amount: amount ?? this.amount,
      frequency: frequency ?? this.frequency,
      dayOfMonth: dayOfMonth ?? this.dayOfMonth,
      dayOfWeek: dayOfWeek ?? this.dayOfWeek,
      category: category ?? this.category,
      paymentMethod: paymentMethod ?? this.paymentMethod,
      nextDueDate: nextDueDate ?? this.nextDueDate,
      isActive: isActive ?? this.isActive,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      baseRevision: baseRevision ?? this.baseRevision,
      operationId: operationId ?? this.operationId,
      lastModifiedByDeviceId:
          lastModifiedByDeviceId ?? this.lastModifiedByDeviceId,
      syncState: syncState ?? this.syncState,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (amount.present) {
      map['amount'] = Variable<int>(amount.value);
    }
    if (frequency.present) {
      map['frequency'] = Variable<String>(frequency.value);
    }
    if (dayOfMonth.present) {
      map['day_of_month'] = Variable<int>(dayOfMonth.value);
    }
    if (dayOfWeek.present) {
      map['day_of_week'] = Variable<int>(dayOfWeek.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (paymentMethod.present) {
      map['payment_method'] = Variable<String>(paymentMethod.value);
    }
    if (nextDueDate.present) {
      map['next_due_date'] = Variable<DateTime>(nextDueDate.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $RecurringExpensesTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (baseRevision.present) {
      map['base_revision'] = Variable<int>(baseRevision.value);
    }
    if (operationId.present) {
      map['operation_id'] = Variable<String>(operationId.value);
    }
    if (lastModifiedByDeviceId.present) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId.value,
      );
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RecurringExpensesCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('title: $title, ')
          ..write('amount: $amount, ')
          ..write('frequency: $frequency, ')
          ..write('dayOfMonth: $dayOfMonth, ')
          ..write('dayOfWeek: $dayOfWeek, ')
          ..write('category: $category, ')
          ..write('paymentMethod: $paymentMethod, ')
          ..write('nextDueDate: $nextDueDate, ')
          ..write('isActive: $isActive, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SubscriptionsTable extends Subscriptions
    with TableInfo<$SubscriptionsTable, Subscription> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SubscriptionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _stripeCustomerIdMeta = const VerificationMeta(
    'stripeCustomerId',
  );
  @override
  late final GeneratedColumn<String> stripeCustomerId = GeneratedColumn<String>(
    'stripe_customer_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _priceIdMeta = const VerificationMeta(
    'priceId',
  );
  @override
  late final GeneratedColumn<String> priceId = GeneratedColumn<String>(
    'price_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _tierMeta = const VerificationMeta('tier');
  @override
  late final GeneratedColumn<String> tier = GeneratedColumn<String>(
    'tier',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currentPeriodStartMeta =
      const VerificationMeta('currentPeriodStart');
  @override
  late final GeneratedColumn<DateTime> currentPeriodStart =
      GeneratedColumn<DateTime>(
        'current_period_start',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _currentPeriodEndMeta = const VerificationMeta(
    'currentPeriodEnd',
  );
  @override
  late final GeneratedColumn<DateTime> currentPeriodEnd =
      GeneratedColumn<DateTime>(
        'current_period_end',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata =
      GeneratedColumn<String>(
        'metadata',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Map<String, dynamic>?>(
        $SubscriptionsTable.$convertermetadatan,
      );
  static const VerificationMeta _cancelAtPeriodEndMeta = const VerificationMeta(
    'cancelAtPeriodEnd',
  );
  @override
  late final GeneratedColumn<bool> cancelAtPeriodEnd = GeneratedColumn<bool>(
    'cancel_at_period_end',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("cancel_at_period_end" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _lastModifiedByDeviceIdMeta =
      const VerificationMeta('lastModifiedByDeviceId');
  @override
  late final GeneratedColumn<String> lastModifiedByDeviceId =
      GeneratedColumn<String>(
        'last_modified_by_device_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    stripeCustomerId,
    priceId,
    status,
    tier,
    currentPeriodStart,
    currentPeriodEnd,
    metadata,
    cancelAtPeriodEnd,
    createdAt,
    lastModifiedByDeviceId,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'subscriptions';
  @override
  VerificationContext validateIntegrity(
    Insertable<Subscription> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('stripe_customer_id')) {
      context.handle(
        _stripeCustomerIdMeta,
        stripeCustomerId.isAcceptableOrUnknown(
          data['stripe_customer_id']!,
          _stripeCustomerIdMeta,
        ),
      );
    }
    if (data.containsKey('price_id')) {
      context.handle(
        _priceIdMeta,
        priceId.isAcceptableOrUnknown(data['price_id']!, _priceIdMeta),
      );
    } else if (isInserting) {
      context.missing(_priceIdMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('tier')) {
      context.handle(
        _tierMeta,
        tier.isAcceptableOrUnknown(data['tier']!, _tierMeta),
      );
    } else if (isInserting) {
      context.missing(_tierMeta);
    }
    if (data.containsKey('current_period_start')) {
      context.handle(
        _currentPeriodStartMeta,
        currentPeriodStart.isAcceptableOrUnknown(
          data['current_period_start']!,
          _currentPeriodStartMeta,
        ),
      );
    }
    if (data.containsKey('current_period_end')) {
      context.handle(
        _currentPeriodEndMeta,
        currentPeriodEnd.isAcceptableOrUnknown(
          data['current_period_end']!,
          _currentPeriodEndMeta,
        ),
      );
    }
    if (data.containsKey('cancel_at_period_end')) {
      context.handle(
        _cancelAtPeriodEndMeta,
        cancelAtPeriodEnd.isAcceptableOrUnknown(
          data['cancel_at_period_end']!,
          _cancelAtPeriodEndMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('last_modified_by_device_id')) {
      context.handle(
        _lastModifiedByDeviceIdMeta,
        lastModifiedByDeviceId.isAcceptableOrUnknown(
          data['last_modified_by_device_id']!,
          _lastModifiedByDeviceIdMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Subscription map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Subscription(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      stripeCustomerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}stripe_customer_id'],
      ),
      priceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}price_id'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      tier: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tier'],
      )!,
      currentPeriodStart: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}current_period_start'],
      ),
      currentPeriodEnd: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}current_period_end'],
      ),
      metadata: $SubscriptionsTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      cancelAtPeriodEnd: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}cancel_at_period_end'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      lastModifiedByDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_modified_by_device_id'],
      ),
    );
  }

  @override
  $SubscriptionsTable createAlias(String alias) {
    return $SubscriptionsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class Subscription extends DataClass implements Insertable<Subscription> {
  final String id;
  final String userId;
  final String? stripeCustomerId;
  final String priceId;
  final String status;
  final String tier;
  final DateTime? currentPeriodStart;
  final DateTime? currentPeriodEnd;
  final Map<String, dynamic>? metadata;
  final bool cancelAtPeriodEnd;
  final DateTime createdAt;
  final String? lastModifiedByDeviceId;
  const Subscription({
    required this.id,
    required this.userId,
    this.stripeCustomerId,
    required this.priceId,
    required this.status,
    required this.tier,
    this.currentPeriodStart,
    this.currentPeriodEnd,
    this.metadata,
    required this.cancelAtPeriodEnd,
    required this.createdAt,
    this.lastModifiedByDeviceId,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || stripeCustomerId != null) {
      map['stripe_customer_id'] = Variable<String>(stripeCustomerId);
    }
    map['price_id'] = Variable<String>(priceId);
    map['status'] = Variable<String>(status);
    map['tier'] = Variable<String>(tier);
    if (!nullToAbsent || currentPeriodStart != null) {
      map['current_period_start'] = Variable<DateTime>(currentPeriodStart);
    }
    if (!nullToAbsent || currentPeriodEnd != null) {
      map['current_period_end'] = Variable<DateTime>(currentPeriodEnd);
    }
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $SubscriptionsTable.$convertermetadatan.toSql(metadata),
      );
    }
    map['cancel_at_period_end'] = Variable<bool>(cancelAtPeriodEnd);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || lastModifiedByDeviceId != null) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId,
      );
    }
    return map;
  }

  SubscriptionsCompanion toCompanion(bool nullToAbsent) {
    return SubscriptionsCompanion(
      id: Value(id),
      userId: Value(userId),
      stripeCustomerId: stripeCustomerId == null && nullToAbsent
          ? const Value.absent()
          : Value(stripeCustomerId),
      priceId: Value(priceId),
      status: Value(status),
      tier: Value(tier),
      currentPeriodStart: currentPeriodStart == null && nullToAbsent
          ? const Value.absent()
          : Value(currentPeriodStart),
      currentPeriodEnd: currentPeriodEnd == null && nullToAbsent
          ? const Value.absent()
          : Value(currentPeriodEnd),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      cancelAtPeriodEnd: Value(cancelAtPeriodEnd),
      createdAt: Value(createdAt),
      lastModifiedByDeviceId: lastModifiedByDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedByDeviceId),
    );
  }

  factory Subscription.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Subscription(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      stripeCustomerId: serializer.fromJson<String?>(json['stripeCustomerId']),
      priceId: serializer.fromJson<String>(json['priceId']),
      status: serializer.fromJson<String>(json['status']),
      tier: serializer.fromJson<String>(json['tier']),
      currentPeriodStart: serializer.fromJson<DateTime?>(
        json['currentPeriodStart'],
      ),
      currentPeriodEnd: serializer.fromJson<DateTime?>(
        json['currentPeriodEnd'],
      ),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      cancelAtPeriodEnd: serializer.fromJson<bool>(json['cancelAtPeriodEnd']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      lastModifiedByDeviceId: serializer.fromJson<String?>(
        json['lastModifiedByDeviceId'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'stripeCustomerId': serializer.toJson<String?>(stripeCustomerId),
      'priceId': serializer.toJson<String>(priceId),
      'status': serializer.toJson<String>(status),
      'tier': serializer.toJson<String>(tier),
      'currentPeriodStart': serializer.toJson<DateTime?>(currentPeriodStart),
      'currentPeriodEnd': serializer.toJson<DateTime?>(currentPeriodEnd),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'cancelAtPeriodEnd': serializer.toJson<bool>(cancelAtPeriodEnd),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'lastModifiedByDeviceId': serializer.toJson<String?>(
        lastModifiedByDeviceId,
      ),
    };
  }

  Subscription copyWith({
    String? id,
    String? userId,
    Value<String?> stripeCustomerId = const Value.absent(),
    String? priceId,
    String? status,
    String? tier,
    Value<DateTime?> currentPeriodStart = const Value.absent(),
    Value<DateTime?> currentPeriodEnd = const Value.absent(),
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    bool? cancelAtPeriodEnd,
    DateTime? createdAt,
    Value<String?> lastModifiedByDeviceId = const Value.absent(),
  }) => Subscription(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    stripeCustomerId: stripeCustomerId.present
        ? stripeCustomerId.value
        : this.stripeCustomerId,
    priceId: priceId ?? this.priceId,
    status: status ?? this.status,
    tier: tier ?? this.tier,
    currentPeriodStart: currentPeriodStart.present
        ? currentPeriodStart.value
        : this.currentPeriodStart,
    currentPeriodEnd: currentPeriodEnd.present
        ? currentPeriodEnd.value
        : this.currentPeriodEnd,
    metadata: metadata.present ? metadata.value : this.metadata,
    cancelAtPeriodEnd: cancelAtPeriodEnd ?? this.cancelAtPeriodEnd,
    createdAt: createdAt ?? this.createdAt,
    lastModifiedByDeviceId: lastModifiedByDeviceId.present
        ? lastModifiedByDeviceId.value
        : this.lastModifiedByDeviceId,
  );
  Subscription copyWithCompanion(SubscriptionsCompanion data) {
    return Subscription(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      stripeCustomerId: data.stripeCustomerId.present
          ? data.stripeCustomerId.value
          : this.stripeCustomerId,
      priceId: data.priceId.present ? data.priceId.value : this.priceId,
      status: data.status.present ? data.status.value : this.status,
      tier: data.tier.present ? data.tier.value : this.tier,
      currentPeriodStart: data.currentPeriodStart.present
          ? data.currentPeriodStart.value
          : this.currentPeriodStart,
      currentPeriodEnd: data.currentPeriodEnd.present
          ? data.currentPeriodEnd.value
          : this.currentPeriodEnd,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      cancelAtPeriodEnd: data.cancelAtPeriodEnd.present
          ? data.cancelAtPeriodEnd.value
          : this.cancelAtPeriodEnd,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      lastModifiedByDeviceId: data.lastModifiedByDeviceId.present
          ? data.lastModifiedByDeviceId.value
          : this.lastModifiedByDeviceId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Subscription(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('stripeCustomerId: $stripeCustomerId, ')
          ..write('priceId: $priceId, ')
          ..write('status: $status, ')
          ..write('tier: $tier, ')
          ..write('currentPeriodStart: $currentPeriodStart, ')
          ..write('currentPeriodEnd: $currentPeriodEnd, ')
          ..write('metadata: $metadata, ')
          ..write('cancelAtPeriodEnd: $cancelAtPeriodEnd, ')
          ..write('createdAt: $createdAt, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    stripeCustomerId,
    priceId,
    status,
    tier,
    currentPeriodStart,
    currentPeriodEnd,
    metadata,
    cancelAtPeriodEnd,
    createdAt,
    lastModifiedByDeviceId,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Subscription &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.stripeCustomerId == this.stripeCustomerId &&
          other.priceId == this.priceId &&
          other.status == this.status &&
          other.tier == this.tier &&
          other.currentPeriodStart == this.currentPeriodStart &&
          other.currentPeriodEnd == this.currentPeriodEnd &&
          other.metadata == this.metadata &&
          other.cancelAtPeriodEnd == this.cancelAtPeriodEnd &&
          other.createdAt == this.createdAt &&
          other.lastModifiedByDeviceId == this.lastModifiedByDeviceId);
}

class SubscriptionsCompanion extends UpdateCompanion<Subscription> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String?> stripeCustomerId;
  final Value<String> priceId;
  final Value<String> status;
  final Value<String> tier;
  final Value<DateTime?> currentPeriodStart;
  final Value<DateTime?> currentPeriodEnd;
  final Value<Map<String, dynamic>?> metadata;
  final Value<bool> cancelAtPeriodEnd;
  final Value<DateTime> createdAt;
  final Value<String?> lastModifiedByDeviceId;
  final Value<int> rowid;
  const SubscriptionsCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.stripeCustomerId = const Value.absent(),
    this.priceId = const Value.absent(),
    this.status = const Value.absent(),
    this.tier = const Value.absent(),
    this.currentPeriodStart = const Value.absent(),
    this.currentPeriodEnd = const Value.absent(),
    this.metadata = const Value.absent(),
    this.cancelAtPeriodEnd = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SubscriptionsCompanion.insert({
    required String id,
    required String userId,
    this.stripeCustomerId = const Value.absent(),
    required String priceId,
    required String status,
    required String tier,
    this.currentPeriodStart = const Value.absent(),
    this.currentPeriodEnd = const Value.absent(),
    this.metadata = const Value.absent(),
    this.cancelAtPeriodEnd = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       priceId = Value(priceId),
       status = Value(status),
       tier = Value(tier);
  static Insertable<Subscription> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? stripeCustomerId,
    Expression<String>? priceId,
    Expression<String>? status,
    Expression<String>? tier,
    Expression<DateTime>? currentPeriodStart,
    Expression<DateTime>? currentPeriodEnd,
    Expression<String>? metadata,
    Expression<bool>? cancelAtPeriodEnd,
    Expression<DateTime>? createdAt,
    Expression<String>? lastModifiedByDeviceId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (stripeCustomerId != null) 'stripe_customer_id': stripeCustomerId,
      if (priceId != null) 'price_id': priceId,
      if (status != null) 'status': status,
      if (tier != null) 'tier': tier,
      if (currentPeriodStart != null)
        'current_period_start': currentPeriodStart,
      if (currentPeriodEnd != null) 'current_period_end': currentPeriodEnd,
      if (metadata != null) 'metadata': metadata,
      if (cancelAtPeriodEnd != null) 'cancel_at_period_end': cancelAtPeriodEnd,
      if (createdAt != null) 'created_at': createdAt,
      if (lastModifiedByDeviceId != null)
        'last_modified_by_device_id': lastModifiedByDeviceId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SubscriptionsCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String?>? stripeCustomerId,
    Value<String>? priceId,
    Value<String>? status,
    Value<String>? tier,
    Value<DateTime?>? currentPeriodStart,
    Value<DateTime?>? currentPeriodEnd,
    Value<Map<String, dynamic>?>? metadata,
    Value<bool>? cancelAtPeriodEnd,
    Value<DateTime>? createdAt,
    Value<String?>? lastModifiedByDeviceId,
    Value<int>? rowid,
  }) {
    return SubscriptionsCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      stripeCustomerId: stripeCustomerId ?? this.stripeCustomerId,
      priceId: priceId ?? this.priceId,
      status: status ?? this.status,
      tier: tier ?? this.tier,
      currentPeriodStart: currentPeriodStart ?? this.currentPeriodStart,
      currentPeriodEnd: currentPeriodEnd ?? this.currentPeriodEnd,
      metadata: metadata ?? this.metadata,
      cancelAtPeriodEnd: cancelAtPeriodEnd ?? this.cancelAtPeriodEnd,
      createdAt: createdAt ?? this.createdAt,
      lastModifiedByDeviceId:
          lastModifiedByDeviceId ?? this.lastModifiedByDeviceId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (stripeCustomerId.present) {
      map['stripe_customer_id'] = Variable<String>(stripeCustomerId.value);
    }
    if (priceId.present) {
      map['price_id'] = Variable<String>(priceId.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (tier.present) {
      map['tier'] = Variable<String>(tier.value);
    }
    if (currentPeriodStart.present) {
      map['current_period_start'] = Variable<DateTime>(
        currentPeriodStart.value,
      );
    }
    if (currentPeriodEnd.present) {
      map['current_period_end'] = Variable<DateTime>(currentPeriodEnd.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $SubscriptionsTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (cancelAtPeriodEnd.present) {
      map['cancel_at_period_end'] = Variable<bool>(cancelAtPeriodEnd.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (lastModifiedByDeviceId.present) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId.value,
      );
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SubscriptionsCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('stripeCustomerId: $stripeCustomerId, ')
          ..write('priceId: $priceId, ')
          ..write('status: $status, ')
          ..write('tier: $tier, ')
          ..write('currentPeriodStart: $currentPeriodStart, ')
          ..write('currentPeriodEnd: $currentPeriodEnd, ')
          ..write('metadata: $metadata, ')
          ..write('cancelAtPeriodEnd: $cancelAtPeriodEnd, ')
          ..write('createdAt: $createdAt, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SavingsGoalsTable extends SavingsGoals
    with TableInfo<$SavingsGoalsTable, SavingsGoal> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SavingsGoalsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _linkedAccountIdMeta = const VerificationMeta(
    'linkedAccountId',
  );
  @override
  late final GeneratedColumn<String> linkedAccountId = GeneratedColumn<String>(
    'linked_account_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES accounts (id)',
    ),
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currentAmountMeta = const VerificationMeta(
    'currentAmount',
  );
  @override
  late final GeneratedColumn<int> currentAmount = GeneratedColumn<int>(
    'current_amount',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _targetAmountMeta = const VerificationMeta(
    'targetAmount',
  );
  @override
  late final GeneratedColumn<int> targetAmount = GeneratedColumn<int>(
    'target_amount',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currencyMeta = const VerificationMeta(
    'currency',
  );
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
    'currency',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('EUR'),
  );
  static const VerificationMeta _iconNameMeta = const VerificationMeta(
    'iconName',
  );
  @override
  late final GeneratedColumn<String> iconName = GeneratedColumn<String>(
    'icon_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _colorHexMeta = const VerificationMeta(
    'colorHex',
  );
  @override
  late final GeneratedColumn<String> colorHex = GeneratedColumn<String>(
    'color_hex',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _deadlineMeta = const VerificationMeta(
    'deadline',
  );
  @override
  late final GeneratedColumn<DateTime> deadline = GeneratedColumn<DateTime>(
    'deadline',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isArchivedMeta = const VerificationMeta(
    'isArchived',
  );
  @override
  late final GeneratedColumn<bool> isArchived = GeneratedColumn<bool>(
    'is_archived',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_archived" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata =
      GeneratedColumn<String>(
        'metadata',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Map<String, dynamic>?>(
        $SavingsGoalsTable.$convertermetadatan,
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _baseRevisionMeta = const VerificationMeta(
    'baseRevision',
  );
  @override
  late final GeneratedColumn<int> baseRevision = GeneratedColumn<int>(
    'base_revision',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _operationIdMeta = const VerificationMeta(
    'operationId',
  );
  @override
  late final GeneratedColumn<String> operationId = GeneratedColumn<String>(
    'operation_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastModifiedByDeviceIdMeta =
      const VerificationMeta('lastModifiedByDeviceId');
  @override
  late final GeneratedColumn<String> lastModifiedByDeviceId =
      GeneratedColumn<String>(
        'last_modified_by_device_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    linkedAccountId,
    title,
    currentAmount,
    targetAmount,
    currency,
    iconName,
    colorHex,
    deadline,
    isArchived,
    metadata,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    isDeleted,
    syncState,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'savings_goals';
  @override
  VerificationContext validateIntegrity(
    Insertable<SavingsGoal> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('linked_account_id')) {
      context.handle(
        _linkedAccountIdMeta,
        linkedAccountId.isAcceptableOrUnknown(
          data['linked_account_id']!,
          _linkedAccountIdMeta,
        ),
      );
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('current_amount')) {
      context.handle(
        _currentAmountMeta,
        currentAmount.isAcceptableOrUnknown(
          data['current_amount']!,
          _currentAmountMeta,
        ),
      );
    }
    if (data.containsKey('target_amount')) {
      context.handle(
        _targetAmountMeta,
        targetAmount.isAcceptableOrUnknown(
          data['target_amount']!,
          _targetAmountMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_targetAmountMeta);
    }
    if (data.containsKey('currency')) {
      context.handle(
        _currencyMeta,
        currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta),
      );
    }
    if (data.containsKey('icon_name')) {
      context.handle(
        _iconNameMeta,
        iconName.isAcceptableOrUnknown(data['icon_name']!, _iconNameMeta),
      );
    }
    if (data.containsKey('color_hex')) {
      context.handle(
        _colorHexMeta,
        colorHex.isAcceptableOrUnknown(data['color_hex']!, _colorHexMeta),
      );
    }
    if (data.containsKey('deadline')) {
      context.handle(
        _deadlineMeta,
        deadline.isAcceptableOrUnknown(data['deadline']!, _deadlineMeta),
      );
    }
    if (data.containsKey('is_archived')) {
      context.handle(
        _isArchivedMeta,
        isArchived.isAcceptableOrUnknown(data['is_archived']!, _isArchivedMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('base_revision')) {
      context.handle(
        _baseRevisionMeta,
        baseRevision.isAcceptableOrUnknown(
          data['base_revision']!,
          _baseRevisionMeta,
        ),
      );
    }
    if (data.containsKey('operation_id')) {
      context.handle(
        _operationIdMeta,
        operationId.isAcceptableOrUnknown(
          data['operation_id']!,
          _operationIdMeta,
        ),
      );
    }
    if (data.containsKey('last_modified_by_device_id')) {
      context.handle(
        _lastModifiedByDeviceIdMeta,
        lastModifiedByDeviceId.isAcceptableOrUnknown(
          data['last_modified_by_device_id']!,
          _lastModifiedByDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SavingsGoal map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SavingsGoal(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      linkedAccountId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}linked_account_id'],
      ),
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      currentAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}current_amount'],
      )!,
      targetAmount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}target_amount'],
      )!,
      currency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}currency'],
      )!,
      iconName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}icon_name'],
      ),
      colorHex: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}color_hex'],
      ),
      deadline: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}deadline'],
      ),
      isArchived: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_archived'],
      )!,
      metadata: $SavingsGoalsTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      baseRevision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}base_revision'],
      ),
      operationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation_id'],
      ),
      lastModifiedByDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_modified_by_device_id'],
      ),
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $SavingsGoalsTable createAlias(String alias) {
    return $SavingsGoalsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class SavingsGoal extends DataClass implements Insertable<SavingsGoal> {
  final String id;
  final String userId;
  final String? linkedAccountId;
  final String title;
  final int currentAmount;
  final int targetAmount;
  final String currency;
  final String? iconName;
  final String? colorHex;
  final DateTime? deadline;
  final bool isArchived;
  final Map<String, dynamic>? metadata;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final int? baseRevision;
  final String? operationId;
  final String? lastModifiedByDeviceId;
  final bool isDeleted;
  final String syncState;
  final int lamportClock;
  final String? versionVector;
  const SavingsGoal({
    required this.id,
    required this.userId,
    this.linkedAccountId,
    required this.title,
    required this.currentAmount,
    required this.targetAmount,
    required this.currency,
    this.iconName,
    this.colorHex,
    this.deadline,
    required this.isArchived,
    this.metadata,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    this.baseRevision,
    this.operationId,
    this.lastModifiedByDeviceId,
    required this.isDeleted,
    required this.syncState,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || linkedAccountId != null) {
      map['linked_account_id'] = Variable<String>(linkedAccountId);
    }
    map['title'] = Variable<String>(title);
    map['current_amount'] = Variable<int>(currentAmount);
    map['target_amount'] = Variable<int>(targetAmount);
    map['currency'] = Variable<String>(currency);
    if (!nullToAbsent || iconName != null) {
      map['icon_name'] = Variable<String>(iconName);
    }
    if (!nullToAbsent || colorHex != null) {
      map['color_hex'] = Variable<String>(colorHex);
    }
    if (!nullToAbsent || deadline != null) {
      map['deadline'] = Variable<DateTime>(deadline);
    }
    map['is_archived'] = Variable<bool>(isArchived);
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $SavingsGoalsTable.$convertermetadatan.toSql(metadata),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    if (!nullToAbsent || baseRevision != null) {
      map['base_revision'] = Variable<int>(baseRevision);
    }
    if (!nullToAbsent || operationId != null) {
      map['operation_id'] = Variable<String>(operationId);
    }
    if (!nullToAbsent || lastModifiedByDeviceId != null) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId,
      );
    }
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['sync_state'] = Variable<String>(syncState);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  SavingsGoalsCompanion toCompanion(bool nullToAbsent) {
    return SavingsGoalsCompanion(
      id: Value(id),
      userId: Value(userId),
      linkedAccountId: linkedAccountId == null && nullToAbsent
          ? const Value.absent()
          : Value(linkedAccountId),
      title: Value(title),
      currentAmount: Value(currentAmount),
      targetAmount: Value(targetAmount),
      currency: Value(currency),
      iconName: iconName == null && nullToAbsent
          ? const Value.absent()
          : Value(iconName),
      colorHex: colorHex == null && nullToAbsent
          ? const Value.absent()
          : Value(colorHex),
      deadline: deadline == null && nullToAbsent
          ? const Value.absent()
          : Value(deadline),
      isArchived: Value(isArchived),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      baseRevision: baseRevision == null && nullToAbsent
          ? const Value.absent()
          : Value(baseRevision),
      operationId: operationId == null && nullToAbsent
          ? const Value.absent()
          : Value(operationId),
      lastModifiedByDeviceId: lastModifiedByDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedByDeviceId),
      isDeleted: Value(isDeleted),
      syncState: Value(syncState),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory SavingsGoal.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SavingsGoal(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      linkedAccountId: serializer.fromJson<String?>(json['linkedAccountId']),
      title: serializer.fromJson<String>(json['title']),
      currentAmount: serializer.fromJson<int>(json['currentAmount']),
      targetAmount: serializer.fromJson<int>(json['targetAmount']),
      currency: serializer.fromJson<String>(json['currency']),
      iconName: serializer.fromJson<String?>(json['iconName']),
      colorHex: serializer.fromJson<String?>(json['colorHex']),
      deadline: serializer.fromJson<DateTime?>(json['deadline']),
      isArchived: serializer.fromJson<bool>(json['isArchived']),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      baseRevision: serializer.fromJson<int?>(json['baseRevision']),
      operationId: serializer.fromJson<String?>(json['operationId']),
      lastModifiedByDeviceId: serializer.fromJson<String?>(
        json['lastModifiedByDeviceId'],
      ),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      syncState: serializer.fromJson<String>(json['syncState']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'linkedAccountId': serializer.toJson<String?>(linkedAccountId),
      'title': serializer.toJson<String>(title),
      'currentAmount': serializer.toJson<int>(currentAmount),
      'targetAmount': serializer.toJson<int>(targetAmount),
      'currency': serializer.toJson<String>(currency),
      'iconName': serializer.toJson<String?>(iconName),
      'colorHex': serializer.toJson<String?>(colorHex),
      'deadline': serializer.toJson<DateTime?>(deadline),
      'isArchived': serializer.toJson<bool>(isArchived),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'baseRevision': serializer.toJson<int?>(baseRevision),
      'operationId': serializer.toJson<String?>(operationId),
      'lastModifiedByDeviceId': serializer.toJson<String?>(
        lastModifiedByDeviceId,
      ),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'syncState': serializer.toJson<String>(syncState),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  SavingsGoal copyWith({
    String? id,
    String? userId,
    Value<String?> linkedAccountId = const Value.absent(),
    String? title,
    int? currentAmount,
    int? targetAmount,
    String? currency,
    Value<String?> iconName = const Value.absent(),
    Value<String?> colorHex = const Value.absent(),
    Value<DateTime?> deadline = const Value.absent(),
    bool? isArchived,
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    Value<int?> baseRevision = const Value.absent(),
    Value<String?> operationId = const Value.absent(),
    Value<String?> lastModifiedByDeviceId = const Value.absent(),
    bool? isDeleted,
    String? syncState,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => SavingsGoal(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    linkedAccountId: linkedAccountId.present
        ? linkedAccountId.value
        : this.linkedAccountId,
    title: title ?? this.title,
    currentAmount: currentAmount ?? this.currentAmount,
    targetAmount: targetAmount ?? this.targetAmount,
    currency: currency ?? this.currency,
    iconName: iconName.present ? iconName.value : this.iconName,
    colorHex: colorHex.present ? colorHex.value : this.colorHex,
    deadline: deadline.present ? deadline.value : this.deadline,
    isArchived: isArchived ?? this.isArchived,
    metadata: metadata.present ? metadata.value : this.metadata,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    baseRevision: baseRevision.present ? baseRevision.value : this.baseRevision,
    operationId: operationId.present ? operationId.value : this.operationId,
    lastModifiedByDeviceId: lastModifiedByDeviceId.present
        ? lastModifiedByDeviceId.value
        : this.lastModifiedByDeviceId,
    isDeleted: isDeleted ?? this.isDeleted,
    syncState: syncState ?? this.syncState,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  SavingsGoal copyWithCompanion(SavingsGoalsCompanion data) {
    return SavingsGoal(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      linkedAccountId: data.linkedAccountId.present
          ? data.linkedAccountId.value
          : this.linkedAccountId,
      title: data.title.present ? data.title.value : this.title,
      currentAmount: data.currentAmount.present
          ? data.currentAmount.value
          : this.currentAmount,
      targetAmount: data.targetAmount.present
          ? data.targetAmount.value
          : this.targetAmount,
      currency: data.currency.present ? data.currency.value : this.currency,
      iconName: data.iconName.present ? data.iconName.value : this.iconName,
      colorHex: data.colorHex.present ? data.colorHex.value : this.colorHex,
      deadline: data.deadline.present ? data.deadline.value : this.deadline,
      isArchived: data.isArchived.present
          ? data.isArchived.value
          : this.isArchived,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      baseRevision: data.baseRevision.present
          ? data.baseRevision.value
          : this.baseRevision,
      operationId: data.operationId.present
          ? data.operationId.value
          : this.operationId,
      lastModifiedByDeviceId: data.lastModifiedByDeviceId.present
          ? data.lastModifiedByDeviceId.value
          : this.lastModifiedByDeviceId,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SavingsGoal(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('linkedAccountId: $linkedAccountId, ')
          ..write('title: $title, ')
          ..write('currentAmount: $currentAmount, ')
          ..write('targetAmount: $targetAmount, ')
          ..write('currency: $currency, ')
          ..write('iconName: $iconName, ')
          ..write('colorHex: $colorHex, ')
          ..write('deadline: $deadline, ')
          ..write('isArchived: $isArchived, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hashAll([
    id,
    userId,
    linkedAccountId,
    title,
    currentAmount,
    targetAmount,
    currency,
    iconName,
    colorHex,
    deadline,
    isArchived,
    metadata,
    createdAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    isDeleted,
    syncState,
    lamportClock,
    versionVector,
  ]);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SavingsGoal &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.linkedAccountId == this.linkedAccountId &&
          other.title == this.title &&
          other.currentAmount == this.currentAmount &&
          other.targetAmount == this.targetAmount &&
          other.currency == this.currency &&
          other.iconName == this.iconName &&
          other.colorHex == this.colorHex &&
          other.deadline == this.deadline &&
          other.isArchived == this.isArchived &&
          other.metadata == this.metadata &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.baseRevision == this.baseRevision &&
          other.operationId == this.operationId &&
          other.lastModifiedByDeviceId == this.lastModifiedByDeviceId &&
          other.isDeleted == this.isDeleted &&
          other.syncState == this.syncState &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class SavingsGoalsCompanion extends UpdateCompanion<SavingsGoal> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String?> linkedAccountId;
  final Value<String> title;
  final Value<int> currentAmount;
  final Value<int> targetAmount;
  final Value<String> currency;
  final Value<String?> iconName;
  final Value<String?> colorHex;
  final Value<DateTime?> deadline;
  final Value<bool> isArchived;
  final Value<Map<String, dynamic>?> metadata;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<int?> baseRevision;
  final Value<String?> operationId;
  final Value<String?> lastModifiedByDeviceId;
  final Value<bool> isDeleted;
  final Value<String> syncState;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const SavingsGoalsCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.linkedAccountId = const Value.absent(),
    this.title = const Value.absent(),
    this.currentAmount = const Value.absent(),
    this.targetAmount = const Value.absent(),
    this.currency = const Value.absent(),
    this.iconName = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.deadline = const Value.absent(),
    this.isArchived = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SavingsGoalsCompanion.insert({
    required String id,
    required String userId,
    this.linkedAccountId = const Value.absent(),
    required String title,
    this.currentAmount = const Value.absent(),
    required int targetAmount,
    this.currency = const Value.absent(),
    this.iconName = const Value.absent(),
    this.colorHex = const Value.absent(),
    this.deadline = const Value.absent(),
    this.isArchived = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.syncState = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       title = Value(title),
       targetAmount = Value(targetAmount);
  static Insertable<SavingsGoal> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? linkedAccountId,
    Expression<String>? title,
    Expression<int>? currentAmount,
    Expression<int>? targetAmount,
    Expression<String>? currency,
    Expression<String>? iconName,
    Expression<String>? colorHex,
    Expression<DateTime>? deadline,
    Expression<bool>? isArchived,
    Expression<String>? metadata,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<int>? baseRevision,
    Expression<String>? operationId,
    Expression<String>? lastModifiedByDeviceId,
    Expression<bool>? isDeleted,
    Expression<String>? syncState,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (linkedAccountId != null) 'linked_account_id': linkedAccountId,
      if (title != null) 'title': title,
      if (currentAmount != null) 'current_amount': currentAmount,
      if (targetAmount != null) 'target_amount': targetAmount,
      if (currency != null) 'currency': currency,
      if (iconName != null) 'icon_name': iconName,
      if (colorHex != null) 'color_hex': colorHex,
      if (deadline != null) 'deadline': deadline,
      if (isArchived != null) 'is_archived': isArchived,
      if (metadata != null) 'metadata': metadata,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (baseRevision != null) 'base_revision': baseRevision,
      if (operationId != null) 'operation_id': operationId,
      if (lastModifiedByDeviceId != null)
        'last_modified_by_device_id': lastModifiedByDeviceId,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (syncState != null) 'sync_state': syncState,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SavingsGoalsCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String?>? linkedAccountId,
    Value<String>? title,
    Value<int>? currentAmount,
    Value<int>? targetAmount,
    Value<String>? currency,
    Value<String?>? iconName,
    Value<String?>? colorHex,
    Value<DateTime?>? deadline,
    Value<bool>? isArchived,
    Value<Map<String, dynamic>?>? metadata,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<int?>? baseRevision,
    Value<String?>? operationId,
    Value<String?>? lastModifiedByDeviceId,
    Value<bool>? isDeleted,
    Value<String>? syncState,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return SavingsGoalsCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      linkedAccountId: linkedAccountId ?? this.linkedAccountId,
      title: title ?? this.title,
      currentAmount: currentAmount ?? this.currentAmount,
      targetAmount: targetAmount ?? this.targetAmount,
      currency: currency ?? this.currency,
      iconName: iconName ?? this.iconName,
      colorHex: colorHex ?? this.colorHex,
      deadline: deadline ?? this.deadline,
      isArchived: isArchived ?? this.isArchived,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      baseRevision: baseRevision ?? this.baseRevision,
      operationId: operationId ?? this.operationId,
      lastModifiedByDeviceId:
          lastModifiedByDeviceId ?? this.lastModifiedByDeviceId,
      isDeleted: isDeleted ?? this.isDeleted,
      syncState: syncState ?? this.syncState,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (linkedAccountId.present) {
      map['linked_account_id'] = Variable<String>(linkedAccountId.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (currentAmount.present) {
      map['current_amount'] = Variable<int>(currentAmount.value);
    }
    if (targetAmount.present) {
      map['target_amount'] = Variable<int>(targetAmount.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (iconName.present) {
      map['icon_name'] = Variable<String>(iconName.value);
    }
    if (colorHex.present) {
      map['color_hex'] = Variable<String>(colorHex.value);
    }
    if (deadline.present) {
      map['deadline'] = Variable<DateTime>(deadline.value);
    }
    if (isArchived.present) {
      map['is_archived'] = Variable<bool>(isArchived.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $SavingsGoalsTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (baseRevision.present) {
      map['base_revision'] = Variable<int>(baseRevision.value);
    }
    if (operationId.present) {
      map['operation_id'] = Variable<String>(operationId.value);
    }
    if (lastModifiedByDeviceId.present) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId.value,
      );
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SavingsGoalsCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('linkedAccountId: $linkedAccountId, ')
          ..write('title: $title, ')
          ..write('currentAmount: $currentAmount, ')
          ..write('targetAmount: $targetAmount, ')
          ..write('currency: $currency, ')
          ..write('iconName: $iconName, ')
          ..write('colorHex: $colorHex, ')
          ..write('deadline: $deadline, ')
          ..write('isArchived: $isArchived, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('syncState: $syncState, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LocationsTable extends Locations
    with TableInfo<$LocationsTable, Location> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LocationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _accuracyMeta = const VerificationMeta(
    'accuracy',
  );
  @override
  late final GeneratedColumn<double> accuracy = GeneratedColumn<double>(
    'accuracy',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _altitudeMeta = const VerificationMeta(
    'altitude',
  );
  @override
  late final GeneratedColumn<double> altitude = GeneratedColumn<double>(
    'altitude',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _speedMeta = const VerificationMeta('speed');
  @override
  late final GeneratedColumn<double> speed = GeneratedColumn<double>(
    'speed',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _headingMeta = const VerificationMeta(
    'heading',
  );
  @override
  late final GeneratedColumn<double> heading = GeneratedColumn<double>(
    'heading',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _contextMeta = const VerificationMeta(
    'context',
  );
  @override
  late final GeneratedColumn<String> context = GeneratedColumn<String>(
    'context',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _sourceMeta = const VerificationMeta('source');
  @override
  late final GeneratedColumn<String> source = GeneratedColumn<String>(
    'source',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('gps'),
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>, String>
  deviceInfo = GeneratedColumn<String>(
    'device_info',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('{}'),
  ).withConverter<Map<String, dynamic>>($LocationsTable.$converterdeviceInfo);
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    latitude,
    longitude,
    accuracy,
    altitude,
    speed,
    heading,
    timestamp,
    context,
    source,
    deviceInfo,
    createdAt,
    revision,
    isDeleted,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'locations';
  @override
  VerificationContext validateIntegrity(
    Insertable<Location> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    } else if (isInserting) {
      context.missing(_latitudeMeta);
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    } else if (isInserting) {
      context.missing(_longitudeMeta);
    }
    if (data.containsKey('accuracy')) {
      context.handle(
        _accuracyMeta,
        accuracy.isAcceptableOrUnknown(data['accuracy']!, _accuracyMeta),
      );
    }
    if (data.containsKey('altitude')) {
      context.handle(
        _altitudeMeta,
        altitude.isAcceptableOrUnknown(data['altitude']!, _altitudeMeta),
      );
    }
    if (data.containsKey('speed')) {
      context.handle(
        _speedMeta,
        speed.isAcceptableOrUnknown(data['speed']!, _speedMeta),
      );
    }
    if (data.containsKey('heading')) {
      context.handle(
        _headingMeta,
        heading.isAcceptableOrUnknown(data['heading']!, _headingMeta),
      );
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('context')) {
      context.handle(
        _contextMeta,
        this.context.isAcceptableOrUnknown(data['context']!, _contextMeta),
      );
    }
    if (data.containsKey('source')) {
      context.handle(
        _sourceMeta,
        source.isAcceptableOrUnknown(data['source']!, _sourceMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Location map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Location(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      )!,
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      )!,
      accuracy: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}accuracy'],
      ),
      altitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}altitude'],
      ),
      speed: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}speed'],
      ),
      heading: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}heading'],
      ),
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
      context: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}context'],
      ),
      source: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source'],
      )!,
      deviceInfo: $LocationsTable.$converterdeviceInfo.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}device_info'],
        )!,
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
    );
  }

  @override
  $LocationsTable createAlias(String alias) {
    return $LocationsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $converterdeviceInfo =
      const MetadataConverter();
}

class Location extends DataClass implements Insertable<Location> {
  final String id;
  final String userId;
  final double latitude;
  final double longitude;
  final double? accuracy;
  final double? altitude;
  final double? speed;
  final double? heading;
  final DateTime timestamp;
  final String? context;
  final String source;
  final Map<String, dynamic> deviceInfo;
  final DateTime createdAt;
  final int revision;
  final bool isDeleted;
  const Location({
    required this.id,
    required this.userId,
    required this.latitude,
    required this.longitude,
    this.accuracy,
    this.altitude,
    this.speed,
    this.heading,
    required this.timestamp,
    this.context,
    required this.source,
    required this.deviceInfo,
    required this.createdAt,
    required this.revision,
    required this.isDeleted,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['latitude'] = Variable<double>(latitude);
    map['longitude'] = Variable<double>(longitude);
    if (!nullToAbsent || accuracy != null) {
      map['accuracy'] = Variable<double>(accuracy);
    }
    if (!nullToAbsent || altitude != null) {
      map['altitude'] = Variable<double>(altitude);
    }
    if (!nullToAbsent || speed != null) {
      map['speed'] = Variable<double>(speed);
    }
    if (!nullToAbsent || heading != null) {
      map['heading'] = Variable<double>(heading);
    }
    map['timestamp'] = Variable<DateTime>(timestamp);
    if (!nullToAbsent || context != null) {
      map['context'] = Variable<String>(context);
    }
    map['source'] = Variable<String>(source);
    {
      map['device_info'] = Variable<String>(
        $LocationsTable.$converterdeviceInfo.toSql(deviceInfo),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['revision'] = Variable<int>(revision);
    map['is_deleted'] = Variable<bool>(isDeleted);
    return map;
  }

  LocationsCompanion toCompanion(bool nullToAbsent) {
    return LocationsCompanion(
      id: Value(id),
      userId: Value(userId),
      latitude: Value(latitude),
      longitude: Value(longitude),
      accuracy: accuracy == null && nullToAbsent
          ? const Value.absent()
          : Value(accuracy),
      altitude: altitude == null && nullToAbsent
          ? const Value.absent()
          : Value(altitude),
      speed: speed == null && nullToAbsent
          ? const Value.absent()
          : Value(speed),
      heading: heading == null && nullToAbsent
          ? const Value.absent()
          : Value(heading),
      timestamp: Value(timestamp),
      context: context == null && nullToAbsent
          ? const Value.absent()
          : Value(context),
      source: Value(source),
      deviceInfo: Value(deviceInfo),
      createdAt: Value(createdAt),
      revision: Value(revision),
      isDeleted: Value(isDeleted),
    );
  }

  factory Location.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Location(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      latitude: serializer.fromJson<double>(json['latitude']),
      longitude: serializer.fromJson<double>(json['longitude']),
      accuracy: serializer.fromJson<double?>(json['accuracy']),
      altitude: serializer.fromJson<double?>(json['altitude']),
      speed: serializer.fromJson<double?>(json['speed']),
      heading: serializer.fromJson<double?>(json['heading']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      context: serializer.fromJson<String?>(json['context']),
      source: serializer.fromJson<String>(json['source']),
      deviceInfo: serializer.fromJson<Map<String, dynamic>>(json['deviceInfo']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      revision: serializer.fromJson<int>(json['revision']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'latitude': serializer.toJson<double>(latitude),
      'longitude': serializer.toJson<double>(longitude),
      'accuracy': serializer.toJson<double?>(accuracy),
      'altitude': serializer.toJson<double?>(altitude),
      'speed': serializer.toJson<double?>(speed),
      'heading': serializer.toJson<double?>(heading),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'context': serializer.toJson<String?>(context),
      'source': serializer.toJson<String>(source),
      'deviceInfo': serializer.toJson<Map<String, dynamic>>(deviceInfo),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'revision': serializer.toJson<int>(revision),
      'isDeleted': serializer.toJson<bool>(isDeleted),
    };
  }

  Location copyWith({
    String? id,
    String? userId,
    double? latitude,
    double? longitude,
    Value<double?> accuracy = const Value.absent(),
    Value<double?> altitude = const Value.absent(),
    Value<double?> speed = const Value.absent(),
    Value<double?> heading = const Value.absent(),
    DateTime? timestamp,
    Value<String?> context = const Value.absent(),
    String? source,
    Map<String, dynamic>? deviceInfo,
    DateTime? createdAt,
    int? revision,
    bool? isDeleted,
  }) => Location(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    latitude: latitude ?? this.latitude,
    longitude: longitude ?? this.longitude,
    accuracy: accuracy.present ? accuracy.value : this.accuracy,
    altitude: altitude.present ? altitude.value : this.altitude,
    speed: speed.present ? speed.value : this.speed,
    heading: heading.present ? heading.value : this.heading,
    timestamp: timestamp ?? this.timestamp,
    context: context.present ? context.value : this.context,
    source: source ?? this.source,
    deviceInfo: deviceInfo ?? this.deviceInfo,
    createdAt: createdAt ?? this.createdAt,
    revision: revision ?? this.revision,
    isDeleted: isDeleted ?? this.isDeleted,
  );
  Location copyWithCompanion(LocationsCompanion data) {
    return Location(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      accuracy: data.accuracy.present ? data.accuracy.value : this.accuracy,
      altitude: data.altitude.present ? data.altitude.value : this.altitude,
      speed: data.speed.present ? data.speed.value : this.speed,
      heading: data.heading.present ? data.heading.value : this.heading,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      context: data.context.present ? data.context.value : this.context,
      source: data.source.present ? data.source.value : this.source,
      deviceInfo: data.deviceInfo.present
          ? data.deviceInfo.value
          : this.deviceInfo,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Location(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('accuracy: $accuracy, ')
          ..write('altitude: $altitude, ')
          ..write('speed: $speed, ')
          ..write('heading: $heading, ')
          ..write('timestamp: $timestamp, ')
          ..write('context: $context, ')
          ..write('source: $source, ')
          ..write('deviceInfo: $deviceInfo, ')
          ..write('createdAt: $createdAt, ')
          ..write('revision: $revision, ')
          ..write('isDeleted: $isDeleted')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    latitude,
    longitude,
    accuracy,
    altitude,
    speed,
    heading,
    timestamp,
    context,
    source,
    deviceInfo,
    createdAt,
    revision,
    isDeleted,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Location &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.accuracy == this.accuracy &&
          other.altitude == this.altitude &&
          other.speed == this.speed &&
          other.heading == this.heading &&
          other.timestamp == this.timestamp &&
          other.context == this.context &&
          other.source == this.source &&
          other.deviceInfo == this.deviceInfo &&
          other.createdAt == this.createdAt &&
          other.revision == this.revision &&
          other.isDeleted == this.isDeleted);
}

class LocationsCompanion extends UpdateCompanion<Location> {
  final Value<String> id;
  final Value<String> userId;
  final Value<double> latitude;
  final Value<double> longitude;
  final Value<double?> accuracy;
  final Value<double?> altitude;
  final Value<double?> speed;
  final Value<double?> heading;
  final Value<DateTime> timestamp;
  final Value<String?> context;
  final Value<String> source;
  final Value<Map<String, dynamic>> deviceInfo;
  final Value<DateTime> createdAt;
  final Value<int> revision;
  final Value<bool> isDeleted;
  final Value<int> rowid;
  const LocationsCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.accuracy = const Value.absent(),
    this.altitude = const Value.absent(),
    this.speed = const Value.absent(),
    this.heading = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.context = const Value.absent(),
    this.source = const Value.absent(),
    this.deviceInfo = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  LocationsCompanion.insert({
    required String id,
    required String userId,
    required double latitude,
    required double longitude,
    this.accuracy = const Value.absent(),
    this.altitude = const Value.absent(),
    this.speed = const Value.absent(),
    this.heading = const Value.absent(),
    required DateTime timestamp,
    this.context = const Value.absent(),
    this.source = const Value.absent(),
    this.deviceInfo = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       latitude = Value(latitude),
       longitude = Value(longitude),
       timestamp = Value(timestamp);
  static Insertable<Location> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<double>? accuracy,
    Expression<double>? altitude,
    Expression<double>? speed,
    Expression<double>? heading,
    Expression<DateTime>? timestamp,
    Expression<String>? context,
    Expression<String>? source,
    Expression<String>? deviceInfo,
    Expression<DateTime>? createdAt,
    Expression<int>? revision,
    Expression<bool>? isDeleted,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (accuracy != null) 'accuracy': accuracy,
      if (altitude != null) 'altitude': altitude,
      if (speed != null) 'speed': speed,
      if (heading != null) 'heading': heading,
      if (timestamp != null) 'timestamp': timestamp,
      if (context != null) 'context': context,
      if (source != null) 'source': source,
      if (deviceInfo != null) 'device_info': deviceInfo,
      if (createdAt != null) 'created_at': createdAt,
      if (revision != null) 'revision': revision,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LocationsCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<double>? latitude,
    Value<double>? longitude,
    Value<double?>? accuracy,
    Value<double?>? altitude,
    Value<double?>? speed,
    Value<double?>? heading,
    Value<DateTime>? timestamp,
    Value<String?>? context,
    Value<String>? source,
    Value<Map<String, dynamic>>? deviceInfo,
    Value<DateTime>? createdAt,
    Value<int>? revision,
    Value<bool>? isDeleted,
    Value<int>? rowid,
  }) {
    return LocationsCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      accuracy: accuracy ?? this.accuracy,
      altitude: altitude ?? this.altitude,
      speed: speed ?? this.speed,
      heading: heading ?? this.heading,
      timestamp: timestamp ?? this.timestamp,
      context: context ?? this.context,
      source: source ?? this.source,
      deviceInfo: deviceInfo ?? this.deviceInfo,
      createdAt: createdAt ?? this.createdAt,
      revision: revision ?? this.revision,
      isDeleted: isDeleted ?? this.isDeleted,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (accuracy.present) {
      map['accuracy'] = Variable<double>(accuracy.value);
    }
    if (altitude.present) {
      map['altitude'] = Variable<double>(altitude.value);
    }
    if (speed.present) {
      map['speed'] = Variable<double>(speed.value);
    }
    if (heading.present) {
      map['heading'] = Variable<double>(heading.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (context.present) {
      map['context'] = Variable<String>(context.value);
    }
    if (source.present) {
      map['source'] = Variable<String>(source.value);
    }
    if (deviceInfo.present) {
      map['device_info'] = Variable<String>(
        $LocationsTable.$converterdeviceInfo.toSql(deviceInfo.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LocationsCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('accuracy: $accuracy, ')
          ..write('altitude: $altitude, ')
          ..write('speed: $speed, ')
          ..write('heading: $heading, ')
          ..write('timestamp: $timestamp, ')
          ..write('context: $context, ')
          ..write('source: $source, ')
          ..write('deviceInfo: $deviceInfo, ')
          ..write('createdAt: $createdAt, ')
          ..write('revision: $revision, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GeocodingCacheTable extends GeocodingCache
    with TableInfo<$GeocodingCacheTable, GeocodingCacheData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GeocodingCacheTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _formatMeta = const VerificationMeta('format');
  @override
  late final GeneratedColumn<String> format = GeneratedColumn<String>(
    'format',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _languageCodeMeta = const VerificationMeta(
    'languageCode',
  );
  @override
  late final GeneratedColumn<String> languageCode = GeneratedColumn<String>(
    'language_code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('en'),
  );
  static const VerificationMeta _addressMeta = const VerificationMeta(
    'address',
  );
  @override
  late final GeneratedColumn<String> address = GeneratedColumn<String>(
    'address',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _fullAddressMeta = const VerificationMeta(
    'fullAddress',
  );
  @override
  late final GeneratedColumn<String> fullAddress = GeneratedColumn<String>(
    'full_address',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
    'expires_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    latitude,
    longitude,
    format,
    languageCode,
    address,
    fullAddress,
    expiresAt,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'geocoding_cache';
  @override
  VerificationContext validateIntegrity(
    Insertable<GeocodingCacheData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    } else if (isInserting) {
      context.missing(_latitudeMeta);
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    } else if (isInserting) {
      context.missing(_longitudeMeta);
    }
    if (data.containsKey('format')) {
      context.handle(
        _formatMeta,
        format.isAcceptableOrUnknown(data['format']!, _formatMeta),
      );
    } else if (isInserting) {
      context.missing(_formatMeta);
    }
    if (data.containsKey('language_code')) {
      context.handle(
        _languageCodeMeta,
        languageCode.isAcceptableOrUnknown(
          data['language_code']!,
          _languageCodeMeta,
        ),
      );
    }
    if (data.containsKey('address')) {
      context.handle(
        _addressMeta,
        address.isAcceptableOrUnknown(data['address']!, _addressMeta),
      );
    } else if (isInserting) {
      context.missing(_addressMeta);
    }
    if (data.containsKey('full_address')) {
      context.handle(
        _fullAddressMeta,
        fullAddress.isAcceptableOrUnknown(
          data['full_address']!,
          _fullAddressMeta,
        ),
      );
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    } else if (isInserting) {
      context.missing(_expiresAtMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {
    latitude,
    longitude,
    format,
    languageCode,
  };
  @override
  GeocodingCacheData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GeocodingCacheData(
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      )!,
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      )!,
      format: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}format'],
      )!,
      languageCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}language_code'],
      )!,
      address: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}address'],
      )!,
      fullAddress: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}full_address'],
      ),
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expires_at'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $GeocodingCacheTable createAlias(String alias) {
    return $GeocodingCacheTable(attachedDatabase, alias);
  }
}

class GeocodingCacheData extends DataClass
    implements Insertable<GeocodingCacheData> {
  final double latitude;
  final double longitude;
  final String format;
  final String languageCode;
  final String address;
  final String? fullAddress;
  final DateTime expiresAt;
  final DateTime createdAt;
  const GeocodingCacheData({
    required this.latitude,
    required this.longitude,
    required this.format,
    required this.languageCode,
    required this.address,
    this.fullAddress,
    required this.expiresAt,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['latitude'] = Variable<double>(latitude);
    map['longitude'] = Variable<double>(longitude);
    map['format'] = Variable<String>(format);
    map['language_code'] = Variable<String>(languageCode);
    map['address'] = Variable<String>(address);
    if (!nullToAbsent || fullAddress != null) {
      map['full_address'] = Variable<String>(fullAddress);
    }
    map['expires_at'] = Variable<DateTime>(expiresAt);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  GeocodingCacheCompanion toCompanion(bool nullToAbsent) {
    return GeocodingCacheCompanion(
      latitude: Value(latitude),
      longitude: Value(longitude),
      format: Value(format),
      languageCode: Value(languageCode),
      address: Value(address),
      fullAddress: fullAddress == null && nullToAbsent
          ? const Value.absent()
          : Value(fullAddress),
      expiresAt: Value(expiresAt),
      createdAt: Value(createdAt),
    );
  }

  factory GeocodingCacheData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GeocodingCacheData(
      latitude: serializer.fromJson<double>(json['latitude']),
      longitude: serializer.fromJson<double>(json['longitude']),
      format: serializer.fromJson<String>(json['format']),
      languageCode: serializer.fromJson<String>(json['languageCode']),
      address: serializer.fromJson<String>(json['address']),
      fullAddress: serializer.fromJson<String?>(json['fullAddress']),
      expiresAt: serializer.fromJson<DateTime>(json['expiresAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'latitude': serializer.toJson<double>(latitude),
      'longitude': serializer.toJson<double>(longitude),
      'format': serializer.toJson<String>(format),
      'languageCode': serializer.toJson<String>(languageCode),
      'address': serializer.toJson<String>(address),
      'fullAddress': serializer.toJson<String?>(fullAddress),
      'expiresAt': serializer.toJson<DateTime>(expiresAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  GeocodingCacheData copyWith({
    double? latitude,
    double? longitude,
    String? format,
    String? languageCode,
    String? address,
    Value<String?> fullAddress = const Value.absent(),
    DateTime? expiresAt,
    DateTime? createdAt,
  }) => GeocodingCacheData(
    latitude: latitude ?? this.latitude,
    longitude: longitude ?? this.longitude,
    format: format ?? this.format,
    languageCode: languageCode ?? this.languageCode,
    address: address ?? this.address,
    fullAddress: fullAddress.present ? fullAddress.value : this.fullAddress,
    expiresAt: expiresAt ?? this.expiresAt,
    createdAt: createdAt ?? this.createdAt,
  );
  GeocodingCacheData copyWithCompanion(GeocodingCacheCompanion data) {
    return GeocodingCacheData(
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      format: data.format.present ? data.format.value : this.format,
      languageCode: data.languageCode.present
          ? data.languageCode.value
          : this.languageCode,
      address: data.address.present ? data.address.value : this.address,
      fullAddress: data.fullAddress.present
          ? data.fullAddress.value
          : this.fullAddress,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GeocodingCacheData(')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('format: $format, ')
          ..write('languageCode: $languageCode, ')
          ..write('address: $address, ')
          ..write('fullAddress: $fullAddress, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    latitude,
    longitude,
    format,
    languageCode,
    address,
    fullAddress,
    expiresAt,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GeocodingCacheData &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.format == this.format &&
          other.languageCode == this.languageCode &&
          other.address == this.address &&
          other.fullAddress == this.fullAddress &&
          other.expiresAt == this.expiresAt &&
          other.createdAt == this.createdAt);
}

class GeocodingCacheCompanion extends UpdateCompanion<GeocodingCacheData> {
  final Value<double> latitude;
  final Value<double> longitude;
  final Value<String> format;
  final Value<String> languageCode;
  final Value<String> address;
  final Value<String?> fullAddress;
  final Value<DateTime> expiresAt;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const GeocodingCacheCompanion({
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.format = const Value.absent(),
    this.languageCode = const Value.absent(),
    this.address = const Value.absent(),
    this.fullAddress = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  GeocodingCacheCompanion.insert({
    required double latitude,
    required double longitude,
    required String format,
    this.languageCode = const Value.absent(),
    required String address,
    this.fullAddress = const Value.absent(),
    required DateTime expiresAt,
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : latitude = Value(latitude),
       longitude = Value(longitude),
       format = Value(format),
       address = Value(address),
       expiresAt = Value(expiresAt);
  static Insertable<GeocodingCacheData> custom({
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<String>? format,
    Expression<String>? languageCode,
    Expression<String>? address,
    Expression<String>? fullAddress,
    Expression<DateTime>? expiresAt,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (format != null) 'format': format,
      if (languageCode != null) 'language_code': languageCode,
      if (address != null) 'address': address,
      if (fullAddress != null) 'full_address': fullAddress,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GeocodingCacheCompanion copyWith({
    Value<double>? latitude,
    Value<double>? longitude,
    Value<String>? format,
    Value<String>? languageCode,
    Value<String>? address,
    Value<String?>? fullAddress,
    Value<DateTime>? expiresAt,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return GeocodingCacheCompanion(
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      format: format ?? this.format,
      languageCode: languageCode ?? this.languageCode,
      address: address ?? this.address,
      fullAddress: fullAddress ?? this.fullAddress,
      expiresAt: expiresAt ?? this.expiresAt,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (format.present) {
      map['format'] = Variable<String>(format.value);
    }
    if (languageCode.present) {
      map['language_code'] = Variable<String>(languageCode.value);
    }
    if (address.present) {
      map['address'] = Variable<String>(address.value);
    }
    if (fullAddress.present) {
      map['full_address'] = Variable<String>(fullAddress.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GeocodingCacheCompanion(')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('format: $format, ')
          ..write('languageCode: $languageCode, ')
          ..write('address: $address, ')
          ..write('fullAddress: $fullAddress, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ExpenseLocationsTable extends ExpenseLocations
    with TableInfo<$ExpenseLocationsTable, ExpenseLocation> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ExpenseLocationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _expenseIdMeta = const VerificationMeta(
    'expenseId',
  );
  @override
  late final GeneratedColumn<String> expenseId = GeneratedColumn<String>(
    'expense_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES expenses (id)',
    ),
  );
  static const VerificationMeta _locationIdMeta = const VerificationMeta(
    'locationId',
  );
  @override
  late final GeneratedColumn<String> locationId = GeneratedColumn<String>(
    'location_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES locations (id)',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [expenseId, locationId, createdAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'expense_locations';
  @override
  VerificationContext validateIntegrity(
    Insertable<ExpenseLocation> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('expense_id')) {
      context.handle(
        _expenseIdMeta,
        expenseId.isAcceptableOrUnknown(data['expense_id']!, _expenseIdMeta),
      );
    } else if (isInserting) {
      context.missing(_expenseIdMeta);
    }
    if (data.containsKey('location_id')) {
      context.handle(
        _locationIdMeta,
        locationId.isAcceptableOrUnknown(data['location_id']!, _locationIdMeta),
      );
    } else if (isInserting) {
      context.missing(_locationIdMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {expenseId, locationId};
  @override
  ExpenseLocation map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ExpenseLocation(
      expenseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}expense_id'],
      )!,
      locationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}location_id'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $ExpenseLocationsTable createAlias(String alias) {
    return $ExpenseLocationsTable(attachedDatabase, alias);
  }
}

class ExpenseLocation extends DataClass implements Insertable<ExpenseLocation> {
  final String expenseId;
  final String locationId;
  final DateTime createdAt;
  const ExpenseLocation({
    required this.expenseId,
    required this.locationId,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['expense_id'] = Variable<String>(expenseId);
    map['location_id'] = Variable<String>(locationId);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  ExpenseLocationsCompanion toCompanion(bool nullToAbsent) {
    return ExpenseLocationsCompanion(
      expenseId: Value(expenseId),
      locationId: Value(locationId),
      createdAt: Value(createdAt),
    );
  }

  factory ExpenseLocation.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ExpenseLocation(
      expenseId: serializer.fromJson<String>(json['expenseId']),
      locationId: serializer.fromJson<String>(json['locationId']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'expenseId': serializer.toJson<String>(expenseId),
      'locationId': serializer.toJson<String>(locationId),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  ExpenseLocation copyWith({
    String? expenseId,
    String? locationId,
    DateTime? createdAt,
  }) => ExpenseLocation(
    expenseId: expenseId ?? this.expenseId,
    locationId: locationId ?? this.locationId,
    createdAt: createdAt ?? this.createdAt,
  );
  ExpenseLocation copyWithCompanion(ExpenseLocationsCompanion data) {
    return ExpenseLocation(
      expenseId: data.expenseId.present ? data.expenseId.value : this.expenseId,
      locationId: data.locationId.present
          ? data.locationId.value
          : this.locationId,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ExpenseLocation(')
          ..write('expenseId: $expenseId, ')
          ..write('locationId: $locationId, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(expenseId, locationId, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ExpenseLocation &&
          other.expenseId == this.expenseId &&
          other.locationId == this.locationId &&
          other.createdAt == this.createdAt);
}

class ExpenseLocationsCompanion extends UpdateCompanion<ExpenseLocation> {
  final Value<String> expenseId;
  final Value<String> locationId;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const ExpenseLocationsCompanion({
    this.expenseId = const Value.absent(),
    this.locationId = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ExpenseLocationsCompanion.insert({
    required String expenseId,
    required String locationId,
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : expenseId = Value(expenseId),
       locationId = Value(locationId);
  static Insertable<ExpenseLocation> custom({
    Expression<String>? expenseId,
    Expression<String>? locationId,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (expenseId != null) 'expense_id': expenseId,
      if (locationId != null) 'location_id': locationId,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ExpenseLocationsCompanion copyWith({
    Value<String>? expenseId,
    Value<String>? locationId,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return ExpenseLocationsCompanion(
      expenseId: expenseId ?? this.expenseId,
      locationId: locationId ?? this.locationId,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (expenseId.present) {
      map['expense_id'] = Variable<String>(expenseId.value);
    }
    if (locationId.present) {
      map['location_id'] = Variable<String>(locationId.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ExpenseLocationsCompanion(')
          ..write('expenseId: $expenseId, ')
          ..write('locationId: $locationId, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $RecurringExpenseLocationsTable extends RecurringExpenseLocations
    with TableInfo<$RecurringExpenseLocationsTable, RecurringExpenseLocation> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $RecurringExpenseLocationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _recurringExpenseIdMeta =
      const VerificationMeta('recurringExpenseId');
  @override
  late final GeneratedColumn<String> recurringExpenseId =
      GeneratedColumn<String>(
        'recurring_expense_id',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: true,
        defaultConstraints: GeneratedColumn.constraintIsAlways(
          'REFERENCES recurring_expenses (id)',
        ),
      );
  static const VerificationMeta _locationIdMeta = const VerificationMeta(
    'locationId',
  );
  @override
  late final GeneratedColumn<String> locationId = GeneratedColumn<String>(
    'location_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES locations (id)',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    recurringExpenseId,
    locationId,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'recurring_expense_locations';
  @override
  VerificationContext validateIntegrity(
    Insertable<RecurringExpenseLocation> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('recurring_expense_id')) {
      context.handle(
        _recurringExpenseIdMeta,
        recurringExpenseId.isAcceptableOrUnknown(
          data['recurring_expense_id']!,
          _recurringExpenseIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_recurringExpenseIdMeta);
    }
    if (data.containsKey('location_id')) {
      context.handle(
        _locationIdMeta,
        locationId.isAcceptableOrUnknown(data['location_id']!, _locationIdMeta),
      );
    } else if (isInserting) {
      context.missing(_locationIdMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {recurringExpenseId, locationId};
  @override
  RecurringExpenseLocation map(
    Map<String, dynamic> data, {
    String? tablePrefix,
  }) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return RecurringExpenseLocation(
      recurringExpenseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}recurring_expense_id'],
      )!,
      locationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}location_id'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $RecurringExpenseLocationsTable createAlias(String alias) {
    return $RecurringExpenseLocationsTable(attachedDatabase, alias);
  }
}

class RecurringExpenseLocation extends DataClass
    implements Insertable<RecurringExpenseLocation> {
  final String recurringExpenseId;
  final String locationId;
  final DateTime createdAt;
  const RecurringExpenseLocation({
    required this.recurringExpenseId,
    required this.locationId,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['recurring_expense_id'] = Variable<String>(recurringExpenseId);
    map['location_id'] = Variable<String>(locationId);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  RecurringExpenseLocationsCompanion toCompanion(bool nullToAbsent) {
    return RecurringExpenseLocationsCompanion(
      recurringExpenseId: Value(recurringExpenseId),
      locationId: Value(locationId),
      createdAt: Value(createdAt),
    );
  }

  factory RecurringExpenseLocation.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return RecurringExpenseLocation(
      recurringExpenseId: serializer.fromJson<String>(
        json['recurringExpenseId'],
      ),
      locationId: serializer.fromJson<String>(json['locationId']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'recurringExpenseId': serializer.toJson<String>(recurringExpenseId),
      'locationId': serializer.toJson<String>(locationId),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  RecurringExpenseLocation copyWith({
    String? recurringExpenseId,
    String? locationId,
    DateTime? createdAt,
  }) => RecurringExpenseLocation(
    recurringExpenseId: recurringExpenseId ?? this.recurringExpenseId,
    locationId: locationId ?? this.locationId,
    createdAt: createdAt ?? this.createdAt,
  );
  RecurringExpenseLocation copyWithCompanion(
    RecurringExpenseLocationsCompanion data,
  ) {
    return RecurringExpenseLocation(
      recurringExpenseId: data.recurringExpenseId.present
          ? data.recurringExpenseId.value
          : this.recurringExpenseId,
      locationId: data.locationId.present
          ? data.locationId.value
          : this.locationId,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('RecurringExpenseLocation(')
          ..write('recurringExpenseId: $recurringExpenseId, ')
          ..write('locationId: $locationId, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(recurringExpenseId, locationId, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is RecurringExpenseLocation &&
          other.recurringExpenseId == this.recurringExpenseId &&
          other.locationId == this.locationId &&
          other.createdAt == this.createdAt);
}

class RecurringExpenseLocationsCompanion
    extends UpdateCompanion<RecurringExpenseLocation> {
  final Value<String> recurringExpenseId;
  final Value<String> locationId;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const RecurringExpenseLocationsCompanion({
    this.recurringExpenseId = const Value.absent(),
    this.locationId = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  RecurringExpenseLocationsCompanion.insert({
    required String recurringExpenseId,
    required String locationId,
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : recurringExpenseId = Value(recurringExpenseId),
       locationId = Value(locationId);
  static Insertable<RecurringExpenseLocation> custom({
    Expression<String>? recurringExpenseId,
    Expression<String>? locationId,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (recurringExpenseId != null)
        'recurring_expense_id': recurringExpenseId,
      if (locationId != null) 'location_id': locationId,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  RecurringExpenseLocationsCompanion copyWith({
    Value<String>? recurringExpenseId,
    Value<String>? locationId,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return RecurringExpenseLocationsCompanion(
      recurringExpenseId: recurringExpenseId ?? this.recurringExpenseId,
      locationId: locationId ?? this.locationId,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (recurringExpenseId.present) {
      map['recurring_expense_id'] = Variable<String>(recurringExpenseId.value);
    }
    if (locationId.present) {
      map['location_id'] = Variable<String>(locationId.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('RecurringExpenseLocationsCompanion(')
          ..write('recurringExpenseId: $recurringExpenseId, ')
          ..write('locationId: $locationId, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LocationAnalyticsTable extends LocationAnalytics
    with TableInfo<$LocationAnalyticsTable, LocationAnalytic> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LocationAnalyticsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _locationIdMeta = const VerificationMeta(
    'locationId',
  );
  @override
  late final GeneratedColumn<String> locationId = GeneratedColumn<String>(
    'location_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES locations (id)',
    ),
  );
  static const VerificationMeta _accuracyMeta = const VerificationMeta(
    'accuracy',
  );
  @override
  late final GeneratedColumn<double> accuracy = GeneratedColumn<double>(
    'accuracy',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _speedMeta = const VerificationMeta('speed');
  @override
  late final GeneratedColumn<double> speed = GeneratedColumn<double>(
    'speed',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _batteryImpactMeta = const VerificationMeta(
    'batteryImpact',
  );
  @override
  late final GeneratedColumn<String> batteryImpact = GeneratedColumn<String>(
    'battery_impact',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _networkTypeMeta = const VerificationMeta(
    'networkType',
  );
  @override
  late final GeneratedColumn<String> networkType = GeneratedColumn<String>(
    'network_type',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    locationId,
    accuracy,
    speed,
    batteryImpact,
    networkType,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'location_analytics';
  @override
  VerificationContext validateIntegrity(
    Insertable<LocationAnalytic> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    }
    if (data.containsKey('location_id')) {
      context.handle(
        _locationIdMeta,
        locationId.isAcceptableOrUnknown(data['location_id']!, _locationIdMeta),
      );
    }
    if (data.containsKey('accuracy')) {
      context.handle(
        _accuracyMeta,
        accuracy.isAcceptableOrUnknown(data['accuracy']!, _accuracyMeta),
      );
    }
    if (data.containsKey('speed')) {
      context.handle(
        _speedMeta,
        speed.isAcceptableOrUnknown(data['speed']!, _speedMeta),
      );
    }
    if (data.containsKey('battery_impact')) {
      context.handle(
        _batteryImpactMeta,
        batteryImpact.isAcceptableOrUnknown(
          data['battery_impact']!,
          _batteryImpactMeta,
        ),
      );
    }
    if (data.containsKey('network_type')) {
      context.handle(
        _networkTypeMeta,
        networkType.isAcceptableOrUnknown(
          data['network_type']!,
          _networkTypeMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  LocationAnalytic map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LocationAnalytic(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      ),
      locationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}location_id'],
      ),
      accuracy: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}accuracy'],
      ),
      speed: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}speed'],
      ),
      batteryImpact: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}battery_impact'],
      ),
      networkType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}network_type'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $LocationAnalyticsTable createAlias(String alias) {
    return $LocationAnalyticsTable(attachedDatabase, alias);
  }
}

class LocationAnalytic extends DataClass
    implements Insertable<LocationAnalytic> {
  final String id;
  final String? userId;
  final String? locationId;
  final double? accuracy;
  final double? speed;
  final String? batteryImpact;
  final String? networkType;
  final DateTime createdAt;
  const LocationAnalytic({
    required this.id,
    this.userId,
    this.locationId,
    this.accuracy,
    this.speed,
    this.batteryImpact,
    this.networkType,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || userId != null) {
      map['user_id'] = Variable<String>(userId);
    }
    if (!nullToAbsent || locationId != null) {
      map['location_id'] = Variable<String>(locationId);
    }
    if (!nullToAbsent || accuracy != null) {
      map['accuracy'] = Variable<double>(accuracy);
    }
    if (!nullToAbsent || speed != null) {
      map['speed'] = Variable<double>(speed);
    }
    if (!nullToAbsent || batteryImpact != null) {
      map['battery_impact'] = Variable<String>(batteryImpact);
    }
    if (!nullToAbsent || networkType != null) {
      map['network_type'] = Variable<String>(networkType);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  LocationAnalyticsCompanion toCompanion(bool nullToAbsent) {
    return LocationAnalyticsCompanion(
      id: Value(id),
      userId: userId == null && nullToAbsent
          ? const Value.absent()
          : Value(userId),
      locationId: locationId == null && nullToAbsent
          ? const Value.absent()
          : Value(locationId),
      accuracy: accuracy == null && nullToAbsent
          ? const Value.absent()
          : Value(accuracy),
      speed: speed == null && nullToAbsent
          ? const Value.absent()
          : Value(speed),
      batteryImpact: batteryImpact == null && nullToAbsent
          ? const Value.absent()
          : Value(batteryImpact),
      networkType: networkType == null && nullToAbsent
          ? const Value.absent()
          : Value(networkType),
      createdAt: Value(createdAt),
    );
  }

  factory LocationAnalytic.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LocationAnalytic(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String?>(json['userId']),
      locationId: serializer.fromJson<String?>(json['locationId']),
      accuracy: serializer.fromJson<double?>(json['accuracy']),
      speed: serializer.fromJson<double?>(json['speed']),
      batteryImpact: serializer.fromJson<String?>(json['batteryImpact']),
      networkType: serializer.fromJson<String?>(json['networkType']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String?>(userId),
      'locationId': serializer.toJson<String?>(locationId),
      'accuracy': serializer.toJson<double?>(accuracy),
      'speed': serializer.toJson<double?>(speed),
      'batteryImpact': serializer.toJson<String?>(batteryImpact),
      'networkType': serializer.toJson<String?>(networkType),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  LocationAnalytic copyWith({
    String? id,
    Value<String?> userId = const Value.absent(),
    Value<String?> locationId = const Value.absent(),
    Value<double?> accuracy = const Value.absent(),
    Value<double?> speed = const Value.absent(),
    Value<String?> batteryImpact = const Value.absent(),
    Value<String?> networkType = const Value.absent(),
    DateTime? createdAt,
  }) => LocationAnalytic(
    id: id ?? this.id,
    userId: userId.present ? userId.value : this.userId,
    locationId: locationId.present ? locationId.value : this.locationId,
    accuracy: accuracy.present ? accuracy.value : this.accuracy,
    speed: speed.present ? speed.value : this.speed,
    batteryImpact: batteryImpact.present
        ? batteryImpact.value
        : this.batteryImpact,
    networkType: networkType.present ? networkType.value : this.networkType,
    createdAt: createdAt ?? this.createdAt,
  );
  LocationAnalytic copyWithCompanion(LocationAnalyticsCompanion data) {
    return LocationAnalytic(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      locationId: data.locationId.present
          ? data.locationId.value
          : this.locationId,
      accuracy: data.accuracy.present ? data.accuracy.value : this.accuracy,
      speed: data.speed.present ? data.speed.value : this.speed,
      batteryImpact: data.batteryImpact.present
          ? data.batteryImpact.value
          : this.batteryImpact,
      networkType: data.networkType.present
          ? data.networkType.value
          : this.networkType,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LocationAnalytic(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('locationId: $locationId, ')
          ..write('accuracy: $accuracy, ')
          ..write('speed: $speed, ')
          ..write('batteryImpact: $batteryImpact, ')
          ..write('networkType: $networkType, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    locationId,
    accuracy,
    speed,
    batteryImpact,
    networkType,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LocationAnalytic &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.locationId == this.locationId &&
          other.accuracy == this.accuracy &&
          other.speed == this.speed &&
          other.batteryImpact == this.batteryImpact &&
          other.networkType == this.networkType &&
          other.createdAt == this.createdAt);
}

class LocationAnalyticsCompanion extends UpdateCompanion<LocationAnalytic> {
  final Value<String> id;
  final Value<String?> userId;
  final Value<String?> locationId;
  final Value<double?> accuracy;
  final Value<double?> speed;
  final Value<String?> batteryImpact;
  final Value<String?> networkType;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const LocationAnalyticsCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.locationId = const Value.absent(),
    this.accuracy = const Value.absent(),
    this.speed = const Value.absent(),
    this.batteryImpact = const Value.absent(),
    this.networkType = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  LocationAnalyticsCompanion.insert({
    required String id,
    this.userId = const Value.absent(),
    this.locationId = const Value.absent(),
    this.accuracy = const Value.absent(),
    this.speed = const Value.absent(),
    this.batteryImpact = const Value.absent(),
    this.networkType = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id);
  static Insertable<LocationAnalytic> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? locationId,
    Expression<double>? accuracy,
    Expression<double>? speed,
    Expression<String>? batteryImpact,
    Expression<String>? networkType,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (locationId != null) 'location_id': locationId,
      if (accuracy != null) 'accuracy': accuracy,
      if (speed != null) 'speed': speed,
      if (batteryImpact != null) 'battery_impact': batteryImpact,
      if (networkType != null) 'network_type': networkType,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LocationAnalyticsCompanion copyWith({
    Value<String>? id,
    Value<String?>? userId,
    Value<String?>? locationId,
    Value<double?>? accuracy,
    Value<double?>? speed,
    Value<String?>? batteryImpact,
    Value<String?>? networkType,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return LocationAnalyticsCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      locationId: locationId ?? this.locationId,
      accuracy: accuracy ?? this.accuracy,
      speed: speed ?? this.speed,
      batteryImpact: batteryImpact ?? this.batteryImpact,
      networkType: networkType ?? this.networkType,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (locationId.present) {
      map['location_id'] = Variable<String>(locationId.value);
    }
    if (accuracy.present) {
      map['accuracy'] = Variable<double>(accuracy.value);
    }
    if (speed.present) {
      map['speed'] = Variable<double>(speed.value);
    }
    if (batteryImpact.present) {
      map['battery_impact'] = Variable<String>(batteryImpact.value);
    }
    if (networkType.present) {
      map['network_type'] = Variable<String>(networkType.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LocationAnalyticsCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('locationId: $locationId, ')
          ..write('accuracy: $accuracy, ')
          ..write('speed: $speed, ')
          ..write('batteryImpact: $batteryImpact, ')
          ..write('networkType: $networkType, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GeofencesTable extends Geofences
    with TableInfo<$GeofencesTable, Geofence> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GeofencesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _radiusMeta = const VerificationMeta('radius');
  @override
  late final GeneratedColumn<double> radius = GeneratedColumn<double>(
    'radius',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _contextMeta = const VerificationMeta(
    'context',
  );
  @override
  late final GeneratedColumn<String> context = GeneratedColumn<String>(
    'context',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isActiveMeta = const VerificationMeta(
    'isActive',
  );
  @override
  late final GeneratedColumn<bool> isActive = GeneratedColumn<bool>(
    'is_active',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_active" IN (0, 1))',
    ),
    defaultValue: const Constant(true),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    name,
    latitude,
    longitude,
    radius,
    context,
    isActive,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'geofences';
  @override
  VerificationContext validateIntegrity(
    Insertable<Geofence> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    } else if (isInserting) {
      context.missing(_latitudeMeta);
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    } else if (isInserting) {
      context.missing(_longitudeMeta);
    }
    if (data.containsKey('radius')) {
      context.handle(
        _radiusMeta,
        radius.isAcceptableOrUnknown(data['radius']!, _radiusMeta),
      );
    } else if (isInserting) {
      context.missing(_radiusMeta);
    }
    if (data.containsKey('context')) {
      context.handle(
        _contextMeta,
        this.context.isAcceptableOrUnknown(data['context']!, _contextMeta),
      );
    }
    if (data.containsKey('is_active')) {
      context.handle(
        _isActiveMeta,
        isActive.isAcceptableOrUnknown(data['is_active']!, _isActiveMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Geofence map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Geofence(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      )!,
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      )!,
      radius: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}radius'],
      )!,
      context: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}context'],
      ),
      isActive: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_active'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $GeofencesTable createAlias(String alias) {
    return $GeofencesTable(attachedDatabase, alias);
  }
}

class Geofence extends DataClass implements Insertable<Geofence> {
  final String id;
  final String userId;
  final String name;
  final double latitude;
  final double longitude;
  final double radius;
  final String? context;
  final bool isActive;
  final DateTime createdAt;
  final DateTime updatedAt;
  const Geofence({
    required this.id,
    required this.userId,
    required this.name,
    required this.latitude,
    required this.longitude,
    required this.radius,
    this.context,
    required this.isActive,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['name'] = Variable<String>(name);
    map['latitude'] = Variable<double>(latitude);
    map['longitude'] = Variable<double>(longitude);
    map['radius'] = Variable<double>(radius);
    if (!nullToAbsent || context != null) {
      map['context'] = Variable<String>(context);
    }
    map['is_active'] = Variable<bool>(isActive);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  GeofencesCompanion toCompanion(bool nullToAbsent) {
    return GeofencesCompanion(
      id: Value(id),
      userId: Value(userId),
      name: Value(name),
      latitude: Value(latitude),
      longitude: Value(longitude),
      radius: Value(radius),
      context: context == null && nullToAbsent
          ? const Value.absent()
          : Value(context),
      isActive: Value(isActive),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Geofence.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Geofence(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      name: serializer.fromJson<String>(json['name']),
      latitude: serializer.fromJson<double>(json['latitude']),
      longitude: serializer.fromJson<double>(json['longitude']),
      radius: serializer.fromJson<double>(json['radius']),
      context: serializer.fromJson<String?>(json['context']),
      isActive: serializer.fromJson<bool>(json['isActive']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'name': serializer.toJson<String>(name),
      'latitude': serializer.toJson<double>(latitude),
      'longitude': serializer.toJson<double>(longitude),
      'radius': serializer.toJson<double>(radius),
      'context': serializer.toJson<String?>(context),
      'isActive': serializer.toJson<bool>(isActive),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  Geofence copyWith({
    String? id,
    String? userId,
    String? name,
    double? latitude,
    double? longitude,
    double? radius,
    Value<String?> context = const Value.absent(),
    bool? isActive,
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => Geofence(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    name: name ?? this.name,
    latitude: latitude ?? this.latitude,
    longitude: longitude ?? this.longitude,
    radius: radius ?? this.radius,
    context: context.present ? context.value : this.context,
    isActive: isActive ?? this.isActive,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Geofence copyWithCompanion(GeofencesCompanion data) {
    return Geofence(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      name: data.name.present ? data.name.value : this.name,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      radius: data.radius.present ? data.radius.value : this.radius,
      context: data.context.present ? data.context.value : this.context,
      isActive: data.isActive.present ? data.isActive.value : this.isActive,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Geofence(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('name: $name, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('radius: $radius, ')
          ..write('context: $context, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    name,
    latitude,
    longitude,
    radius,
    context,
    isActive,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Geofence &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.name == this.name &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.radius == this.radius &&
          other.context == this.context &&
          other.isActive == this.isActive &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class GeofencesCompanion extends UpdateCompanion<Geofence> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String> name;
  final Value<double> latitude;
  final Value<double> longitude;
  final Value<double> radius;
  final Value<String?> context;
  final Value<bool> isActive;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const GeofencesCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.name = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.radius = const Value.absent(),
    this.context = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  GeofencesCompanion.insert({
    required String id,
    required String userId,
    required String name,
    required double latitude,
    required double longitude,
    required double radius,
    this.context = const Value.absent(),
    this.isActive = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       name = Value(name),
       latitude = Value(latitude),
       longitude = Value(longitude),
       radius = Value(radius);
  static Insertable<Geofence> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? name,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<double>? radius,
    Expression<String>? context,
    Expression<bool>? isActive,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (name != null) 'name': name,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (radius != null) 'radius': radius,
      if (context != null) 'context': context,
      if (isActive != null) 'is_active': isActive,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GeofencesCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String>? name,
    Value<double>? latitude,
    Value<double>? longitude,
    Value<double>? radius,
    Value<String?>? context,
    Value<bool>? isActive,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return GeofencesCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      name: name ?? this.name,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      radius: radius ?? this.radius,
      context: context ?? this.context,
      isActive: isActive ?? this.isActive,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (radius.present) {
      map['radius'] = Variable<double>(radius.value);
    }
    if (context.present) {
      map['context'] = Variable<String>(context.value);
    }
    if (isActive.present) {
      map['is_active'] = Variable<bool>(isActive.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GeofencesCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('name: $name, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('radius: $radius, ')
          ..write('context: $context, ')
          ..write('isActive: $isActive, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $GeofenceEventsTable extends GeofenceEvents
    with TableInfo<$GeofenceEventsTable, GeofenceEvent> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $GeofenceEventsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _geofenceIdMeta = const VerificationMeta(
    'geofenceId',
  );
  @override
  late final GeneratedColumn<String> geofenceId = GeneratedColumn<String>(
    'geofence_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES geofences (id)',
    ),
  );
  static const VerificationMeta _eventTypeMeta = const VerificationMeta(
    'eventType',
  );
  @override
  late final GeneratedColumn<String> eventType = GeneratedColumn<String>(
    'event_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _latitudeMeta = const VerificationMeta(
    'latitude',
  );
  @override
  late final GeneratedColumn<double> latitude = GeneratedColumn<double>(
    'latitude',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _longitudeMeta = const VerificationMeta(
    'longitude',
  );
  @override
  late final GeneratedColumn<double> longitude = GeneratedColumn<double>(
    'longitude',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _durationSecondsMeta = const VerificationMeta(
    'durationSeconds',
  );
  @override
  late final GeneratedColumn<int> durationSeconds = GeneratedColumn<int>(
    'duration_seconds',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    geofenceId,
    eventType,
    latitude,
    longitude,
    durationSeconds,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'geofence_events';
  @override
  VerificationContext validateIntegrity(
    Insertable<GeofenceEvent> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('geofence_id')) {
      context.handle(
        _geofenceIdMeta,
        geofenceId.isAcceptableOrUnknown(data['geofence_id']!, _geofenceIdMeta),
      );
    } else if (isInserting) {
      context.missing(_geofenceIdMeta);
    }
    if (data.containsKey('event_type')) {
      context.handle(
        _eventTypeMeta,
        eventType.isAcceptableOrUnknown(data['event_type']!, _eventTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_eventTypeMeta);
    }
    if (data.containsKey('latitude')) {
      context.handle(
        _latitudeMeta,
        latitude.isAcceptableOrUnknown(data['latitude']!, _latitudeMeta),
      );
    } else if (isInserting) {
      context.missing(_latitudeMeta);
    }
    if (data.containsKey('longitude')) {
      context.handle(
        _longitudeMeta,
        longitude.isAcceptableOrUnknown(data['longitude']!, _longitudeMeta),
      );
    } else if (isInserting) {
      context.missing(_longitudeMeta);
    }
    if (data.containsKey('duration_seconds')) {
      context.handle(
        _durationSecondsMeta,
        durationSeconds.isAcceptableOrUnknown(
          data['duration_seconds']!,
          _durationSecondsMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  GeofenceEvent map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return GeofenceEvent(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      geofenceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}geofence_id'],
      )!,
      eventType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}event_type'],
      )!,
      latitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}latitude'],
      )!,
      longitude: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}longitude'],
      )!,
      durationSeconds: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}duration_seconds'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $GeofenceEventsTable createAlias(String alias) {
    return $GeofenceEventsTable(attachedDatabase, alias);
  }
}

class GeofenceEvent extends DataClass implements Insertable<GeofenceEvent> {
  final String id;
  final String geofenceId;
  final String eventType;
  final double latitude;
  final double longitude;
  final int? durationSeconds;
  final DateTime createdAt;
  const GeofenceEvent({
    required this.id,
    required this.geofenceId,
    required this.eventType,
    required this.latitude,
    required this.longitude,
    this.durationSeconds,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['geofence_id'] = Variable<String>(geofenceId);
    map['event_type'] = Variable<String>(eventType);
    map['latitude'] = Variable<double>(latitude);
    map['longitude'] = Variable<double>(longitude);
    if (!nullToAbsent || durationSeconds != null) {
      map['duration_seconds'] = Variable<int>(durationSeconds);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  GeofenceEventsCompanion toCompanion(bool nullToAbsent) {
    return GeofenceEventsCompanion(
      id: Value(id),
      geofenceId: Value(geofenceId),
      eventType: Value(eventType),
      latitude: Value(latitude),
      longitude: Value(longitude),
      durationSeconds: durationSeconds == null && nullToAbsent
          ? const Value.absent()
          : Value(durationSeconds),
      createdAt: Value(createdAt),
    );
  }

  factory GeofenceEvent.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return GeofenceEvent(
      id: serializer.fromJson<String>(json['id']),
      geofenceId: serializer.fromJson<String>(json['geofenceId']),
      eventType: serializer.fromJson<String>(json['eventType']),
      latitude: serializer.fromJson<double>(json['latitude']),
      longitude: serializer.fromJson<double>(json['longitude']),
      durationSeconds: serializer.fromJson<int?>(json['durationSeconds']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'geofenceId': serializer.toJson<String>(geofenceId),
      'eventType': serializer.toJson<String>(eventType),
      'latitude': serializer.toJson<double>(latitude),
      'longitude': serializer.toJson<double>(longitude),
      'durationSeconds': serializer.toJson<int?>(durationSeconds),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  GeofenceEvent copyWith({
    String? id,
    String? geofenceId,
    String? eventType,
    double? latitude,
    double? longitude,
    Value<int?> durationSeconds = const Value.absent(),
    DateTime? createdAt,
  }) => GeofenceEvent(
    id: id ?? this.id,
    geofenceId: geofenceId ?? this.geofenceId,
    eventType: eventType ?? this.eventType,
    latitude: latitude ?? this.latitude,
    longitude: longitude ?? this.longitude,
    durationSeconds: durationSeconds.present
        ? durationSeconds.value
        : this.durationSeconds,
    createdAt: createdAt ?? this.createdAt,
  );
  GeofenceEvent copyWithCompanion(GeofenceEventsCompanion data) {
    return GeofenceEvent(
      id: data.id.present ? data.id.value : this.id,
      geofenceId: data.geofenceId.present
          ? data.geofenceId.value
          : this.geofenceId,
      eventType: data.eventType.present ? data.eventType.value : this.eventType,
      latitude: data.latitude.present ? data.latitude.value : this.latitude,
      longitude: data.longitude.present ? data.longitude.value : this.longitude,
      durationSeconds: data.durationSeconds.present
          ? data.durationSeconds.value
          : this.durationSeconds,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('GeofenceEvent(')
          ..write('id: $id, ')
          ..write('geofenceId: $geofenceId, ')
          ..write('eventType: $eventType, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('durationSeconds: $durationSeconds, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    geofenceId,
    eventType,
    latitude,
    longitude,
    durationSeconds,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is GeofenceEvent &&
          other.id == this.id &&
          other.geofenceId == this.geofenceId &&
          other.eventType == this.eventType &&
          other.latitude == this.latitude &&
          other.longitude == this.longitude &&
          other.durationSeconds == this.durationSeconds &&
          other.createdAt == this.createdAt);
}

class GeofenceEventsCompanion extends UpdateCompanion<GeofenceEvent> {
  final Value<String> id;
  final Value<String> geofenceId;
  final Value<String> eventType;
  final Value<double> latitude;
  final Value<double> longitude;
  final Value<int?> durationSeconds;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const GeofenceEventsCompanion({
    this.id = const Value.absent(),
    this.geofenceId = const Value.absent(),
    this.eventType = const Value.absent(),
    this.latitude = const Value.absent(),
    this.longitude = const Value.absent(),
    this.durationSeconds = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  GeofenceEventsCompanion.insert({
    required String id,
    required String geofenceId,
    required String eventType,
    required double latitude,
    required double longitude,
    this.durationSeconds = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       geofenceId = Value(geofenceId),
       eventType = Value(eventType),
       latitude = Value(latitude),
       longitude = Value(longitude);
  static Insertable<GeofenceEvent> custom({
    Expression<String>? id,
    Expression<String>? geofenceId,
    Expression<String>? eventType,
    Expression<double>? latitude,
    Expression<double>? longitude,
    Expression<int>? durationSeconds,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (geofenceId != null) 'geofence_id': geofenceId,
      if (eventType != null) 'event_type': eventType,
      if (latitude != null) 'latitude': latitude,
      if (longitude != null) 'longitude': longitude,
      if (durationSeconds != null) 'duration_seconds': durationSeconds,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  GeofenceEventsCompanion copyWith({
    Value<String>? id,
    Value<String>? geofenceId,
    Value<String>? eventType,
    Value<double>? latitude,
    Value<double>? longitude,
    Value<int?>? durationSeconds,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return GeofenceEventsCompanion(
      id: id ?? this.id,
      geofenceId: geofenceId ?? this.geofenceId,
      eventType: eventType ?? this.eventType,
      latitude: latitude ?? this.latitude,
      longitude: longitude ?? this.longitude,
      durationSeconds: durationSeconds ?? this.durationSeconds,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (geofenceId.present) {
      map['geofence_id'] = Variable<String>(geofenceId.value);
    }
    if (eventType.present) {
      map['event_type'] = Variable<String>(eventType.value);
    }
    if (latitude.present) {
      map['latitude'] = Variable<double>(latitude.value);
    }
    if (longitude.present) {
      map['longitude'] = Variable<double>(longitude.value);
    }
    if (durationSeconds.present) {
      map['duration_seconds'] = Variable<int>(durationSeconds.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('GeofenceEventsCompanion(')
          ..write('id: $id, ')
          ..write('geofenceId: $geofenceId, ')
          ..write('eventType: $eventType, ')
          ..write('latitude: $latitude, ')
          ..write('longitude: $longitude, ')
          ..write('durationSeconds: $durationSeconds, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ConflictsTable extends Conflicts
    with TableInfo<$ConflictsTable, ConflictData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ConflictsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityIdMeta = const VerificationMeta(
    'entityId',
  );
  @override
  late final GeneratedColumn<String> entityId = GeneratedColumn<String>(
    'entity_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('open'),
  );
  static const VerificationMeta _localJsonMeta = const VerificationMeta(
    'localJson',
  );
  @override
  late final GeneratedColumn<String> localJson = GeneratedColumn<String>(
    'local_json',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _remoteJsonMeta = const VerificationMeta(
    'remoteJson',
  );
  @override
  late final GeneratedColumn<String> remoteJson = GeneratedColumn<String>(
    'remote_json',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _diffJsonMeta = const VerificationMeta(
    'diffJson',
  );
  @override
  late final GeneratedColumn<String> diffJson = GeneratedColumn<String>(
    'diff_json',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _resolutionTypeMeta = const VerificationMeta(
    'resolutionType',
  );
  @override
  late final GeneratedColumn<String> resolutionType = GeneratedColumn<String>(
    'resolution_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('pending'),
  );
  static const VerificationMeta _resolvedAtMeta = const VerificationMeta(
    'resolvedAt',
  );
  @override
  late final GeneratedColumn<DateTime> resolvedAt = GeneratedColumn<DateTime>(
    'resolved_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _detectedByDeviceIdMeta =
      const VerificationMeta('detectedByDeviceId');
  @override
  late final GeneratedColumn<String> detectedByDeviceId =
      GeneratedColumn<String>(
        'detected_by_device_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    entityType,
    entityId,
    createdAt,
    status,
    localJson,
    remoteJson,
    diffJson,
    resolutionType,
    resolvedAt,
    detectedByDeviceId,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'conflicts';
  @override
  VerificationContext validateIntegrity(
    Insertable<ConflictData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('entity_id')) {
      context.handle(
        _entityIdMeta,
        entityId.isAcceptableOrUnknown(data['entity_id']!, _entityIdMeta),
      );
    } else if (isInserting) {
      context.missing(_entityIdMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('local_json')) {
      context.handle(
        _localJsonMeta,
        localJson.isAcceptableOrUnknown(data['local_json']!, _localJsonMeta),
      );
    } else if (isInserting) {
      context.missing(_localJsonMeta);
    }
    if (data.containsKey('remote_json')) {
      context.handle(
        _remoteJsonMeta,
        remoteJson.isAcceptableOrUnknown(data['remote_json']!, _remoteJsonMeta),
      );
    } else if (isInserting) {
      context.missing(_remoteJsonMeta);
    }
    if (data.containsKey('diff_json')) {
      context.handle(
        _diffJsonMeta,
        diffJson.isAcceptableOrUnknown(data['diff_json']!, _diffJsonMeta),
      );
    }
    if (data.containsKey('resolution_type')) {
      context.handle(
        _resolutionTypeMeta,
        resolutionType.isAcceptableOrUnknown(
          data['resolution_type']!,
          _resolutionTypeMeta,
        ),
      );
    }
    if (data.containsKey('resolved_at')) {
      context.handle(
        _resolvedAtMeta,
        resolvedAt.isAcceptableOrUnknown(data['resolved_at']!, _resolvedAtMeta),
      );
    }
    if (data.containsKey('detected_by_device_id')) {
      context.handle(
        _detectedByDeviceIdMeta,
        detectedByDeviceId.isAcceptableOrUnknown(
          data['detected_by_device_id']!,
          _detectedByDeviceIdMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ConflictData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ConflictData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      entityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_id'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      localJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}local_json'],
      )!,
      remoteJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}remote_json'],
      )!,
      diffJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}diff_json'],
      ),
      resolutionType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}resolution_type'],
      )!,
      resolvedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}resolved_at'],
      ),
      detectedByDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}detected_by_device_id'],
      ),
    );
  }

  @override
  $ConflictsTable createAlias(String alias) {
    return $ConflictsTable(attachedDatabase, alias);
  }
}

class ConflictData extends DataClass implements Insertable<ConflictData> {
  /// Unique conflict ID
  final String id;

  /// Type of entity: expense, budget, account, category, recurring
  final String entityType;

  /// ID of the conflicting entity
  final String entityId;

  /// When the conflict was detected
  final DateTime createdAt;

  /// Status: open, resolved
  final String status;

  /// Local version as JSON
  final String localJson;

  /// Remote version as JSON
  final String remoteJson;

  /// Precomputed diff as JSON (optional)
  final String? diffJson;

  /// Resolution type: pending, keepLocal, keepRemote, merge, duplicate
  final String resolutionType;

  /// When the conflict was resolved
  final DateTime? resolvedAt;

  /// Device ID that detected the conflict
  final String? detectedByDeviceId;
  const ConflictData({
    required this.id,
    required this.entityType,
    required this.entityId,
    required this.createdAt,
    required this.status,
    required this.localJson,
    required this.remoteJson,
    this.diffJson,
    required this.resolutionType,
    this.resolvedAt,
    this.detectedByDeviceId,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['entity_type'] = Variable<String>(entityType);
    map['entity_id'] = Variable<String>(entityId);
    map['created_at'] = Variable<DateTime>(createdAt);
    map['status'] = Variable<String>(status);
    map['local_json'] = Variable<String>(localJson);
    map['remote_json'] = Variable<String>(remoteJson);
    if (!nullToAbsent || diffJson != null) {
      map['diff_json'] = Variable<String>(diffJson);
    }
    map['resolution_type'] = Variable<String>(resolutionType);
    if (!nullToAbsent || resolvedAt != null) {
      map['resolved_at'] = Variable<DateTime>(resolvedAt);
    }
    if (!nullToAbsent || detectedByDeviceId != null) {
      map['detected_by_device_id'] = Variable<String>(detectedByDeviceId);
    }
    return map;
  }

  ConflictsCompanion toCompanion(bool nullToAbsent) {
    return ConflictsCompanion(
      id: Value(id),
      entityType: Value(entityType),
      entityId: Value(entityId),
      createdAt: Value(createdAt),
      status: Value(status),
      localJson: Value(localJson),
      remoteJson: Value(remoteJson),
      diffJson: diffJson == null && nullToAbsent
          ? const Value.absent()
          : Value(diffJson),
      resolutionType: Value(resolutionType),
      resolvedAt: resolvedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(resolvedAt),
      detectedByDeviceId: detectedByDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(detectedByDeviceId),
    );
  }

  factory ConflictData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ConflictData(
      id: serializer.fromJson<String>(json['id']),
      entityType: serializer.fromJson<String>(json['entityType']),
      entityId: serializer.fromJson<String>(json['entityId']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      status: serializer.fromJson<String>(json['status']),
      localJson: serializer.fromJson<String>(json['localJson']),
      remoteJson: serializer.fromJson<String>(json['remoteJson']),
      diffJson: serializer.fromJson<String?>(json['diffJson']),
      resolutionType: serializer.fromJson<String>(json['resolutionType']),
      resolvedAt: serializer.fromJson<DateTime?>(json['resolvedAt']),
      detectedByDeviceId: serializer.fromJson<String?>(
        json['detectedByDeviceId'],
      ),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'entityType': serializer.toJson<String>(entityType),
      'entityId': serializer.toJson<String>(entityId),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'status': serializer.toJson<String>(status),
      'localJson': serializer.toJson<String>(localJson),
      'remoteJson': serializer.toJson<String>(remoteJson),
      'diffJson': serializer.toJson<String?>(diffJson),
      'resolutionType': serializer.toJson<String>(resolutionType),
      'resolvedAt': serializer.toJson<DateTime?>(resolvedAt),
      'detectedByDeviceId': serializer.toJson<String?>(detectedByDeviceId),
    };
  }

  ConflictData copyWith({
    String? id,
    String? entityType,
    String? entityId,
    DateTime? createdAt,
    String? status,
    String? localJson,
    String? remoteJson,
    Value<String?> diffJson = const Value.absent(),
    String? resolutionType,
    Value<DateTime?> resolvedAt = const Value.absent(),
    Value<String?> detectedByDeviceId = const Value.absent(),
  }) => ConflictData(
    id: id ?? this.id,
    entityType: entityType ?? this.entityType,
    entityId: entityId ?? this.entityId,
    createdAt: createdAt ?? this.createdAt,
    status: status ?? this.status,
    localJson: localJson ?? this.localJson,
    remoteJson: remoteJson ?? this.remoteJson,
    diffJson: diffJson.present ? diffJson.value : this.diffJson,
    resolutionType: resolutionType ?? this.resolutionType,
    resolvedAt: resolvedAt.present ? resolvedAt.value : this.resolvedAt,
    detectedByDeviceId: detectedByDeviceId.present
        ? detectedByDeviceId.value
        : this.detectedByDeviceId,
  );
  ConflictData copyWithCompanion(ConflictsCompanion data) {
    return ConflictData(
      id: data.id.present ? data.id.value : this.id,
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      entityId: data.entityId.present ? data.entityId.value : this.entityId,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      status: data.status.present ? data.status.value : this.status,
      localJson: data.localJson.present ? data.localJson.value : this.localJson,
      remoteJson: data.remoteJson.present
          ? data.remoteJson.value
          : this.remoteJson,
      diffJson: data.diffJson.present ? data.diffJson.value : this.diffJson,
      resolutionType: data.resolutionType.present
          ? data.resolutionType.value
          : this.resolutionType,
      resolvedAt: data.resolvedAt.present
          ? data.resolvedAt.value
          : this.resolvedAt,
      detectedByDeviceId: data.detectedByDeviceId.present
          ? data.detectedByDeviceId.value
          : this.detectedByDeviceId,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ConflictData(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('createdAt: $createdAt, ')
          ..write('status: $status, ')
          ..write('localJson: $localJson, ')
          ..write('remoteJson: $remoteJson, ')
          ..write('diffJson: $diffJson, ')
          ..write('resolutionType: $resolutionType, ')
          ..write('resolvedAt: $resolvedAt, ')
          ..write('detectedByDeviceId: $detectedByDeviceId')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    entityType,
    entityId,
    createdAt,
    status,
    localJson,
    remoteJson,
    diffJson,
    resolutionType,
    resolvedAt,
    detectedByDeviceId,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ConflictData &&
          other.id == this.id &&
          other.entityType == this.entityType &&
          other.entityId == this.entityId &&
          other.createdAt == this.createdAt &&
          other.status == this.status &&
          other.localJson == this.localJson &&
          other.remoteJson == this.remoteJson &&
          other.diffJson == this.diffJson &&
          other.resolutionType == this.resolutionType &&
          other.resolvedAt == this.resolvedAt &&
          other.detectedByDeviceId == this.detectedByDeviceId);
}

class ConflictsCompanion extends UpdateCompanion<ConflictData> {
  final Value<String> id;
  final Value<String> entityType;
  final Value<String> entityId;
  final Value<DateTime> createdAt;
  final Value<String> status;
  final Value<String> localJson;
  final Value<String> remoteJson;
  final Value<String?> diffJson;
  final Value<String> resolutionType;
  final Value<DateTime?> resolvedAt;
  final Value<String?> detectedByDeviceId;
  final Value<int> rowid;
  const ConflictsCompanion({
    this.id = const Value.absent(),
    this.entityType = const Value.absent(),
    this.entityId = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.status = const Value.absent(),
    this.localJson = const Value.absent(),
    this.remoteJson = const Value.absent(),
    this.diffJson = const Value.absent(),
    this.resolutionType = const Value.absent(),
    this.resolvedAt = const Value.absent(),
    this.detectedByDeviceId = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ConflictsCompanion.insert({
    required String id,
    required String entityType,
    required String entityId,
    this.createdAt = const Value.absent(),
    this.status = const Value.absent(),
    required String localJson,
    required String remoteJson,
    this.diffJson = const Value.absent(),
    this.resolutionType = const Value.absent(),
    this.resolvedAt = const Value.absent(),
    this.detectedByDeviceId = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       entityType = Value(entityType),
       entityId = Value(entityId),
       localJson = Value(localJson),
       remoteJson = Value(remoteJson);
  static Insertable<ConflictData> custom({
    Expression<String>? id,
    Expression<String>? entityType,
    Expression<String>? entityId,
    Expression<DateTime>? createdAt,
    Expression<String>? status,
    Expression<String>? localJson,
    Expression<String>? remoteJson,
    Expression<String>? diffJson,
    Expression<String>? resolutionType,
    Expression<DateTime>? resolvedAt,
    Expression<String>? detectedByDeviceId,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (entityType != null) 'entity_type': entityType,
      if (entityId != null) 'entity_id': entityId,
      if (createdAt != null) 'created_at': createdAt,
      if (status != null) 'status': status,
      if (localJson != null) 'local_json': localJson,
      if (remoteJson != null) 'remote_json': remoteJson,
      if (diffJson != null) 'diff_json': diffJson,
      if (resolutionType != null) 'resolution_type': resolutionType,
      if (resolvedAt != null) 'resolved_at': resolvedAt,
      if (detectedByDeviceId != null)
        'detected_by_device_id': detectedByDeviceId,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ConflictsCompanion copyWith({
    Value<String>? id,
    Value<String>? entityType,
    Value<String>? entityId,
    Value<DateTime>? createdAt,
    Value<String>? status,
    Value<String>? localJson,
    Value<String>? remoteJson,
    Value<String?>? diffJson,
    Value<String>? resolutionType,
    Value<DateTime?>? resolvedAt,
    Value<String?>? detectedByDeviceId,
    Value<int>? rowid,
  }) {
    return ConflictsCompanion(
      id: id ?? this.id,
      entityType: entityType ?? this.entityType,
      entityId: entityId ?? this.entityId,
      createdAt: createdAt ?? this.createdAt,
      status: status ?? this.status,
      localJson: localJson ?? this.localJson,
      remoteJson: remoteJson ?? this.remoteJson,
      diffJson: diffJson ?? this.diffJson,
      resolutionType: resolutionType ?? this.resolutionType,
      resolvedAt: resolvedAt ?? this.resolvedAt,
      detectedByDeviceId: detectedByDeviceId ?? this.detectedByDeviceId,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (entityId.present) {
      map['entity_id'] = Variable<String>(entityId.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (localJson.present) {
      map['local_json'] = Variable<String>(localJson.value);
    }
    if (remoteJson.present) {
      map['remote_json'] = Variable<String>(remoteJson.value);
    }
    if (diffJson.present) {
      map['diff_json'] = Variable<String>(diffJson.value);
    }
    if (resolutionType.present) {
      map['resolution_type'] = Variable<String>(resolutionType.value);
    }
    if (resolvedAt.present) {
      map['resolved_at'] = Variable<DateTime>(resolvedAt.value);
    }
    if (detectedByDeviceId.present) {
      map['detected_by_device_id'] = Variable<String>(detectedByDeviceId.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ConflictsCompanion(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('createdAt: $createdAt, ')
          ..write('status: $status, ')
          ..write('localJson: $localJson, ')
          ..write('remoteJson: $remoteJson, ')
          ..write('diffJson: $diffJson, ')
          ..write('resolutionType: $resolutionType, ')
          ..write('resolvedAt: $resolvedAt, ')
          ..write('detectedByDeviceId: $detectedByDeviceId, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AuditEventsTable extends AuditEvents
    with TableInfo<$AuditEventsTable, AuditEvent> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AuditEventsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _eventTypeMeta = const VerificationMeta(
    'eventType',
  );
  @override
  late final GeneratedColumn<String> eventType = GeneratedColumn<String>(
    'event_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _actorDeviceIdMeta = const VerificationMeta(
    'actorDeviceId',
  );
  @override
  late final GeneratedColumn<String> actorDeviceId = GeneratedColumn<String>(
    'actor_device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _summaryMeta = const VerificationMeta(
    'summary',
  );
  @override
  late final GeneratedColumn<String> summary = GeneratedColumn<String>(
    'summary',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _detailsJsonMeta = const VerificationMeta(
    'detailsJson',
  );
  @override
  late final GeneratedColumn<String> detailsJson = GeneratedColumn<String>(
    'details_json',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _correlationIdMeta = const VerificationMeta(
    'correlationId',
  );
  @override
  late final GeneratedColumn<String> correlationId = GeneratedColumn<String>(
    'correlation_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _severityMeta = const VerificationMeta(
    'severity',
  );
  @override
  late final GeneratedColumn<String> severity = GeneratedColumn<String>(
    'severity',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('info'),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    eventType,
    createdAt,
    actorDeviceId,
    summary,
    detailsJson,
    correlationId,
    severity,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'audit_events';
  @override
  VerificationContext validateIntegrity(
    Insertable<AuditEvent> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('event_type')) {
      context.handle(
        _eventTypeMeta,
        eventType.isAcceptableOrUnknown(data['event_type']!, _eventTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_eventTypeMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('actor_device_id')) {
      context.handle(
        _actorDeviceIdMeta,
        actorDeviceId.isAcceptableOrUnknown(
          data['actor_device_id']!,
          _actorDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('summary')) {
      context.handle(
        _summaryMeta,
        summary.isAcceptableOrUnknown(data['summary']!, _summaryMeta),
      );
    } else if (isInserting) {
      context.missing(_summaryMeta);
    }
    if (data.containsKey('details_json')) {
      context.handle(
        _detailsJsonMeta,
        detailsJson.isAcceptableOrUnknown(
          data['details_json']!,
          _detailsJsonMeta,
        ),
      );
    }
    if (data.containsKey('correlation_id')) {
      context.handle(
        _correlationIdMeta,
        correlationId.isAcceptableOrUnknown(
          data['correlation_id']!,
          _correlationIdMeta,
        ),
      );
    }
    if (data.containsKey('severity')) {
      context.handle(
        _severityMeta,
        severity.isAcceptableOrUnknown(data['severity']!, _severityMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  AuditEvent map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return AuditEvent(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      eventType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}event_type'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      actorDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}actor_device_id'],
      ),
      summary: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}summary'],
      )!,
      detailsJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}details_json'],
      ),
      correlationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}correlation_id'],
      ),
      severity: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}severity'],
      )!,
    );
  }

  @override
  $AuditEventsTable createAlias(String alias) {
    return $AuditEventsTable(attachedDatabase, alias);
  }
}

class AuditEvent extends DataClass implements Insertable<AuditEvent> {
  final String id;

  /// Event type: currency_migration, restore, conflict_resolve, backup, delete
  final String eventType;

  /// When the event occurred
  final DateTime createdAt;

  /// Device that performed the action
  final String? actorDeviceId;

  /// Brief summary
  final String summary;

  /// Detailed JSON (before/after, counts, etc.)
  final String? detailsJson;

  /// P0 OBSERVABILITY: Link events across services
  final String? correlationId;

  /// Severity for telemetry filtering: info, warning, critical, security
  final String severity;
  const AuditEvent({
    required this.id,
    required this.eventType,
    required this.createdAt,
    this.actorDeviceId,
    required this.summary,
    this.detailsJson,
    this.correlationId,
    required this.severity,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['event_type'] = Variable<String>(eventType);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || actorDeviceId != null) {
      map['actor_device_id'] = Variable<String>(actorDeviceId);
    }
    map['summary'] = Variable<String>(summary);
    if (!nullToAbsent || detailsJson != null) {
      map['details_json'] = Variable<String>(detailsJson);
    }
    if (!nullToAbsent || correlationId != null) {
      map['correlation_id'] = Variable<String>(correlationId);
    }
    map['severity'] = Variable<String>(severity);
    return map;
  }

  AuditEventsCompanion toCompanion(bool nullToAbsent) {
    return AuditEventsCompanion(
      id: Value(id),
      eventType: Value(eventType),
      createdAt: Value(createdAt),
      actorDeviceId: actorDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(actorDeviceId),
      summary: Value(summary),
      detailsJson: detailsJson == null && nullToAbsent
          ? const Value.absent()
          : Value(detailsJson),
      correlationId: correlationId == null && nullToAbsent
          ? const Value.absent()
          : Value(correlationId),
      severity: Value(severity),
    );
  }

  factory AuditEvent.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return AuditEvent(
      id: serializer.fromJson<String>(json['id']),
      eventType: serializer.fromJson<String>(json['eventType']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      actorDeviceId: serializer.fromJson<String?>(json['actorDeviceId']),
      summary: serializer.fromJson<String>(json['summary']),
      detailsJson: serializer.fromJson<String?>(json['detailsJson']),
      correlationId: serializer.fromJson<String?>(json['correlationId']),
      severity: serializer.fromJson<String>(json['severity']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'eventType': serializer.toJson<String>(eventType),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'actorDeviceId': serializer.toJson<String?>(actorDeviceId),
      'summary': serializer.toJson<String>(summary),
      'detailsJson': serializer.toJson<String?>(detailsJson),
      'correlationId': serializer.toJson<String?>(correlationId),
      'severity': serializer.toJson<String>(severity),
    };
  }

  AuditEvent copyWith({
    String? id,
    String? eventType,
    DateTime? createdAt,
    Value<String?> actorDeviceId = const Value.absent(),
    String? summary,
    Value<String?> detailsJson = const Value.absent(),
    Value<String?> correlationId = const Value.absent(),
    String? severity,
  }) => AuditEvent(
    id: id ?? this.id,
    eventType: eventType ?? this.eventType,
    createdAt: createdAt ?? this.createdAt,
    actorDeviceId: actorDeviceId.present
        ? actorDeviceId.value
        : this.actorDeviceId,
    summary: summary ?? this.summary,
    detailsJson: detailsJson.present ? detailsJson.value : this.detailsJson,
    correlationId: correlationId.present
        ? correlationId.value
        : this.correlationId,
    severity: severity ?? this.severity,
  );
  AuditEvent copyWithCompanion(AuditEventsCompanion data) {
    return AuditEvent(
      id: data.id.present ? data.id.value : this.id,
      eventType: data.eventType.present ? data.eventType.value : this.eventType,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      actorDeviceId: data.actorDeviceId.present
          ? data.actorDeviceId.value
          : this.actorDeviceId,
      summary: data.summary.present ? data.summary.value : this.summary,
      detailsJson: data.detailsJson.present
          ? data.detailsJson.value
          : this.detailsJson,
      correlationId: data.correlationId.present
          ? data.correlationId.value
          : this.correlationId,
      severity: data.severity.present ? data.severity.value : this.severity,
    );
  }

  @override
  String toString() {
    return (StringBuffer('AuditEvent(')
          ..write('id: $id, ')
          ..write('eventType: $eventType, ')
          ..write('createdAt: $createdAt, ')
          ..write('actorDeviceId: $actorDeviceId, ')
          ..write('summary: $summary, ')
          ..write('detailsJson: $detailsJson, ')
          ..write('correlationId: $correlationId, ')
          ..write('severity: $severity')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    eventType,
    createdAt,
    actorDeviceId,
    summary,
    detailsJson,
    correlationId,
    severity,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is AuditEvent &&
          other.id == this.id &&
          other.eventType == this.eventType &&
          other.createdAt == this.createdAt &&
          other.actorDeviceId == this.actorDeviceId &&
          other.summary == this.summary &&
          other.detailsJson == this.detailsJson &&
          other.correlationId == this.correlationId &&
          other.severity == this.severity);
}

class AuditEventsCompanion extends UpdateCompanion<AuditEvent> {
  final Value<String> id;
  final Value<String> eventType;
  final Value<DateTime> createdAt;
  final Value<String?> actorDeviceId;
  final Value<String> summary;
  final Value<String?> detailsJson;
  final Value<String?> correlationId;
  final Value<String> severity;
  final Value<int> rowid;
  const AuditEventsCompanion({
    this.id = const Value.absent(),
    this.eventType = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.actorDeviceId = const Value.absent(),
    this.summary = const Value.absent(),
    this.detailsJson = const Value.absent(),
    this.correlationId = const Value.absent(),
    this.severity = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AuditEventsCompanion.insert({
    required String id,
    required String eventType,
    this.createdAt = const Value.absent(),
    this.actorDeviceId = const Value.absent(),
    required String summary,
    this.detailsJson = const Value.absent(),
    this.correlationId = const Value.absent(),
    this.severity = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       eventType = Value(eventType),
       summary = Value(summary);
  static Insertable<AuditEvent> custom({
    Expression<String>? id,
    Expression<String>? eventType,
    Expression<DateTime>? createdAt,
    Expression<String>? actorDeviceId,
    Expression<String>? summary,
    Expression<String>? detailsJson,
    Expression<String>? correlationId,
    Expression<String>? severity,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (eventType != null) 'event_type': eventType,
      if (createdAt != null) 'created_at': createdAt,
      if (actorDeviceId != null) 'actor_device_id': actorDeviceId,
      if (summary != null) 'summary': summary,
      if (detailsJson != null) 'details_json': detailsJson,
      if (correlationId != null) 'correlation_id': correlationId,
      if (severity != null) 'severity': severity,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AuditEventsCompanion copyWith({
    Value<String>? id,
    Value<String>? eventType,
    Value<DateTime>? createdAt,
    Value<String?>? actorDeviceId,
    Value<String>? summary,
    Value<String?>? detailsJson,
    Value<String?>? correlationId,
    Value<String>? severity,
    Value<int>? rowid,
  }) {
    return AuditEventsCompanion(
      id: id ?? this.id,
      eventType: eventType ?? this.eventType,
      createdAt: createdAt ?? this.createdAt,
      actorDeviceId: actorDeviceId ?? this.actorDeviceId,
      summary: summary ?? this.summary,
      detailsJson: detailsJson ?? this.detailsJson,
      correlationId: correlationId ?? this.correlationId,
      severity: severity ?? this.severity,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (eventType.present) {
      map['event_type'] = Variable<String>(eventType.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (actorDeviceId.present) {
      map['actor_device_id'] = Variable<String>(actorDeviceId.value);
    }
    if (summary.present) {
      map['summary'] = Variable<String>(summary.value);
    }
    if (detailsJson.present) {
      map['details_json'] = Variable<String>(detailsJson.value);
    }
    if (correlationId.present) {
      map['correlation_id'] = Variable<String>(correlationId.value);
    }
    if (severity.present) {
      map['severity'] = Variable<String>(severity.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AuditEventsCompanion(')
          ..write('id: $id, ')
          ..write('eventType: $eventType, ')
          ..write('createdAt: $createdAt, ')
          ..write('actorDeviceId: $actorDeviceId, ')
          ..write('summary: $summary, ')
          ..write('detailsJson: $detailsJson, ')
          ..write('correlationId: $correlationId, ')
          ..write('severity: $severity, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $OutboxEventsTable extends OutboxEvents
    with TableInfo<$OutboxEventsTable, OutboxEvent> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $OutboxEventsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityIdMeta = const VerificationMeta(
    'entityId',
  );
  @override
  late final GeneratedColumn<String> entityId = GeneratedColumn<String>(
    'entity_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _operationMeta = const VerificationMeta(
    'operation',
  );
  @override
  late final GeneratedColumn<String> operation = GeneratedColumn<String>(
    'operation',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _payloadMeta = const VerificationMeta(
    'payload',
  );
  @override
  late final GeneratedColumn<String> payload = GeneratedColumn<String>(
    'payload',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _baseRevisionMeta = const VerificationMeta(
    'baseRevision',
  );
  @override
  late final GeneratedColumn<int> baseRevision = GeneratedColumn<int>(
    'base_revision',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _processedAtMeta = const VerificationMeta(
    'processedAt',
  );
  @override
  late final GeneratedColumn<DateTime> processedAt = GeneratedColumn<DateTime>(
    'processed_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('pending'),
  );
  static const VerificationMeta _errorMessageMeta = const VerificationMeta(
    'errorMessage',
  );
  @override
  late final GeneratedColumn<String> errorMessage = GeneratedColumn<String>(
    'error_message',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _retryCountMeta = const VerificationMeta(
    'retryCount',
  );
  @override
  late final GeneratedColumn<int> retryCount = GeneratedColumn<int>(
    'retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _priorityMeta = const VerificationMeta(
    'priority',
  );
  @override
  late final GeneratedColumn<int> priority = GeneratedColumn<int>(
    'priority',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _permissionEpochAtEditMeta =
      const VerificationMeta('permissionEpochAtEdit');
  @override
  late final GeneratedColumn<int> permissionEpochAtEdit = GeneratedColumn<int>(
    'permission_epoch_at_edit',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastRetryAtMeta = const VerificationMeta(
    'lastRetryAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastRetryAt = GeneratedColumn<DateTime>(
    'last_retry_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _maxRetriesMeta = const VerificationMeta(
    'maxRetries',
  );
  @override
  late final GeneratedColumn<int> maxRetries = GeneratedColumn<int>(
    'max_retries',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(5),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    entityType,
    entityId,
    operation,
    payload,
    baseRevision,
    createdAt,
    processedAt,
    status,
    errorMessage,
    retryCount,
    priority,
    permissionEpochAtEdit,
    lastRetryAt,
    maxRetries,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'outbox_events';
  @override
  VerificationContext validateIntegrity(
    Insertable<OutboxEvent> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('entity_id')) {
      context.handle(
        _entityIdMeta,
        entityId.isAcceptableOrUnknown(data['entity_id']!, _entityIdMeta),
      );
    } else if (isInserting) {
      context.missing(_entityIdMeta);
    }
    if (data.containsKey('operation')) {
      context.handle(
        _operationMeta,
        operation.isAcceptableOrUnknown(data['operation']!, _operationMeta),
      );
    } else if (isInserting) {
      context.missing(_operationMeta);
    }
    if (data.containsKey('payload')) {
      context.handle(
        _payloadMeta,
        payload.isAcceptableOrUnknown(data['payload']!, _payloadMeta),
      );
    } else if (isInserting) {
      context.missing(_payloadMeta);
    }
    if (data.containsKey('base_revision')) {
      context.handle(
        _baseRevisionMeta,
        baseRevision.isAcceptableOrUnknown(
          data['base_revision']!,
          _baseRevisionMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('processed_at')) {
      context.handle(
        _processedAtMeta,
        processedAt.isAcceptableOrUnknown(
          data['processed_at']!,
          _processedAtMeta,
        ),
      );
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('error_message')) {
      context.handle(
        _errorMessageMeta,
        errorMessage.isAcceptableOrUnknown(
          data['error_message']!,
          _errorMessageMeta,
        ),
      );
    }
    if (data.containsKey('retry_count')) {
      context.handle(
        _retryCountMeta,
        retryCount.isAcceptableOrUnknown(data['retry_count']!, _retryCountMeta),
      );
    }
    if (data.containsKey('priority')) {
      context.handle(
        _priorityMeta,
        priority.isAcceptableOrUnknown(data['priority']!, _priorityMeta),
      );
    }
    if (data.containsKey('permission_epoch_at_edit')) {
      context.handle(
        _permissionEpochAtEditMeta,
        permissionEpochAtEdit.isAcceptableOrUnknown(
          data['permission_epoch_at_edit']!,
          _permissionEpochAtEditMeta,
        ),
      );
    }
    if (data.containsKey('last_retry_at')) {
      context.handle(
        _lastRetryAtMeta,
        lastRetryAt.isAcceptableOrUnknown(
          data['last_retry_at']!,
          _lastRetryAtMeta,
        ),
      );
    }
    if (data.containsKey('max_retries')) {
      context.handle(
        _maxRetriesMeta,
        maxRetries.isAcceptableOrUnknown(data['max_retries']!, _maxRetriesMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  OutboxEvent map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return OutboxEvent(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      entityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_id'],
      )!,
      operation: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation'],
      )!,
      payload: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payload'],
      )!,
      baseRevision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}base_revision'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      processedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}processed_at'],
      ),
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      errorMessage: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}error_message'],
      ),
      retryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}retry_count'],
      )!,
      priority: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}priority'],
      )!,
      permissionEpochAtEdit: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}permission_epoch_at_edit'],
      ),
      lastRetryAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_retry_at'],
      ),
      maxRetries: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}max_retries'],
      )!,
    );
  }

  @override
  $OutboxEventsTable createAlias(String alias) {
    return $OutboxEventsTable(attachedDatabase, alias);
  }
}

class OutboxEvent extends DataClass implements Insertable<OutboxEvent> {
  final String id;
  final String entityType;
  final String entityId;
  final String operation;
  final String payload;
  final int? baseRevision;
  final DateTime createdAt;
  final DateTime? processedAt;
  final String status;
  final String? errorMessage;
  final int retryCount;
  final int priority;
  final int? permissionEpochAtEdit;
  final DateTime? lastRetryAt;
  final int maxRetries;
  const OutboxEvent({
    required this.id,
    required this.entityType,
    required this.entityId,
    required this.operation,
    required this.payload,
    this.baseRevision,
    required this.createdAt,
    this.processedAt,
    required this.status,
    this.errorMessage,
    required this.retryCount,
    required this.priority,
    this.permissionEpochAtEdit,
    this.lastRetryAt,
    required this.maxRetries,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['entity_type'] = Variable<String>(entityType);
    map['entity_id'] = Variable<String>(entityId);
    map['operation'] = Variable<String>(operation);
    map['payload'] = Variable<String>(payload);
    if (!nullToAbsent || baseRevision != null) {
      map['base_revision'] = Variable<int>(baseRevision);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || processedAt != null) {
      map['processed_at'] = Variable<DateTime>(processedAt);
    }
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || errorMessage != null) {
      map['error_message'] = Variable<String>(errorMessage);
    }
    map['retry_count'] = Variable<int>(retryCount);
    map['priority'] = Variable<int>(priority);
    if (!nullToAbsent || permissionEpochAtEdit != null) {
      map['permission_epoch_at_edit'] = Variable<int>(permissionEpochAtEdit);
    }
    if (!nullToAbsent || lastRetryAt != null) {
      map['last_retry_at'] = Variable<DateTime>(lastRetryAt);
    }
    map['max_retries'] = Variable<int>(maxRetries);
    return map;
  }

  OutboxEventsCompanion toCompanion(bool nullToAbsent) {
    return OutboxEventsCompanion(
      id: Value(id),
      entityType: Value(entityType),
      entityId: Value(entityId),
      operation: Value(operation),
      payload: Value(payload),
      baseRevision: baseRevision == null && nullToAbsent
          ? const Value.absent()
          : Value(baseRevision),
      createdAt: Value(createdAt),
      processedAt: processedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(processedAt),
      status: Value(status),
      errorMessage: errorMessage == null && nullToAbsent
          ? const Value.absent()
          : Value(errorMessage),
      retryCount: Value(retryCount),
      priority: Value(priority),
      permissionEpochAtEdit: permissionEpochAtEdit == null && nullToAbsent
          ? const Value.absent()
          : Value(permissionEpochAtEdit),
      lastRetryAt: lastRetryAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastRetryAt),
      maxRetries: Value(maxRetries),
    );
  }

  factory OutboxEvent.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return OutboxEvent(
      id: serializer.fromJson<String>(json['id']),
      entityType: serializer.fromJson<String>(json['entityType']),
      entityId: serializer.fromJson<String>(json['entityId']),
      operation: serializer.fromJson<String>(json['operation']),
      payload: serializer.fromJson<String>(json['payload']),
      baseRevision: serializer.fromJson<int?>(json['baseRevision']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      processedAt: serializer.fromJson<DateTime?>(json['processedAt']),
      status: serializer.fromJson<String>(json['status']),
      errorMessage: serializer.fromJson<String?>(json['errorMessage']),
      retryCount: serializer.fromJson<int>(json['retryCount']),
      priority: serializer.fromJson<int>(json['priority']),
      permissionEpochAtEdit: serializer.fromJson<int?>(
        json['permissionEpochAtEdit'],
      ),
      lastRetryAt: serializer.fromJson<DateTime?>(json['lastRetryAt']),
      maxRetries: serializer.fromJson<int>(json['maxRetries']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'entityType': serializer.toJson<String>(entityType),
      'entityId': serializer.toJson<String>(entityId),
      'operation': serializer.toJson<String>(operation),
      'payload': serializer.toJson<String>(payload),
      'baseRevision': serializer.toJson<int?>(baseRevision),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'processedAt': serializer.toJson<DateTime?>(processedAt),
      'status': serializer.toJson<String>(status),
      'errorMessage': serializer.toJson<String?>(errorMessage),
      'retryCount': serializer.toJson<int>(retryCount),
      'priority': serializer.toJson<int>(priority),
      'permissionEpochAtEdit': serializer.toJson<int?>(permissionEpochAtEdit),
      'lastRetryAt': serializer.toJson<DateTime?>(lastRetryAt),
      'maxRetries': serializer.toJson<int>(maxRetries),
    };
  }

  OutboxEvent copyWith({
    String? id,
    String? entityType,
    String? entityId,
    String? operation,
    String? payload,
    Value<int?> baseRevision = const Value.absent(),
    DateTime? createdAt,
    Value<DateTime?> processedAt = const Value.absent(),
    String? status,
    Value<String?> errorMessage = const Value.absent(),
    int? retryCount,
    int? priority,
    Value<int?> permissionEpochAtEdit = const Value.absent(),
    Value<DateTime?> lastRetryAt = const Value.absent(),
    int? maxRetries,
  }) => OutboxEvent(
    id: id ?? this.id,
    entityType: entityType ?? this.entityType,
    entityId: entityId ?? this.entityId,
    operation: operation ?? this.operation,
    payload: payload ?? this.payload,
    baseRevision: baseRevision.present ? baseRevision.value : this.baseRevision,
    createdAt: createdAt ?? this.createdAt,
    processedAt: processedAt.present ? processedAt.value : this.processedAt,
    status: status ?? this.status,
    errorMessage: errorMessage.present ? errorMessage.value : this.errorMessage,
    retryCount: retryCount ?? this.retryCount,
    priority: priority ?? this.priority,
    permissionEpochAtEdit: permissionEpochAtEdit.present
        ? permissionEpochAtEdit.value
        : this.permissionEpochAtEdit,
    lastRetryAt: lastRetryAt.present ? lastRetryAt.value : this.lastRetryAt,
    maxRetries: maxRetries ?? this.maxRetries,
  );
  OutboxEvent copyWithCompanion(OutboxEventsCompanion data) {
    return OutboxEvent(
      id: data.id.present ? data.id.value : this.id,
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      entityId: data.entityId.present ? data.entityId.value : this.entityId,
      operation: data.operation.present ? data.operation.value : this.operation,
      payload: data.payload.present ? data.payload.value : this.payload,
      baseRevision: data.baseRevision.present
          ? data.baseRevision.value
          : this.baseRevision,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      processedAt: data.processedAt.present
          ? data.processedAt.value
          : this.processedAt,
      status: data.status.present ? data.status.value : this.status,
      errorMessage: data.errorMessage.present
          ? data.errorMessage.value
          : this.errorMessage,
      retryCount: data.retryCount.present
          ? data.retryCount.value
          : this.retryCount,
      priority: data.priority.present ? data.priority.value : this.priority,
      permissionEpochAtEdit: data.permissionEpochAtEdit.present
          ? data.permissionEpochAtEdit.value
          : this.permissionEpochAtEdit,
      lastRetryAt: data.lastRetryAt.present
          ? data.lastRetryAt.value
          : this.lastRetryAt,
      maxRetries: data.maxRetries.present
          ? data.maxRetries.value
          : this.maxRetries,
    );
  }

  @override
  String toString() {
    return (StringBuffer('OutboxEvent(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('operation: $operation, ')
          ..write('payload: $payload, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('createdAt: $createdAt, ')
          ..write('processedAt: $processedAt, ')
          ..write('status: $status, ')
          ..write('errorMessage: $errorMessage, ')
          ..write('retryCount: $retryCount, ')
          ..write('priority: $priority, ')
          ..write('permissionEpochAtEdit: $permissionEpochAtEdit, ')
          ..write('lastRetryAt: $lastRetryAt, ')
          ..write('maxRetries: $maxRetries')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    entityType,
    entityId,
    operation,
    payload,
    baseRevision,
    createdAt,
    processedAt,
    status,
    errorMessage,
    retryCount,
    priority,
    permissionEpochAtEdit,
    lastRetryAt,
    maxRetries,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is OutboxEvent &&
          other.id == this.id &&
          other.entityType == this.entityType &&
          other.entityId == this.entityId &&
          other.operation == this.operation &&
          other.payload == this.payload &&
          other.baseRevision == this.baseRevision &&
          other.createdAt == this.createdAt &&
          other.processedAt == this.processedAt &&
          other.status == this.status &&
          other.errorMessage == this.errorMessage &&
          other.retryCount == this.retryCount &&
          other.priority == this.priority &&
          other.permissionEpochAtEdit == this.permissionEpochAtEdit &&
          other.lastRetryAt == this.lastRetryAt &&
          other.maxRetries == this.maxRetries);
}

class OutboxEventsCompanion extends UpdateCompanion<OutboxEvent> {
  final Value<String> id;
  final Value<String> entityType;
  final Value<String> entityId;
  final Value<String> operation;
  final Value<String> payload;
  final Value<int?> baseRevision;
  final Value<DateTime> createdAt;
  final Value<DateTime?> processedAt;
  final Value<String> status;
  final Value<String?> errorMessage;
  final Value<int> retryCount;
  final Value<int> priority;
  final Value<int?> permissionEpochAtEdit;
  final Value<DateTime?> lastRetryAt;
  final Value<int> maxRetries;
  final Value<int> rowid;
  const OutboxEventsCompanion({
    this.id = const Value.absent(),
    this.entityType = const Value.absent(),
    this.entityId = const Value.absent(),
    this.operation = const Value.absent(),
    this.payload = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.processedAt = const Value.absent(),
    this.status = const Value.absent(),
    this.errorMessage = const Value.absent(),
    this.retryCount = const Value.absent(),
    this.priority = const Value.absent(),
    this.permissionEpochAtEdit = const Value.absent(),
    this.lastRetryAt = const Value.absent(),
    this.maxRetries = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  OutboxEventsCompanion.insert({
    required String id,
    required String entityType,
    required String entityId,
    required String operation,
    required String payload,
    this.baseRevision = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.processedAt = const Value.absent(),
    this.status = const Value.absent(),
    this.errorMessage = const Value.absent(),
    this.retryCount = const Value.absent(),
    this.priority = const Value.absent(),
    this.permissionEpochAtEdit = const Value.absent(),
    this.lastRetryAt = const Value.absent(),
    this.maxRetries = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       entityType = Value(entityType),
       entityId = Value(entityId),
       operation = Value(operation),
       payload = Value(payload);
  static Insertable<OutboxEvent> custom({
    Expression<String>? id,
    Expression<String>? entityType,
    Expression<String>? entityId,
    Expression<String>? operation,
    Expression<String>? payload,
    Expression<int>? baseRevision,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? processedAt,
    Expression<String>? status,
    Expression<String>? errorMessage,
    Expression<int>? retryCount,
    Expression<int>? priority,
    Expression<int>? permissionEpochAtEdit,
    Expression<DateTime>? lastRetryAt,
    Expression<int>? maxRetries,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (entityType != null) 'entity_type': entityType,
      if (entityId != null) 'entity_id': entityId,
      if (operation != null) 'operation': operation,
      if (payload != null) 'payload': payload,
      if (baseRevision != null) 'base_revision': baseRevision,
      if (createdAt != null) 'created_at': createdAt,
      if (processedAt != null) 'processed_at': processedAt,
      if (status != null) 'status': status,
      if (errorMessage != null) 'error_message': errorMessage,
      if (retryCount != null) 'retry_count': retryCount,
      if (priority != null) 'priority': priority,
      if (permissionEpochAtEdit != null)
        'permission_epoch_at_edit': permissionEpochAtEdit,
      if (lastRetryAt != null) 'last_retry_at': lastRetryAt,
      if (maxRetries != null) 'max_retries': maxRetries,
      if (rowid != null) 'rowid': rowid,
    });
  }

  OutboxEventsCompanion copyWith({
    Value<String>? id,
    Value<String>? entityType,
    Value<String>? entityId,
    Value<String>? operation,
    Value<String>? payload,
    Value<int?>? baseRevision,
    Value<DateTime>? createdAt,
    Value<DateTime?>? processedAt,
    Value<String>? status,
    Value<String?>? errorMessage,
    Value<int>? retryCount,
    Value<int>? priority,
    Value<int?>? permissionEpochAtEdit,
    Value<DateTime?>? lastRetryAt,
    Value<int>? maxRetries,
    Value<int>? rowid,
  }) {
    return OutboxEventsCompanion(
      id: id ?? this.id,
      entityType: entityType ?? this.entityType,
      entityId: entityId ?? this.entityId,
      operation: operation ?? this.operation,
      payload: payload ?? this.payload,
      baseRevision: baseRevision ?? this.baseRevision,
      createdAt: createdAt ?? this.createdAt,
      processedAt: processedAt ?? this.processedAt,
      status: status ?? this.status,
      errorMessage: errorMessage ?? this.errorMessage,
      retryCount: retryCount ?? this.retryCount,
      priority: priority ?? this.priority,
      permissionEpochAtEdit:
          permissionEpochAtEdit ?? this.permissionEpochAtEdit,
      lastRetryAt: lastRetryAt ?? this.lastRetryAt,
      maxRetries: maxRetries ?? this.maxRetries,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (entityId.present) {
      map['entity_id'] = Variable<String>(entityId.value);
    }
    if (operation.present) {
      map['operation'] = Variable<String>(operation.value);
    }
    if (payload.present) {
      map['payload'] = Variable<String>(payload.value);
    }
    if (baseRevision.present) {
      map['base_revision'] = Variable<int>(baseRevision.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (processedAt.present) {
      map['processed_at'] = Variable<DateTime>(processedAt.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (errorMessage.present) {
      map['error_message'] = Variable<String>(errorMessage.value);
    }
    if (retryCount.present) {
      map['retry_count'] = Variable<int>(retryCount.value);
    }
    if (priority.present) {
      map['priority'] = Variable<int>(priority.value);
    }
    if (permissionEpochAtEdit.present) {
      map['permission_epoch_at_edit'] = Variable<int>(
        permissionEpochAtEdit.value,
      );
    }
    if (lastRetryAt.present) {
      map['last_retry_at'] = Variable<DateTime>(lastRetryAt.value);
    }
    if (maxRetries.present) {
      map['max_retries'] = Variable<int>(maxRetries.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('OutboxEventsCompanion(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('operation: $operation, ')
          ..write('payload: $payload, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('createdAt: $createdAt, ')
          ..write('processedAt: $processedAt, ')
          ..write('status: $status, ')
          ..write('errorMessage: $errorMessage, ')
          ..write('retryCount: $retryCount, ')
          ..write('priority: $priority, ')
          ..write('permissionEpochAtEdit: $permissionEpochAtEdit, ')
          ..write('lastRetryAt: $lastRetryAt, ')
          ..write('maxRetries: $maxRetries, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CategoryLearningTable extends CategoryLearning
    with TableInfo<$CategoryLearningTable, CategoryLearningData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CategoryLearningTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _merchantPatternMeta = const VerificationMeta(
    'merchantPattern',
  );
  @override
  late final GeneratedColumn<String> merchantPattern = GeneratedColumn<String>(
    'merchant_pattern',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _semanticTokensMeta = const VerificationMeta(
    'semanticTokens',
  );
  @override
  late final GeneratedColumn<String> semanticTokens = GeneratedColumn<String>(
    'semantic_tokens',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _categoryNameMeta = const VerificationMeta(
    'categoryName',
  );
  @override
  late final GeneratedColumn<String> categoryName = GeneratedColumn<String>(
    'category_name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _subCategoryIdMeta = const VerificationMeta(
    'subCategoryId',
  );
  @override
  late final GeneratedColumn<String> subCategoryId = GeneratedColumn<String>(
    'sub_category_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES sub_categories (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _confidenceBoostMeta = const VerificationMeta(
    'confidenceBoost',
  );
  @override
  late final GeneratedColumn<int> confidenceBoost = GeneratedColumn<int>(
    'confidence_boost',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(10),
  );
  static const VerificationMeta _sourceWeightMeta = const VerificationMeta(
    'sourceWeight',
  );
  @override
  late final GeneratedColumn<double> sourceWeight = GeneratedColumn<double>(
    'source_weight',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(1.0),
  );
  static const VerificationMeta _usageCountMeta = const VerificationMeta(
    'usageCount',
  );
  @override
  late final GeneratedColumn<int> usageCount = GeneratedColumn<int>(
    'usage_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(1),
  );
  static const VerificationMeta _lastUsedAtMeta = const VerificationMeta(
    'lastUsedAt',
  );
  @override
  late final GeneratedColumn<DateTime> lastUsedAt = GeneratedColumn<DateTime>(
    'last_used_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    merchantPattern,
    semanticTokens,
    categoryName,
    subCategoryId,
    confidenceBoost,
    sourceWeight,
    usageCount,
    lastUsedAt,
    createdAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'category_learning';
  @override
  VerificationContext validateIntegrity(
    Insertable<CategoryLearningData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('merchant_pattern')) {
      context.handle(
        _merchantPatternMeta,
        merchantPattern.isAcceptableOrUnknown(
          data['merchant_pattern']!,
          _merchantPatternMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_merchantPatternMeta);
    }
    if (data.containsKey('semantic_tokens')) {
      context.handle(
        _semanticTokensMeta,
        semanticTokens.isAcceptableOrUnknown(
          data['semantic_tokens']!,
          _semanticTokensMeta,
        ),
      );
    }
    if (data.containsKey('category_name')) {
      context.handle(
        _categoryNameMeta,
        categoryName.isAcceptableOrUnknown(
          data['category_name']!,
          _categoryNameMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_categoryNameMeta);
    }
    if (data.containsKey('sub_category_id')) {
      context.handle(
        _subCategoryIdMeta,
        subCategoryId.isAcceptableOrUnknown(
          data['sub_category_id']!,
          _subCategoryIdMeta,
        ),
      );
    }
    if (data.containsKey('confidence_boost')) {
      context.handle(
        _confidenceBoostMeta,
        confidenceBoost.isAcceptableOrUnknown(
          data['confidence_boost']!,
          _confidenceBoostMeta,
        ),
      );
    }
    if (data.containsKey('source_weight')) {
      context.handle(
        _sourceWeightMeta,
        sourceWeight.isAcceptableOrUnknown(
          data['source_weight']!,
          _sourceWeightMeta,
        ),
      );
    }
    if (data.containsKey('usage_count')) {
      context.handle(
        _usageCountMeta,
        usageCount.isAcceptableOrUnknown(data['usage_count']!, _usageCountMeta),
      );
    }
    if (data.containsKey('last_used_at')) {
      context.handle(
        _lastUsedAtMeta,
        lastUsedAt.isAcceptableOrUnknown(
          data['last_used_at']!,
          _lastUsedAtMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_lastUsedAtMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CategoryLearningData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CategoryLearningData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      merchantPattern: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}merchant_pattern'],
      )!,
      semanticTokens: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}semantic_tokens'],
      ),
      categoryName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category_name'],
      )!,
      subCategoryId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sub_category_id'],
      ),
      confidenceBoost: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}confidence_boost'],
      )!,
      sourceWeight: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}source_weight'],
      )!,
      usageCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}usage_count'],
      )!,
      lastUsedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_used_at'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $CategoryLearningTable createAlias(String alias) {
    return $CategoryLearningTable(attachedDatabase, alias);
  }
}

class CategoryLearningData extends DataClass
    implements Insertable<CategoryLearningData> {
  final String id;
  final String merchantPattern;
  final String? semanticTokens;
  final String categoryName;
  final String? subCategoryId;
  final int confidenceBoost;
  final double sourceWeight;
  final int usageCount;
  final DateTime lastUsedAt;
  final DateTime createdAt;
  const CategoryLearningData({
    required this.id,
    required this.merchantPattern,
    this.semanticTokens,
    required this.categoryName,
    this.subCategoryId,
    required this.confidenceBoost,
    required this.sourceWeight,
    required this.usageCount,
    required this.lastUsedAt,
    required this.createdAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['merchant_pattern'] = Variable<String>(merchantPattern);
    if (!nullToAbsent || semanticTokens != null) {
      map['semantic_tokens'] = Variable<String>(semanticTokens);
    }
    map['category_name'] = Variable<String>(categoryName);
    if (!nullToAbsent || subCategoryId != null) {
      map['sub_category_id'] = Variable<String>(subCategoryId);
    }
    map['confidence_boost'] = Variable<int>(confidenceBoost);
    map['source_weight'] = Variable<double>(sourceWeight);
    map['usage_count'] = Variable<int>(usageCount);
    map['last_used_at'] = Variable<DateTime>(lastUsedAt);
    map['created_at'] = Variable<DateTime>(createdAt);
    return map;
  }

  CategoryLearningCompanion toCompanion(bool nullToAbsent) {
    return CategoryLearningCompanion(
      id: Value(id),
      merchantPattern: Value(merchantPattern),
      semanticTokens: semanticTokens == null && nullToAbsent
          ? const Value.absent()
          : Value(semanticTokens),
      categoryName: Value(categoryName),
      subCategoryId: subCategoryId == null && nullToAbsent
          ? const Value.absent()
          : Value(subCategoryId),
      confidenceBoost: Value(confidenceBoost),
      sourceWeight: Value(sourceWeight),
      usageCount: Value(usageCount),
      lastUsedAt: Value(lastUsedAt),
      createdAt: Value(createdAt),
    );
  }

  factory CategoryLearningData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CategoryLearningData(
      id: serializer.fromJson<String>(json['id']),
      merchantPattern: serializer.fromJson<String>(json['merchantPattern']),
      semanticTokens: serializer.fromJson<String?>(json['semanticTokens']),
      categoryName: serializer.fromJson<String>(json['categoryName']),
      subCategoryId: serializer.fromJson<String?>(json['subCategoryId']),
      confidenceBoost: serializer.fromJson<int>(json['confidenceBoost']),
      sourceWeight: serializer.fromJson<double>(json['sourceWeight']),
      usageCount: serializer.fromJson<int>(json['usageCount']),
      lastUsedAt: serializer.fromJson<DateTime>(json['lastUsedAt']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'merchantPattern': serializer.toJson<String>(merchantPattern),
      'semanticTokens': serializer.toJson<String?>(semanticTokens),
      'categoryName': serializer.toJson<String>(categoryName),
      'subCategoryId': serializer.toJson<String?>(subCategoryId),
      'confidenceBoost': serializer.toJson<int>(confidenceBoost),
      'sourceWeight': serializer.toJson<double>(sourceWeight),
      'usageCount': serializer.toJson<int>(usageCount),
      'lastUsedAt': serializer.toJson<DateTime>(lastUsedAt),
      'createdAt': serializer.toJson<DateTime>(createdAt),
    };
  }

  CategoryLearningData copyWith({
    String? id,
    String? merchantPattern,
    Value<String?> semanticTokens = const Value.absent(),
    String? categoryName,
    Value<String?> subCategoryId = const Value.absent(),
    int? confidenceBoost,
    double? sourceWeight,
    int? usageCount,
    DateTime? lastUsedAt,
    DateTime? createdAt,
  }) => CategoryLearningData(
    id: id ?? this.id,
    merchantPattern: merchantPattern ?? this.merchantPattern,
    semanticTokens: semanticTokens.present
        ? semanticTokens.value
        : this.semanticTokens,
    categoryName: categoryName ?? this.categoryName,
    subCategoryId: subCategoryId.present
        ? subCategoryId.value
        : this.subCategoryId,
    confidenceBoost: confidenceBoost ?? this.confidenceBoost,
    sourceWeight: sourceWeight ?? this.sourceWeight,
    usageCount: usageCount ?? this.usageCount,
    lastUsedAt: lastUsedAt ?? this.lastUsedAt,
    createdAt: createdAt ?? this.createdAt,
  );
  CategoryLearningData copyWithCompanion(CategoryLearningCompanion data) {
    return CategoryLearningData(
      id: data.id.present ? data.id.value : this.id,
      merchantPattern: data.merchantPattern.present
          ? data.merchantPattern.value
          : this.merchantPattern,
      semanticTokens: data.semanticTokens.present
          ? data.semanticTokens.value
          : this.semanticTokens,
      categoryName: data.categoryName.present
          ? data.categoryName.value
          : this.categoryName,
      subCategoryId: data.subCategoryId.present
          ? data.subCategoryId.value
          : this.subCategoryId,
      confidenceBoost: data.confidenceBoost.present
          ? data.confidenceBoost.value
          : this.confidenceBoost,
      sourceWeight: data.sourceWeight.present
          ? data.sourceWeight.value
          : this.sourceWeight,
      usageCount: data.usageCount.present
          ? data.usageCount.value
          : this.usageCount,
      lastUsedAt: data.lastUsedAt.present
          ? data.lastUsedAt.value
          : this.lastUsedAt,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CategoryLearningData(')
          ..write('id: $id, ')
          ..write('merchantPattern: $merchantPattern, ')
          ..write('semanticTokens: $semanticTokens, ')
          ..write('categoryName: $categoryName, ')
          ..write('subCategoryId: $subCategoryId, ')
          ..write('confidenceBoost: $confidenceBoost, ')
          ..write('sourceWeight: $sourceWeight, ')
          ..write('usageCount: $usageCount, ')
          ..write('lastUsedAt: $lastUsedAt, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    merchantPattern,
    semanticTokens,
    categoryName,
    subCategoryId,
    confidenceBoost,
    sourceWeight,
    usageCount,
    lastUsedAt,
    createdAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CategoryLearningData &&
          other.id == this.id &&
          other.merchantPattern == this.merchantPattern &&
          other.semanticTokens == this.semanticTokens &&
          other.categoryName == this.categoryName &&
          other.subCategoryId == this.subCategoryId &&
          other.confidenceBoost == this.confidenceBoost &&
          other.sourceWeight == this.sourceWeight &&
          other.usageCount == this.usageCount &&
          other.lastUsedAt == this.lastUsedAt &&
          other.createdAt == this.createdAt);
}

class CategoryLearningCompanion extends UpdateCompanion<CategoryLearningData> {
  final Value<String> id;
  final Value<String> merchantPattern;
  final Value<String?> semanticTokens;
  final Value<String> categoryName;
  final Value<String?> subCategoryId;
  final Value<int> confidenceBoost;
  final Value<double> sourceWeight;
  final Value<int> usageCount;
  final Value<DateTime> lastUsedAt;
  final Value<DateTime> createdAt;
  final Value<int> rowid;
  const CategoryLearningCompanion({
    this.id = const Value.absent(),
    this.merchantPattern = const Value.absent(),
    this.semanticTokens = const Value.absent(),
    this.categoryName = const Value.absent(),
    this.subCategoryId = const Value.absent(),
    this.confidenceBoost = const Value.absent(),
    this.sourceWeight = const Value.absent(),
    this.usageCount = const Value.absent(),
    this.lastUsedAt = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CategoryLearningCompanion.insert({
    required String id,
    required String merchantPattern,
    this.semanticTokens = const Value.absent(),
    required String categoryName,
    this.subCategoryId = const Value.absent(),
    this.confidenceBoost = const Value.absent(),
    this.sourceWeight = const Value.absent(),
    this.usageCount = const Value.absent(),
    required DateTime lastUsedAt,
    this.createdAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       merchantPattern = Value(merchantPattern),
       categoryName = Value(categoryName),
       lastUsedAt = Value(lastUsedAt);
  static Insertable<CategoryLearningData> custom({
    Expression<String>? id,
    Expression<String>? merchantPattern,
    Expression<String>? semanticTokens,
    Expression<String>? categoryName,
    Expression<String>? subCategoryId,
    Expression<int>? confidenceBoost,
    Expression<double>? sourceWeight,
    Expression<int>? usageCount,
    Expression<DateTime>? lastUsedAt,
    Expression<DateTime>? createdAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (merchantPattern != null) 'merchant_pattern': merchantPattern,
      if (semanticTokens != null) 'semantic_tokens': semanticTokens,
      if (categoryName != null) 'category_name': categoryName,
      if (subCategoryId != null) 'sub_category_id': subCategoryId,
      if (confidenceBoost != null) 'confidence_boost': confidenceBoost,
      if (sourceWeight != null) 'source_weight': sourceWeight,
      if (usageCount != null) 'usage_count': usageCount,
      if (lastUsedAt != null) 'last_used_at': lastUsedAt,
      if (createdAt != null) 'created_at': createdAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CategoryLearningCompanion copyWith({
    Value<String>? id,
    Value<String>? merchantPattern,
    Value<String?>? semanticTokens,
    Value<String>? categoryName,
    Value<String?>? subCategoryId,
    Value<int>? confidenceBoost,
    Value<double>? sourceWeight,
    Value<int>? usageCount,
    Value<DateTime>? lastUsedAt,
    Value<DateTime>? createdAt,
    Value<int>? rowid,
  }) {
    return CategoryLearningCompanion(
      id: id ?? this.id,
      merchantPattern: merchantPattern ?? this.merchantPattern,
      semanticTokens: semanticTokens ?? this.semanticTokens,
      categoryName: categoryName ?? this.categoryName,
      subCategoryId: subCategoryId ?? this.subCategoryId,
      confidenceBoost: confidenceBoost ?? this.confidenceBoost,
      sourceWeight: sourceWeight ?? this.sourceWeight,
      usageCount: usageCount ?? this.usageCount,
      lastUsedAt: lastUsedAt ?? this.lastUsedAt,
      createdAt: createdAt ?? this.createdAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (merchantPattern.present) {
      map['merchant_pattern'] = Variable<String>(merchantPattern.value);
    }
    if (semanticTokens.present) {
      map['semantic_tokens'] = Variable<String>(semanticTokens.value);
    }
    if (categoryName.present) {
      map['category_name'] = Variable<String>(categoryName.value);
    }
    if (subCategoryId.present) {
      map['sub_category_id'] = Variable<String>(subCategoryId.value);
    }
    if (confidenceBoost.present) {
      map['confidence_boost'] = Variable<int>(confidenceBoost.value);
    }
    if (sourceWeight.present) {
      map['source_weight'] = Variable<double>(sourceWeight.value);
    }
    if (usageCount.present) {
      map['usage_count'] = Variable<int>(usageCount.value);
    }
    if (lastUsedAt.present) {
      map['last_used_at'] = Variable<DateTime>(lastUsedAt.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CategoryLearningCompanion(')
          ..write('id: $id, ')
          ..write('merchantPattern: $merchantPattern, ')
          ..write('semanticTokens: $semanticTokens, ')
          ..write('categoryName: $categoryName, ')
          ..write('subCategoryId: $subCategoryId, ')
          ..write('confidenceBoost: $confidenceBoost, ')
          ..write('sourceWeight: $sourceWeight, ')
          ..write('usageCount: $usageCount, ')
          ..write('lastUsedAt: $lastUsedAt, ')
          ..write('createdAt: $createdAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SyncRecoveryStateTable extends SyncRecoveryState
    with TableInfo<$SyncRecoveryStateTable, SyncRecoveryStateData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncRecoveryStateTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _currentStateMeta = const VerificationMeta(
    'currentState',
  );
  @override
  late final GeneratedColumn<String> currentState = GeneratedColumn<String>(
    'current_state',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(
      minTextLength: 1,
      maxTextLength: 50,
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _syncStartedAtMeta = const VerificationMeta(
    'syncStartedAt',
  );
  @override
  late final GeneratedColumn<DateTime> syncStartedAt =
      GeneratedColumn<DateTime>(
        'sync_started_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _lastSyncCompletedAtMeta =
      const VerificationMeta('lastSyncCompletedAt');
  @override
  late final GeneratedColumn<DateTime> lastSyncCompletedAt =
      GeneratedColumn<DateTime>(
        'last_sync_completed_at',
        aliasedName,
        true,
        type: DriftSqlType.dateTime,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _syncReasonMeta = const VerificationMeta(
    'syncReason',
  );
  @override
  late final GeneratedColumn<String> syncReason = GeneratedColumn<String>(
    'sync_reason',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(
      minTextLength: 1,
      maxTextLength: 50,
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _pendingOperationsMeta = const VerificationMeta(
    'pendingOperations',
  );
  @override
  late final GeneratedColumn<String> pendingOperations =
      GeneratedColumn<String>(
        'pending_operations',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _lastErrorMeta = const VerificationMeta(
    'lastError',
  );
  @override
  late final GeneratedColumn<String> lastError = GeneratedColumn<String>(
    'last_error',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _retryCountMeta = const VerificationMeta(
    'retryCount',
  );
  @override
  late final GeneratedColumn<int> retryCount = GeneratedColumn<int>(
    'retry_count',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    currentState,
    syncStartedAt,
    lastSyncCompletedAt,
    syncReason,
    pendingOperations,
    lastError,
    retryCount,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sync_recovery_state';
  @override
  VerificationContext validateIntegrity(
    Insertable<SyncRecoveryStateData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('current_state')) {
      context.handle(
        _currentStateMeta,
        currentState.isAcceptableOrUnknown(
          data['current_state']!,
          _currentStateMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_currentStateMeta);
    }
    if (data.containsKey('sync_started_at')) {
      context.handle(
        _syncStartedAtMeta,
        syncStartedAt.isAcceptableOrUnknown(
          data['sync_started_at']!,
          _syncStartedAtMeta,
        ),
      );
    }
    if (data.containsKey('last_sync_completed_at')) {
      context.handle(
        _lastSyncCompletedAtMeta,
        lastSyncCompletedAt.isAcceptableOrUnknown(
          data['last_sync_completed_at']!,
          _lastSyncCompletedAtMeta,
        ),
      );
    }
    if (data.containsKey('sync_reason')) {
      context.handle(
        _syncReasonMeta,
        syncReason.isAcceptableOrUnknown(data['sync_reason']!, _syncReasonMeta),
      );
    }
    if (data.containsKey('pending_operations')) {
      context.handle(
        _pendingOperationsMeta,
        pendingOperations.isAcceptableOrUnknown(
          data['pending_operations']!,
          _pendingOperationsMeta,
        ),
      );
    }
    if (data.containsKey('last_error')) {
      context.handle(
        _lastErrorMeta,
        lastError.isAcceptableOrUnknown(data['last_error']!, _lastErrorMeta),
      );
    }
    if (data.containsKey('retry_count')) {
      context.handle(
        _retryCountMeta,
        retryCount.isAcceptableOrUnknown(data['retry_count']!, _retryCountMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SyncRecoveryStateData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SyncRecoveryStateData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      currentState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}current_state'],
      )!,
      syncStartedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}sync_started_at'],
      ),
      lastSyncCompletedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}last_sync_completed_at'],
      ),
      syncReason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_reason'],
      ),
      pendingOperations: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}pending_operations'],
      ),
      lastError: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_error'],
      ),
      retryCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}retry_count'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $SyncRecoveryStateTable createAlias(String alias) {
    return $SyncRecoveryStateTable(attachedDatabase, alias);
  }
}

class SyncRecoveryStateData extends DataClass
    implements Insertable<SyncRecoveryStateData> {
  final int id;
  final String currentState;
  final DateTime? syncStartedAt;
  final DateTime? lastSyncCompletedAt;
  final String? syncReason;
  final String? pendingOperations;
  final String? lastError;
  final int retryCount;
  final DateTime updatedAt;
  const SyncRecoveryStateData({
    required this.id,
    required this.currentState,
    this.syncStartedAt,
    this.lastSyncCompletedAt,
    this.syncReason,
    this.pendingOperations,
    this.lastError,
    required this.retryCount,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['current_state'] = Variable<String>(currentState);
    if (!nullToAbsent || syncStartedAt != null) {
      map['sync_started_at'] = Variable<DateTime>(syncStartedAt);
    }
    if (!nullToAbsent || lastSyncCompletedAt != null) {
      map['last_sync_completed_at'] = Variable<DateTime>(lastSyncCompletedAt);
    }
    if (!nullToAbsent || syncReason != null) {
      map['sync_reason'] = Variable<String>(syncReason);
    }
    if (!nullToAbsent || pendingOperations != null) {
      map['pending_operations'] = Variable<String>(pendingOperations);
    }
    if (!nullToAbsent || lastError != null) {
      map['last_error'] = Variable<String>(lastError);
    }
    map['retry_count'] = Variable<int>(retryCount);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  SyncRecoveryStateCompanion toCompanion(bool nullToAbsent) {
    return SyncRecoveryStateCompanion(
      id: Value(id),
      currentState: Value(currentState),
      syncStartedAt: syncStartedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(syncStartedAt),
      lastSyncCompletedAt: lastSyncCompletedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(lastSyncCompletedAt),
      syncReason: syncReason == null && nullToAbsent
          ? const Value.absent()
          : Value(syncReason),
      pendingOperations: pendingOperations == null && nullToAbsent
          ? const Value.absent()
          : Value(pendingOperations),
      lastError: lastError == null && nullToAbsent
          ? const Value.absent()
          : Value(lastError),
      retryCount: Value(retryCount),
      updatedAt: Value(updatedAt),
    );
  }

  factory SyncRecoveryStateData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SyncRecoveryStateData(
      id: serializer.fromJson<int>(json['id']),
      currentState: serializer.fromJson<String>(json['currentState']),
      syncStartedAt: serializer.fromJson<DateTime?>(json['syncStartedAt']),
      lastSyncCompletedAt: serializer.fromJson<DateTime?>(
        json['lastSyncCompletedAt'],
      ),
      syncReason: serializer.fromJson<String?>(json['syncReason']),
      pendingOperations: serializer.fromJson<String?>(
        json['pendingOperations'],
      ),
      lastError: serializer.fromJson<String?>(json['lastError']),
      retryCount: serializer.fromJson<int>(json['retryCount']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'currentState': serializer.toJson<String>(currentState),
      'syncStartedAt': serializer.toJson<DateTime?>(syncStartedAt),
      'lastSyncCompletedAt': serializer.toJson<DateTime?>(lastSyncCompletedAt),
      'syncReason': serializer.toJson<String?>(syncReason),
      'pendingOperations': serializer.toJson<String?>(pendingOperations),
      'lastError': serializer.toJson<String?>(lastError),
      'retryCount': serializer.toJson<int>(retryCount),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  SyncRecoveryStateData copyWith({
    int? id,
    String? currentState,
    Value<DateTime?> syncStartedAt = const Value.absent(),
    Value<DateTime?> lastSyncCompletedAt = const Value.absent(),
    Value<String?> syncReason = const Value.absent(),
    Value<String?> pendingOperations = const Value.absent(),
    Value<String?> lastError = const Value.absent(),
    int? retryCount,
    DateTime? updatedAt,
  }) => SyncRecoveryStateData(
    id: id ?? this.id,
    currentState: currentState ?? this.currentState,
    syncStartedAt: syncStartedAt.present
        ? syncStartedAt.value
        : this.syncStartedAt,
    lastSyncCompletedAt: lastSyncCompletedAt.present
        ? lastSyncCompletedAt.value
        : this.lastSyncCompletedAt,
    syncReason: syncReason.present ? syncReason.value : this.syncReason,
    pendingOperations: pendingOperations.present
        ? pendingOperations.value
        : this.pendingOperations,
    lastError: lastError.present ? lastError.value : this.lastError,
    retryCount: retryCount ?? this.retryCount,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  SyncRecoveryStateData copyWithCompanion(SyncRecoveryStateCompanion data) {
    return SyncRecoveryStateData(
      id: data.id.present ? data.id.value : this.id,
      currentState: data.currentState.present
          ? data.currentState.value
          : this.currentState,
      syncStartedAt: data.syncStartedAt.present
          ? data.syncStartedAt.value
          : this.syncStartedAt,
      lastSyncCompletedAt: data.lastSyncCompletedAt.present
          ? data.lastSyncCompletedAt.value
          : this.lastSyncCompletedAt,
      syncReason: data.syncReason.present
          ? data.syncReason.value
          : this.syncReason,
      pendingOperations: data.pendingOperations.present
          ? data.pendingOperations.value
          : this.pendingOperations,
      lastError: data.lastError.present ? data.lastError.value : this.lastError,
      retryCount: data.retryCount.present
          ? data.retryCount.value
          : this.retryCount,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SyncRecoveryStateData(')
          ..write('id: $id, ')
          ..write('currentState: $currentState, ')
          ..write('syncStartedAt: $syncStartedAt, ')
          ..write('lastSyncCompletedAt: $lastSyncCompletedAt, ')
          ..write('syncReason: $syncReason, ')
          ..write('pendingOperations: $pendingOperations, ')
          ..write('lastError: $lastError, ')
          ..write('retryCount: $retryCount, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    currentState,
    syncStartedAt,
    lastSyncCompletedAt,
    syncReason,
    pendingOperations,
    lastError,
    retryCount,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SyncRecoveryStateData &&
          other.id == this.id &&
          other.currentState == this.currentState &&
          other.syncStartedAt == this.syncStartedAt &&
          other.lastSyncCompletedAt == this.lastSyncCompletedAt &&
          other.syncReason == this.syncReason &&
          other.pendingOperations == this.pendingOperations &&
          other.lastError == this.lastError &&
          other.retryCount == this.retryCount &&
          other.updatedAt == this.updatedAt);
}

class SyncRecoveryStateCompanion
    extends UpdateCompanion<SyncRecoveryStateData> {
  final Value<int> id;
  final Value<String> currentState;
  final Value<DateTime?> syncStartedAt;
  final Value<DateTime?> lastSyncCompletedAt;
  final Value<String?> syncReason;
  final Value<String?> pendingOperations;
  final Value<String?> lastError;
  final Value<int> retryCount;
  final Value<DateTime> updatedAt;
  const SyncRecoveryStateCompanion({
    this.id = const Value.absent(),
    this.currentState = const Value.absent(),
    this.syncStartedAt = const Value.absent(),
    this.lastSyncCompletedAt = const Value.absent(),
    this.syncReason = const Value.absent(),
    this.pendingOperations = const Value.absent(),
    this.lastError = const Value.absent(),
    this.retryCount = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  SyncRecoveryStateCompanion.insert({
    this.id = const Value.absent(),
    required String currentState,
    this.syncStartedAt = const Value.absent(),
    this.lastSyncCompletedAt = const Value.absent(),
    this.syncReason = const Value.absent(),
    this.pendingOperations = const Value.absent(),
    this.lastError = const Value.absent(),
    this.retryCount = const Value.absent(),
    required DateTime updatedAt,
  }) : currentState = Value(currentState),
       updatedAt = Value(updatedAt);
  static Insertable<SyncRecoveryStateData> custom({
    Expression<int>? id,
    Expression<String>? currentState,
    Expression<DateTime>? syncStartedAt,
    Expression<DateTime>? lastSyncCompletedAt,
    Expression<String>? syncReason,
    Expression<String>? pendingOperations,
    Expression<String>? lastError,
    Expression<int>? retryCount,
    Expression<DateTime>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (currentState != null) 'current_state': currentState,
      if (syncStartedAt != null) 'sync_started_at': syncStartedAt,
      if (lastSyncCompletedAt != null)
        'last_sync_completed_at': lastSyncCompletedAt,
      if (syncReason != null) 'sync_reason': syncReason,
      if (pendingOperations != null) 'pending_operations': pendingOperations,
      if (lastError != null) 'last_error': lastError,
      if (retryCount != null) 'retry_count': retryCount,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  SyncRecoveryStateCompanion copyWith({
    Value<int>? id,
    Value<String>? currentState,
    Value<DateTime?>? syncStartedAt,
    Value<DateTime?>? lastSyncCompletedAt,
    Value<String?>? syncReason,
    Value<String?>? pendingOperations,
    Value<String?>? lastError,
    Value<int>? retryCount,
    Value<DateTime>? updatedAt,
  }) {
    return SyncRecoveryStateCompanion(
      id: id ?? this.id,
      currentState: currentState ?? this.currentState,
      syncStartedAt: syncStartedAt ?? this.syncStartedAt,
      lastSyncCompletedAt: lastSyncCompletedAt ?? this.lastSyncCompletedAt,
      syncReason: syncReason ?? this.syncReason,
      pendingOperations: pendingOperations ?? this.pendingOperations,
      lastError: lastError ?? this.lastError,
      retryCount: retryCount ?? this.retryCount,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (currentState.present) {
      map['current_state'] = Variable<String>(currentState.value);
    }
    if (syncStartedAt.present) {
      map['sync_started_at'] = Variable<DateTime>(syncStartedAt.value);
    }
    if (lastSyncCompletedAt.present) {
      map['last_sync_completed_at'] = Variable<DateTime>(
        lastSyncCompletedAt.value,
      );
    }
    if (syncReason.present) {
      map['sync_reason'] = Variable<String>(syncReason.value);
    }
    if (pendingOperations.present) {
      map['pending_operations'] = Variable<String>(pendingOperations.value);
    }
    if (lastError.present) {
      map['last_error'] = Variable<String>(lastError.value);
    }
    if (retryCount.present) {
      map['retry_count'] = Variable<int>(retryCount.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncRecoveryStateCompanion(')
          ..write('id: $id, ')
          ..write('currentState: $currentState, ')
          ..write('syncStartedAt: $syncStartedAt, ')
          ..write('lastSyncCompletedAt: $lastSyncCompletedAt, ')
          ..write('syncReason: $syncReason, ')
          ..write('pendingOperations: $pendingOperations, ')
          ..write('lastError: $lastError, ')
          ..write('retryCount: $retryCount, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

class $SyncOperationsLogTable extends SyncOperationsLog
    with TableInfo<$SyncOperationsLogTable, SyncOperationLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncOperationsLogTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _operationIdMeta = const VerificationMeta(
    'operationId',
  );
  @override
  late final GeneratedColumn<String> operationId = GeneratedColumn<String>(
    'operation_id',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(
      minTextLength: 36,
      maxTextLength: 36,
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(
      minTextLength: 1,
      maxTextLength: 50,
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityIdMeta = const VerificationMeta(
    'entityId',
  );
  @override
  late final GeneratedColumn<String> entityId = GeneratedColumn<String>(
    'entity_id',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(
      minTextLength: 1,
      maxTextLength: 255,
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _actionMeta = const VerificationMeta('action');
  @override
  late final GeneratedColumn<String> action = GeneratedColumn<String>(
    'action',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(
      minTextLength: 1,
      maxTextLength: 20,
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(
      minTextLength: 1,
      maxTextLength: 20,
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deviceIdMeta = const VerificationMeta(
    'deviceId',
  );
  @override
  late final GeneratedColumn<String> deviceId = GeneratedColumn<String>(
    'device_id',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(
      minTextLength: 1,
      maxTextLength: 255,
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _completedAtMeta = const VerificationMeta(
    'completedAt',
  );
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
    'completed_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _errorMessageMeta = const VerificationMeta(
    'errorMessage',
  );
  @override
  late final GeneratedColumn<String> errorMessage = GeneratedColumn<String>(
    'error_message',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _metadataMeta = const VerificationMeta(
    'metadata',
  );
  @override
  late final GeneratedColumn<String> metadata = GeneratedColumn<String>(
    'metadata',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    operationId,
    entityType,
    entityId,
    action,
    status,
    deviceId,
    timestamp,
    completedAt,
    errorMessage,
    metadata,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sync_operations_log';
  @override
  VerificationContext validateIntegrity(
    Insertable<SyncOperationLog> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('operation_id')) {
      context.handle(
        _operationIdMeta,
        operationId.isAcceptableOrUnknown(
          data['operation_id']!,
          _operationIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_operationIdMeta);
    }
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('entity_id')) {
      context.handle(
        _entityIdMeta,
        entityId.isAcceptableOrUnknown(data['entity_id']!, _entityIdMeta),
      );
    } else if (isInserting) {
      context.missing(_entityIdMeta);
    }
    if (data.containsKey('action')) {
      context.handle(
        _actionMeta,
        action.isAcceptableOrUnknown(data['action']!, _actionMeta),
      );
    } else if (isInserting) {
      context.missing(_actionMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('device_id')) {
      context.handle(
        _deviceIdMeta,
        deviceId.isAcceptableOrUnknown(data['device_id']!, _deviceIdMeta),
      );
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('completed_at')) {
      context.handle(
        _completedAtMeta,
        completedAt.isAcceptableOrUnknown(
          data['completed_at']!,
          _completedAtMeta,
        ),
      );
    }
    if (data.containsKey('error_message')) {
      context.handle(
        _errorMessageMeta,
        errorMessage.isAcceptableOrUnknown(
          data['error_message']!,
          _errorMessageMeta,
        ),
      );
    }
    if (data.containsKey('metadata')) {
      context.handle(
        _metadataMeta,
        metadata.isAcceptableOrUnknown(data['metadata']!, _metadataMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {operationId};
  @override
  SyncOperationLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SyncOperationLog(
      operationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation_id'],
      )!,
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      entityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_id'],
      )!,
      action: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}action'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      deviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}device_id'],
      ),
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
      completedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}completed_at'],
      ),
      errorMessage: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}error_message'],
      ),
      metadata: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}metadata'],
      ),
    );
  }

  @override
  $SyncOperationsLogTable createAlias(String alias) {
    return $SyncOperationsLogTable(attachedDatabase, alias);
  }
}

class SyncOperationLog extends DataClass
    implements Insertable<SyncOperationLog> {
  final String operationId;
  final String entityType;
  final String entityId;
  final String action;
  final String status;
  final String? deviceId;
  final DateTime timestamp;
  final DateTime? completedAt;
  final String? errorMessage;
  final String? metadata;
  const SyncOperationLog({
    required this.operationId,
    required this.entityType,
    required this.entityId,
    required this.action,
    required this.status,
    this.deviceId,
    required this.timestamp,
    this.completedAt,
    this.errorMessage,
    this.metadata,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['operation_id'] = Variable<String>(operationId);
    map['entity_type'] = Variable<String>(entityType);
    map['entity_id'] = Variable<String>(entityId);
    map['action'] = Variable<String>(action);
    map['status'] = Variable<String>(status);
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    map['timestamp'] = Variable<DateTime>(timestamp);
    if (!nullToAbsent || completedAt != null) {
      map['completed_at'] = Variable<DateTime>(completedAt);
    }
    if (!nullToAbsent || errorMessage != null) {
      map['error_message'] = Variable<String>(errorMessage);
    }
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(metadata);
    }
    return map;
  }

  SyncOperationsLogCompanion toCompanion(bool nullToAbsent) {
    return SyncOperationsLogCompanion(
      operationId: Value(operationId),
      entityType: Value(entityType),
      entityId: Value(entityId),
      action: Value(action),
      status: Value(status),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      timestamp: Value(timestamp),
      completedAt: completedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(completedAt),
      errorMessage: errorMessage == null && nullToAbsent
          ? const Value.absent()
          : Value(errorMessage),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
    );
  }

  factory SyncOperationLog.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SyncOperationLog(
      operationId: serializer.fromJson<String>(json['operationId']),
      entityType: serializer.fromJson<String>(json['entityType']),
      entityId: serializer.fromJson<String>(json['entityId']),
      action: serializer.fromJson<String>(json['action']),
      status: serializer.fromJson<String>(json['status']),
      deviceId: serializer.fromJson<String?>(json['deviceId']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      completedAt: serializer.fromJson<DateTime?>(json['completedAt']),
      errorMessage: serializer.fromJson<String?>(json['errorMessage']),
      metadata: serializer.fromJson<String?>(json['metadata']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'operationId': serializer.toJson<String>(operationId),
      'entityType': serializer.toJson<String>(entityType),
      'entityId': serializer.toJson<String>(entityId),
      'action': serializer.toJson<String>(action),
      'status': serializer.toJson<String>(status),
      'deviceId': serializer.toJson<String?>(deviceId),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'completedAt': serializer.toJson<DateTime?>(completedAt),
      'errorMessage': serializer.toJson<String?>(errorMessage),
      'metadata': serializer.toJson<String?>(metadata),
    };
  }

  SyncOperationLog copyWith({
    String? operationId,
    String? entityType,
    String? entityId,
    String? action,
    String? status,
    Value<String?> deviceId = const Value.absent(),
    DateTime? timestamp,
    Value<DateTime?> completedAt = const Value.absent(),
    Value<String?> errorMessage = const Value.absent(),
    Value<String?> metadata = const Value.absent(),
  }) => SyncOperationLog(
    operationId: operationId ?? this.operationId,
    entityType: entityType ?? this.entityType,
    entityId: entityId ?? this.entityId,
    action: action ?? this.action,
    status: status ?? this.status,
    deviceId: deviceId.present ? deviceId.value : this.deviceId,
    timestamp: timestamp ?? this.timestamp,
    completedAt: completedAt.present ? completedAt.value : this.completedAt,
    errorMessage: errorMessage.present ? errorMessage.value : this.errorMessage,
    metadata: metadata.present ? metadata.value : this.metadata,
  );
  SyncOperationLog copyWithCompanion(SyncOperationsLogCompanion data) {
    return SyncOperationLog(
      operationId: data.operationId.present
          ? data.operationId.value
          : this.operationId,
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      entityId: data.entityId.present ? data.entityId.value : this.entityId,
      action: data.action.present ? data.action.value : this.action,
      status: data.status.present ? data.status.value : this.status,
      deviceId: data.deviceId.present ? data.deviceId.value : this.deviceId,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      completedAt: data.completedAt.present
          ? data.completedAt.value
          : this.completedAt,
      errorMessage: data.errorMessage.present
          ? data.errorMessage.value
          : this.errorMessage,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SyncOperationLog(')
          ..write('operationId: $operationId, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('action: $action, ')
          ..write('status: $status, ')
          ..write('deviceId: $deviceId, ')
          ..write('timestamp: $timestamp, ')
          ..write('completedAt: $completedAt, ')
          ..write('errorMessage: $errorMessage, ')
          ..write('metadata: $metadata')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    operationId,
    entityType,
    entityId,
    action,
    status,
    deviceId,
    timestamp,
    completedAt,
    errorMessage,
    metadata,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SyncOperationLog &&
          other.operationId == this.operationId &&
          other.entityType == this.entityType &&
          other.entityId == this.entityId &&
          other.action == this.action &&
          other.status == this.status &&
          other.deviceId == this.deviceId &&
          other.timestamp == this.timestamp &&
          other.completedAt == this.completedAt &&
          other.errorMessage == this.errorMessage &&
          other.metadata == this.metadata);
}

class SyncOperationsLogCompanion extends UpdateCompanion<SyncOperationLog> {
  final Value<String> operationId;
  final Value<String> entityType;
  final Value<String> entityId;
  final Value<String> action;
  final Value<String> status;
  final Value<String?> deviceId;
  final Value<DateTime> timestamp;
  final Value<DateTime?> completedAt;
  final Value<String?> errorMessage;
  final Value<String?> metadata;
  final Value<int> rowid;
  const SyncOperationsLogCompanion({
    this.operationId = const Value.absent(),
    this.entityType = const Value.absent(),
    this.entityId = const Value.absent(),
    this.action = const Value.absent(),
    this.status = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.errorMessage = const Value.absent(),
    this.metadata = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SyncOperationsLogCompanion.insert({
    required String operationId,
    required String entityType,
    required String entityId,
    required String action,
    required String status,
    this.deviceId = const Value.absent(),
    required DateTime timestamp,
    this.completedAt = const Value.absent(),
    this.errorMessage = const Value.absent(),
    this.metadata = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : operationId = Value(operationId),
       entityType = Value(entityType),
       entityId = Value(entityId),
       action = Value(action),
       status = Value(status),
       timestamp = Value(timestamp);
  static Insertable<SyncOperationLog> custom({
    Expression<String>? operationId,
    Expression<String>? entityType,
    Expression<String>? entityId,
    Expression<String>? action,
    Expression<String>? status,
    Expression<String>? deviceId,
    Expression<DateTime>? timestamp,
    Expression<DateTime>? completedAt,
    Expression<String>? errorMessage,
    Expression<String>? metadata,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (operationId != null) 'operation_id': operationId,
      if (entityType != null) 'entity_type': entityType,
      if (entityId != null) 'entity_id': entityId,
      if (action != null) 'action': action,
      if (status != null) 'status': status,
      if (deviceId != null) 'device_id': deviceId,
      if (timestamp != null) 'timestamp': timestamp,
      if (completedAt != null) 'completed_at': completedAt,
      if (errorMessage != null) 'error_message': errorMessage,
      if (metadata != null) 'metadata': metadata,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SyncOperationsLogCompanion copyWith({
    Value<String>? operationId,
    Value<String>? entityType,
    Value<String>? entityId,
    Value<String>? action,
    Value<String>? status,
    Value<String?>? deviceId,
    Value<DateTime>? timestamp,
    Value<DateTime?>? completedAt,
    Value<String?>? errorMessage,
    Value<String?>? metadata,
    Value<int>? rowid,
  }) {
    return SyncOperationsLogCompanion(
      operationId: operationId ?? this.operationId,
      entityType: entityType ?? this.entityType,
      entityId: entityId ?? this.entityId,
      action: action ?? this.action,
      status: status ?? this.status,
      deviceId: deviceId ?? this.deviceId,
      timestamp: timestamp ?? this.timestamp,
      completedAt: completedAt ?? this.completedAt,
      errorMessage: errorMessage ?? this.errorMessage,
      metadata: metadata ?? this.metadata,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (operationId.present) {
      map['operation_id'] = Variable<String>(operationId.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (entityId.present) {
      map['entity_id'] = Variable<String>(entityId.value);
    }
    if (action.present) {
      map['action'] = Variable<String>(action.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (errorMessage.present) {
      map['error_message'] = Variable<String>(errorMessage.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(metadata.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncOperationsLogCompanion(')
          ..write('operationId: $operationId, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('action: $action, ')
          ..write('status: $status, ')
          ..write('deviceId: $deviceId, ')
          ..write('timestamp: $timestamp, ')
          ..write('completedAt: $completedAt, ')
          ..write('errorMessage: $errorMessage, ')
          ..write('metadata: $metadata, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SyncStateTransitionsTable extends SyncStateTransitions
    with TableInfo<$SyncStateTransitionsTable, SyncStateTransition> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SyncStateTransitionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _fromStateMeta = const VerificationMeta(
    'fromState',
  );
  @override
  late final GeneratedColumn<String> fromState = GeneratedColumn<String>(
    'from_state',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(
      minTextLength: 1,
      maxTextLength: 50,
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _toStateMeta = const VerificationMeta(
    'toState',
  );
  @override
  late final GeneratedColumn<String> toState = GeneratedColumn<String>(
    'to_state',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(
      minTextLength: 1,
      maxTextLength: 50,
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _reasonMeta = const VerificationMeta('reason');
  @override
  late final GeneratedColumn<String> reason = GeneratedColumn<String>(
    'reason',
    aliasedName,
    false,
    additionalChecks: GeneratedColumn.checkTextLength(
      minTextLength: 1,
      maxTextLength: 255,
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sessionIdMeta = const VerificationMeta(
    'sessionId',
  );
  @override
  late final GeneratedColumn<String> sessionId = GeneratedColumn<String>(
    'session_id',
    aliasedName,
    true,
    additionalChecks: GeneratedColumn.checkTextLength(
      minTextLength: 1,
      maxTextLength: 36,
    ),
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _contextMeta = const VerificationMeta(
    'context',
  );
  @override
  late final GeneratedColumn<String> context = GeneratedColumn<String>(
    'context',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    fromState,
    toState,
    reason,
    sessionId,
    timestamp,
    context,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'sync_state_transitions';
  @override
  VerificationContext validateIntegrity(
    Insertable<SyncStateTransition> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('from_state')) {
      context.handle(
        _fromStateMeta,
        fromState.isAcceptableOrUnknown(data['from_state']!, _fromStateMeta),
      );
    } else if (isInserting) {
      context.missing(_fromStateMeta);
    }
    if (data.containsKey('to_state')) {
      context.handle(
        _toStateMeta,
        toState.isAcceptableOrUnknown(data['to_state']!, _toStateMeta),
      );
    } else if (isInserting) {
      context.missing(_toStateMeta);
    }
    if (data.containsKey('reason')) {
      context.handle(
        _reasonMeta,
        reason.isAcceptableOrUnknown(data['reason']!, _reasonMeta),
      );
    } else if (isInserting) {
      context.missing(_reasonMeta);
    }
    if (data.containsKey('session_id')) {
      context.handle(
        _sessionIdMeta,
        sessionId.isAcceptableOrUnknown(data['session_id']!, _sessionIdMeta),
      );
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    } else if (isInserting) {
      context.missing(_timestampMeta);
    }
    if (data.containsKey('context')) {
      context.handle(
        _contextMeta,
        this.context.isAcceptableOrUnknown(data['context']!, _contextMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SyncStateTransition map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SyncStateTransition(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      fromState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}from_state'],
      )!,
      toState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}to_state'],
      )!,
      reason: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}reason'],
      )!,
      sessionId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}session_id'],
      ),
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
      context: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}context'],
      ),
    );
  }

  @override
  $SyncStateTransitionsTable createAlias(String alias) {
    return $SyncStateTransitionsTable(attachedDatabase, alias);
  }
}

class SyncStateTransition extends DataClass
    implements Insertable<SyncStateTransition> {
  final int id;
  final String fromState;
  final String toState;
  final String reason;
  final String? sessionId;
  final DateTime timestamp;
  final String? context;
  const SyncStateTransition({
    required this.id,
    required this.fromState,
    required this.toState,
    required this.reason,
    this.sessionId,
    required this.timestamp,
    this.context,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['from_state'] = Variable<String>(fromState);
    map['to_state'] = Variable<String>(toState);
    map['reason'] = Variable<String>(reason);
    if (!nullToAbsent || sessionId != null) {
      map['session_id'] = Variable<String>(sessionId);
    }
    map['timestamp'] = Variable<DateTime>(timestamp);
    if (!nullToAbsent || context != null) {
      map['context'] = Variable<String>(context);
    }
    return map;
  }

  SyncStateTransitionsCompanion toCompanion(bool nullToAbsent) {
    return SyncStateTransitionsCompanion(
      id: Value(id),
      fromState: Value(fromState),
      toState: Value(toState),
      reason: Value(reason),
      sessionId: sessionId == null && nullToAbsent
          ? const Value.absent()
          : Value(sessionId),
      timestamp: Value(timestamp),
      context: context == null && nullToAbsent
          ? const Value.absent()
          : Value(context),
    );
  }

  factory SyncStateTransition.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SyncStateTransition(
      id: serializer.fromJson<int>(json['id']),
      fromState: serializer.fromJson<String>(json['fromState']),
      toState: serializer.fromJson<String>(json['toState']),
      reason: serializer.fromJson<String>(json['reason']),
      sessionId: serializer.fromJson<String?>(json['sessionId']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      context: serializer.fromJson<String?>(json['context']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'fromState': serializer.toJson<String>(fromState),
      'toState': serializer.toJson<String>(toState),
      'reason': serializer.toJson<String>(reason),
      'sessionId': serializer.toJson<String?>(sessionId),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'context': serializer.toJson<String?>(context),
    };
  }

  SyncStateTransition copyWith({
    int? id,
    String? fromState,
    String? toState,
    String? reason,
    Value<String?> sessionId = const Value.absent(),
    DateTime? timestamp,
    Value<String?> context = const Value.absent(),
  }) => SyncStateTransition(
    id: id ?? this.id,
    fromState: fromState ?? this.fromState,
    toState: toState ?? this.toState,
    reason: reason ?? this.reason,
    sessionId: sessionId.present ? sessionId.value : this.sessionId,
    timestamp: timestamp ?? this.timestamp,
    context: context.present ? context.value : this.context,
  );
  SyncStateTransition copyWithCompanion(SyncStateTransitionsCompanion data) {
    return SyncStateTransition(
      id: data.id.present ? data.id.value : this.id,
      fromState: data.fromState.present ? data.fromState.value : this.fromState,
      toState: data.toState.present ? data.toState.value : this.toState,
      reason: data.reason.present ? data.reason.value : this.reason,
      sessionId: data.sessionId.present ? data.sessionId.value : this.sessionId,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      context: data.context.present ? data.context.value : this.context,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SyncStateTransition(')
          ..write('id: $id, ')
          ..write('fromState: $fromState, ')
          ..write('toState: $toState, ')
          ..write('reason: $reason, ')
          ..write('sessionId: $sessionId, ')
          ..write('timestamp: $timestamp, ')
          ..write('context: $context')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    fromState,
    toState,
    reason,
    sessionId,
    timestamp,
    context,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SyncStateTransition &&
          other.id == this.id &&
          other.fromState == this.fromState &&
          other.toState == this.toState &&
          other.reason == this.reason &&
          other.sessionId == this.sessionId &&
          other.timestamp == this.timestamp &&
          other.context == this.context);
}

class SyncStateTransitionsCompanion
    extends UpdateCompanion<SyncStateTransition> {
  final Value<int> id;
  final Value<String> fromState;
  final Value<String> toState;
  final Value<String> reason;
  final Value<String?> sessionId;
  final Value<DateTime> timestamp;
  final Value<String?> context;
  const SyncStateTransitionsCompanion({
    this.id = const Value.absent(),
    this.fromState = const Value.absent(),
    this.toState = const Value.absent(),
    this.reason = const Value.absent(),
    this.sessionId = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.context = const Value.absent(),
  });
  SyncStateTransitionsCompanion.insert({
    this.id = const Value.absent(),
    required String fromState,
    required String toState,
    required String reason,
    this.sessionId = const Value.absent(),
    required DateTime timestamp,
    this.context = const Value.absent(),
  }) : fromState = Value(fromState),
       toState = Value(toState),
       reason = Value(reason),
       timestamp = Value(timestamp);
  static Insertable<SyncStateTransition> custom({
    Expression<int>? id,
    Expression<String>? fromState,
    Expression<String>? toState,
    Expression<String>? reason,
    Expression<String>? sessionId,
    Expression<DateTime>? timestamp,
    Expression<String>? context,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (fromState != null) 'from_state': fromState,
      if (toState != null) 'to_state': toState,
      if (reason != null) 'reason': reason,
      if (sessionId != null) 'session_id': sessionId,
      if (timestamp != null) 'timestamp': timestamp,
      if (context != null) 'context': context,
    });
  }

  SyncStateTransitionsCompanion copyWith({
    Value<int>? id,
    Value<String>? fromState,
    Value<String>? toState,
    Value<String>? reason,
    Value<String?>? sessionId,
    Value<DateTime>? timestamp,
    Value<String?>? context,
  }) {
    return SyncStateTransitionsCompanion(
      id: id ?? this.id,
      fromState: fromState ?? this.fromState,
      toState: toState ?? this.toState,
      reason: reason ?? this.reason,
      sessionId: sessionId ?? this.sessionId,
      timestamp: timestamp ?? this.timestamp,
      context: context ?? this.context,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (fromState.present) {
      map['from_state'] = Variable<String>(fromState.value);
    }
    if (toState.present) {
      map['to_state'] = Variable<String>(toState.value);
    }
    if (reason.present) {
      map['reason'] = Variable<String>(reason.value);
    }
    if (sessionId.present) {
      map['session_id'] = Variable<String>(sessionId.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (context.present) {
      map['context'] = Variable<String>(context.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SyncStateTransitionsCompanion(')
          ..write('id: $id, ')
          ..write('fromState: $fromState, ')
          ..write('toState: $toState, ')
          ..write('reason: $reason, ')
          ..write('sessionId: $sessionId, ')
          ..write('timestamp: $timestamp, ')
          ..write('context: $context')
          ..write(')'))
        .toString();
  }
}

class $FamilyGroupsTable extends FamilyGroups
    with TableInfo<$FamilyGroupsTable, FamilyGroup> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FamilyGroupsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _ownerIdMeta = const VerificationMeta(
    'ownerId',
  );
  @override
  late final GeneratedColumn<String> ownerId = GeneratedColumn<String>(
    'owner_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id) ON DELETE CASCADE',
    ),
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata =
      GeneratedColumn<String>(
        'metadata',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Map<String, dynamic>?>(
        $FamilyGroupsTable.$convertermetadatan,
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    name,
    ownerId,
    metadata,
    createdAt,
    updatedAt,
    revision,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'family_groups';
  @override
  VerificationContext validateIntegrity(
    Insertable<FamilyGroup> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('owner_id')) {
      context.handle(
        _ownerIdMeta,
        ownerId.isAcceptableOrUnknown(data['owner_id']!, _ownerIdMeta),
      );
    } else if (isInserting) {
      context.missing(_ownerIdMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FamilyGroup map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FamilyGroup(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      ownerId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}owner_id'],
      )!,
      metadata: $FamilyGroupsTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $FamilyGroupsTable createAlias(String alias) {
    return $FamilyGroupsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class FamilyGroup extends DataClass implements Insertable<FamilyGroup> {
  final String id;
  final String name;
  final String ownerId;
  final Map<String, dynamic>? metadata;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final String syncState;
  final bool isDeleted;
  final int lamportClock;
  final String? versionVector;
  const FamilyGroup({
    required this.id,
    required this.name,
    required this.ownerId,
    this.metadata,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    required this.syncState,
    required this.isDeleted,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['name'] = Variable<String>(name);
    map['owner_id'] = Variable<String>(ownerId);
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $FamilyGroupsTable.$convertermetadatan.toSql(metadata),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    map['sync_state'] = Variable<String>(syncState);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  FamilyGroupsCompanion toCompanion(bool nullToAbsent) {
    return FamilyGroupsCompanion(
      id: Value(id),
      name: Value(name),
      ownerId: Value(ownerId),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      syncState: Value(syncState),
      isDeleted: Value(isDeleted),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory FamilyGroup.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FamilyGroup(
      id: serializer.fromJson<String>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      ownerId: serializer.fromJson<String>(json['ownerId']),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      syncState: serializer.fromJson<String>(json['syncState']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'name': serializer.toJson<String>(name),
      'ownerId': serializer.toJson<String>(ownerId),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'syncState': serializer.toJson<String>(syncState),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  FamilyGroup copyWith({
    String? id,
    String? name,
    String? ownerId,
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    String? syncState,
    bool? isDeleted,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => FamilyGroup(
    id: id ?? this.id,
    name: name ?? this.name,
    ownerId: ownerId ?? this.ownerId,
    metadata: metadata.present ? metadata.value : this.metadata,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    syncState: syncState ?? this.syncState,
    isDeleted: isDeleted ?? this.isDeleted,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  FamilyGroup copyWithCompanion(FamilyGroupsCompanion data) {
    return FamilyGroup(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      ownerId: data.ownerId.present ? data.ownerId.value : this.ownerId,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FamilyGroup(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('ownerId: $ownerId, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    name,
    ownerId,
    metadata,
    createdAt,
    updatedAt,
    revision,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FamilyGroup &&
          other.id == this.id &&
          other.name == this.name &&
          other.ownerId == this.ownerId &&
          other.metadata == this.metadata &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.syncState == this.syncState &&
          other.isDeleted == this.isDeleted &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class FamilyGroupsCompanion extends UpdateCompanion<FamilyGroup> {
  final Value<String> id;
  final Value<String> name;
  final Value<String> ownerId;
  final Value<Map<String, dynamic>?> metadata;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<String> syncState;
  final Value<bool> isDeleted;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const FamilyGroupsCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.ownerId = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FamilyGroupsCompanion.insert({
    required String id,
    required String name,
    required String ownerId,
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name),
       ownerId = Value(ownerId);
  static Insertable<FamilyGroup> custom({
    Expression<String>? id,
    Expression<String>? name,
    Expression<String>? ownerId,
    Expression<String>? metadata,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<String>? syncState,
    Expression<bool>? isDeleted,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (ownerId != null) 'owner_id': ownerId,
      if (metadata != null) 'metadata': metadata,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (syncState != null) 'sync_state': syncState,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FamilyGroupsCompanion copyWith({
    Value<String>? id,
    Value<String>? name,
    Value<String>? ownerId,
    Value<Map<String, dynamic>?>? metadata,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<String>? syncState,
    Value<bool>? isDeleted,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return FamilyGroupsCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      ownerId: ownerId ?? this.ownerId,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      syncState: syncState ?? this.syncState,
      isDeleted: isDeleted ?? this.isDeleted,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (ownerId.present) {
      map['owner_id'] = Variable<String>(ownerId.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $FamilyGroupsTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FamilyGroupsCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('ownerId: $ownerId, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FamilyContactsTable extends FamilyContacts
    with TableInfo<$FamilyContactsTable, FamilyContact> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FamilyContactsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _deviceContactIdMeta = const VerificationMeta(
    'deviceContactId',
  );
  @override
  late final GeneratedColumn<String> deviceContactId = GeneratedColumn<String>(
    'device_contact_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _emailMeta = const VerificationMeta('email');
  @override
  late final GeneratedColumn<String> email = GeneratedColumn<String>(
    'email',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _phoneMeta = const VerificationMeta('phone');
  @override
  late final GeneratedColumn<String> phone = GeneratedColumn<String>(
    'phone',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _avatarUrlMeta = const VerificationMeta(
    'avatarUrl',
  );
  @override
  late final GeneratedColumn<String> avatarUrl = GeneratedColumn<String>(
    'avatar_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _isLinkedToUserMeta = const VerificationMeta(
    'isLinkedToUser',
  );
  @override
  late final GeneratedColumn<bool> isLinkedToUser = GeneratedColumn<bool>(
    'is_linked_to_user',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_linked_to_user" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _linkedUserIdMeta = const VerificationMeta(
    'linkedUserId',
  );
  @override
  late final GeneratedColumn<String> linkedUserId = GeneratedColumn<String>(
    'linked_user_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id) ON DELETE SET NULL',
    ),
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata =
      GeneratedColumn<String>(
        'metadata',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Map<String, dynamic>?>(
        $FamilyContactsTable.$convertermetadatan,
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    deviceContactId,
    name,
    email,
    phone,
    avatarUrl,
    isLinkedToUser,
    linkedUserId,
    metadata,
    createdAt,
    updatedAt,
    revision,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'family_contacts';
  @override
  VerificationContext validateIntegrity(
    Insertable<FamilyContact> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('device_contact_id')) {
      context.handle(
        _deviceContactIdMeta,
        deviceContactId.isAcceptableOrUnknown(
          data['device_contact_id']!,
          _deviceContactIdMeta,
        ),
      );
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('email')) {
      context.handle(
        _emailMeta,
        email.isAcceptableOrUnknown(data['email']!, _emailMeta),
      );
    }
    if (data.containsKey('phone')) {
      context.handle(
        _phoneMeta,
        phone.isAcceptableOrUnknown(data['phone']!, _phoneMeta),
      );
    }
    if (data.containsKey('avatar_url')) {
      context.handle(
        _avatarUrlMeta,
        avatarUrl.isAcceptableOrUnknown(data['avatar_url']!, _avatarUrlMeta),
      );
    }
    if (data.containsKey('is_linked_to_user')) {
      context.handle(
        _isLinkedToUserMeta,
        isLinkedToUser.isAcceptableOrUnknown(
          data['is_linked_to_user']!,
          _isLinkedToUserMeta,
        ),
      );
    }
    if (data.containsKey('linked_user_id')) {
      context.handle(
        _linkedUserIdMeta,
        linkedUserId.isAcceptableOrUnknown(
          data['linked_user_id']!,
          _linkedUserIdMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FamilyContact map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FamilyContact(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      deviceContactId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}device_contact_id'],
      ),
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      email: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}email'],
      ),
      phone: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}phone'],
      ),
      avatarUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}avatar_url'],
      ),
      isLinkedToUser: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_linked_to_user'],
      )!,
      linkedUserId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}linked_user_id'],
      ),
      metadata: $FamilyContactsTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $FamilyContactsTable createAlias(String alias) {
    return $FamilyContactsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class FamilyContact extends DataClass implements Insertable<FamilyContact> {
  final String id;
  final String? deviceContactId;
  final String name;
  final String? email;
  final String? phone;
  final String? avatarUrl;
  final bool isLinkedToUser;
  final String? linkedUserId;
  final Map<String, dynamic>? metadata;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final String syncState;
  final bool isDeleted;
  final int lamportClock;
  final String? versionVector;
  const FamilyContact({
    required this.id,
    this.deviceContactId,
    required this.name,
    this.email,
    this.phone,
    this.avatarUrl,
    required this.isLinkedToUser,
    this.linkedUserId,
    this.metadata,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    required this.syncState,
    required this.isDeleted,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    if (!nullToAbsent || deviceContactId != null) {
      map['device_contact_id'] = Variable<String>(deviceContactId);
    }
    map['name'] = Variable<String>(name);
    if (!nullToAbsent || email != null) {
      map['email'] = Variable<String>(email);
    }
    if (!nullToAbsent || phone != null) {
      map['phone'] = Variable<String>(phone);
    }
    if (!nullToAbsent || avatarUrl != null) {
      map['avatar_url'] = Variable<String>(avatarUrl);
    }
    map['is_linked_to_user'] = Variable<bool>(isLinkedToUser);
    if (!nullToAbsent || linkedUserId != null) {
      map['linked_user_id'] = Variable<String>(linkedUserId);
    }
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $FamilyContactsTable.$convertermetadatan.toSql(metadata),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    map['sync_state'] = Variable<String>(syncState);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  FamilyContactsCompanion toCompanion(bool nullToAbsent) {
    return FamilyContactsCompanion(
      id: Value(id),
      deviceContactId: deviceContactId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceContactId),
      name: Value(name),
      email: email == null && nullToAbsent
          ? const Value.absent()
          : Value(email),
      phone: phone == null && nullToAbsent
          ? const Value.absent()
          : Value(phone),
      avatarUrl: avatarUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(avatarUrl),
      isLinkedToUser: Value(isLinkedToUser),
      linkedUserId: linkedUserId == null && nullToAbsent
          ? const Value.absent()
          : Value(linkedUserId),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      syncState: Value(syncState),
      isDeleted: Value(isDeleted),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory FamilyContact.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FamilyContact(
      id: serializer.fromJson<String>(json['id']),
      deviceContactId: serializer.fromJson<String?>(json['deviceContactId']),
      name: serializer.fromJson<String>(json['name']),
      email: serializer.fromJson<String?>(json['email']),
      phone: serializer.fromJson<String?>(json['phone']),
      avatarUrl: serializer.fromJson<String?>(json['avatarUrl']),
      isLinkedToUser: serializer.fromJson<bool>(json['isLinkedToUser']),
      linkedUserId: serializer.fromJson<String?>(json['linkedUserId']),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      syncState: serializer.fromJson<String>(json['syncState']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'deviceContactId': serializer.toJson<String?>(deviceContactId),
      'name': serializer.toJson<String>(name),
      'email': serializer.toJson<String?>(email),
      'phone': serializer.toJson<String?>(phone),
      'avatarUrl': serializer.toJson<String?>(avatarUrl),
      'isLinkedToUser': serializer.toJson<bool>(isLinkedToUser),
      'linkedUserId': serializer.toJson<String?>(linkedUserId),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'syncState': serializer.toJson<String>(syncState),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  FamilyContact copyWith({
    String? id,
    Value<String?> deviceContactId = const Value.absent(),
    String? name,
    Value<String?> email = const Value.absent(),
    Value<String?> phone = const Value.absent(),
    Value<String?> avatarUrl = const Value.absent(),
    bool? isLinkedToUser,
    Value<String?> linkedUserId = const Value.absent(),
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    String? syncState,
    bool? isDeleted,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => FamilyContact(
    id: id ?? this.id,
    deviceContactId: deviceContactId.present
        ? deviceContactId.value
        : this.deviceContactId,
    name: name ?? this.name,
    email: email.present ? email.value : this.email,
    phone: phone.present ? phone.value : this.phone,
    avatarUrl: avatarUrl.present ? avatarUrl.value : this.avatarUrl,
    isLinkedToUser: isLinkedToUser ?? this.isLinkedToUser,
    linkedUserId: linkedUserId.present ? linkedUserId.value : this.linkedUserId,
    metadata: metadata.present ? metadata.value : this.metadata,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    syncState: syncState ?? this.syncState,
    isDeleted: isDeleted ?? this.isDeleted,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  FamilyContact copyWithCompanion(FamilyContactsCompanion data) {
    return FamilyContact(
      id: data.id.present ? data.id.value : this.id,
      deviceContactId: data.deviceContactId.present
          ? data.deviceContactId.value
          : this.deviceContactId,
      name: data.name.present ? data.name.value : this.name,
      email: data.email.present ? data.email.value : this.email,
      phone: data.phone.present ? data.phone.value : this.phone,
      avatarUrl: data.avatarUrl.present ? data.avatarUrl.value : this.avatarUrl,
      isLinkedToUser: data.isLinkedToUser.present
          ? data.isLinkedToUser.value
          : this.isLinkedToUser,
      linkedUserId: data.linkedUserId.present
          ? data.linkedUserId.value
          : this.linkedUserId,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FamilyContact(')
          ..write('id: $id, ')
          ..write('deviceContactId: $deviceContactId, ')
          ..write('name: $name, ')
          ..write('email: $email, ')
          ..write('phone: $phone, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('isLinkedToUser: $isLinkedToUser, ')
          ..write('linkedUserId: $linkedUserId, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    deviceContactId,
    name,
    email,
    phone,
    avatarUrl,
    isLinkedToUser,
    linkedUserId,
    metadata,
    createdAt,
    updatedAt,
    revision,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FamilyContact &&
          other.id == this.id &&
          other.deviceContactId == this.deviceContactId &&
          other.name == this.name &&
          other.email == this.email &&
          other.phone == this.phone &&
          other.avatarUrl == this.avatarUrl &&
          other.isLinkedToUser == this.isLinkedToUser &&
          other.linkedUserId == this.linkedUserId &&
          other.metadata == this.metadata &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.syncState == this.syncState &&
          other.isDeleted == this.isDeleted &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class FamilyContactsCompanion extends UpdateCompanion<FamilyContact> {
  final Value<String> id;
  final Value<String?> deviceContactId;
  final Value<String> name;
  final Value<String?> email;
  final Value<String?> phone;
  final Value<String?> avatarUrl;
  final Value<bool> isLinkedToUser;
  final Value<String?> linkedUserId;
  final Value<Map<String, dynamic>?> metadata;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<String> syncState;
  final Value<bool> isDeleted;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const FamilyContactsCompanion({
    this.id = const Value.absent(),
    this.deviceContactId = const Value.absent(),
    this.name = const Value.absent(),
    this.email = const Value.absent(),
    this.phone = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.isLinkedToUser = const Value.absent(),
    this.linkedUserId = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FamilyContactsCompanion.insert({
    required String id,
    this.deviceContactId = const Value.absent(),
    required String name,
    this.email = const Value.absent(),
    this.phone = const Value.absent(),
    this.avatarUrl = const Value.absent(),
    this.isLinkedToUser = const Value.absent(),
    this.linkedUserId = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       name = Value(name);
  static Insertable<FamilyContact> custom({
    Expression<String>? id,
    Expression<String>? deviceContactId,
    Expression<String>? name,
    Expression<String>? email,
    Expression<String>? phone,
    Expression<String>? avatarUrl,
    Expression<bool>? isLinkedToUser,
    Expression<String>? linkedUserId,
    Expression<String>? metadata,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<String>? syncState,
    Expression<bool>? isDeleted,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (deviceContactId != null) 'device_contact_id': deviceContactId,
      if (name != null) 'name': name,
      if (email != null) 'email': email,
      if (phone != null) 'phone': phone,
      if (avatarUrl != null) 'avatar_url': avatarUrl,
      if (isLinkedToUser != null) 'is_linked_to_user': isLinkedToUser,
      if (linkedUserId != null) 'linked_user_id': linkedUserId,
      if (metadata != null) 'metadata': metadata,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (syncState != null) 'sync_state': syncState,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FamilyContactsCompanion copyWith({
    Value<String>? id,
    Value<String?>? deviceContactId,
    Value<String>? name,
    Value<String?>? email,
    Value<String?>? phone,
    Value<String?>? avatarUrl,
    Value<bool>? isLinkedToUser,
    Value<String?>? linkedUserId,
    Value<Map<String, dynamic>?>? metadata,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<String>? syncState,
    Value<bool>? isDeleted,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return FamilyContactsCompanion(
      id: id ?? this.id,
      deviceContactId: deviceContactId ?? this.deviceContactId,
      name: name ?? this.name,
      email: email ?? this.email,
      phone: phone ?? this.phone,
      avatarUrl: avatarUrl ?? this.avatarUrl,
      isLinkedToUser: isLinkedToUser ?? this.isLinkedToUser,
      linkedUserId: linkedUserId ?? this.linkedUserId,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      syncState: syncState ?? this.syncState,
      isDeleted: isDeleted ?? this.isDeleted,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (deviceContactId.present) {
      map['device_contact_id'] = Variable<String>(deviceContactId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (email.present) {
      map['email'] = Variable<String>(email.value);
    }
    if (phone.present) {
      map['phone'] = Variable<String>(phone.value);
    }
    if (avatarUrl.present) {
      map['avatar_url'] = Variable<String>(avatarUrl.value);
    }
    if (isLinkedToUser.present) {
      map['is_linked_to_user'] = Variable<bool>(isLinkedToUser.value);
    }
    if (linkedUserId.present) {
      map['linked_user_id'] = Variable<String>(linkedUserId.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $FamilyContactsTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FamilyContactsCompanion(')
          ..write('id: $id, ')
          ..write('deviceContactId: $deviceContactId, ')
          ..write('name: $name, ')
          ..write('email: $email, ')
          ..write('phone: $phone, ')
          ..write('avatarUrl: $avatarUrl, ')
          ..write('isLinkedToUser: $isLinkedToUser, ')
          ..write('linkedUserId: $linkedUserId, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FamilyRelationsTable extends FamilyRelations
    with TableInfo<$FamilyRelationsTable, FamilyRelation> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FamilyRelationsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _fromContactIdMeta = const VerificationMeta(
    'fromContactId',
  );
  @override
  late final GeneratedColumn<String> fromContactId = GeneratedColumn<String>(
    'from_contact_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES family_contacts (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _toContactIdMeta = const VerificationMeta(
    'toContactId',
  );
  @override
  late final GeneratedColumn<String> toContactId = GeneratedColumn<String>(
    'to_contact_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES family_contacts (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _relationshipTypeMeta = const VerificationMeta(
    'relationshipType',
  );
  @override
  late final GeneratedColumn<String> relationshipType = GeneratedColumn<String>(
    'relationship_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _confidenceMeta = const VerificationMeta(
    'confidence',
  );
  @override
  late final GeneratedColumn<double> confidence = GeneratedColumn<double>(
    'confidence',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
    defaultValue: const Constant(1.0),
  );
  static const VerificationMeta _inferredByMeta = const VerificationMeta(
    'inferredBy',
  );
  @override
  late final GeneratedColumn<String> inferredBy = GeneratedColumn<String>(
    'inferred_by',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('manual'),
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata =
      GeneratedColumn<String>(
        'metadata',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      ).withConverter<Map<String, dynamic>?>(
        $FamilyRelationsTable.$convertermetadatan,
      );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    fromContactId,
    toContactId,
    relationshipType,
    confidence,
    inferredBy,
    metadata,
    createdAt,
    updatedAt,
    revision,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'family_relations';
  @override
  VerificationContext validateIntegrity(
    Insertable<FamilyRelation> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('from_contact_id')) {
      context.handle(
        _fromContactIdMeta,
        fromContactId.isAcceptableOrUnknown(
          data['from_contact_id']!,
          _fromContactIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_fromContactIdMeta);
    }
    if (data.containsKey('to_contact_id')) {
      context.handle(
        _toContactIdMeta,
        toContactId.isAcceptableOrUnknown(
          data['to_contact_id']!,
          _toContactIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_toContactIdMeta);
    }
    if (data.containsKey('relationship_type')) {
      context.handle(
        _relationshipTypeMeta,
        relationshipType.isAcceptableOrUnknown(
          data['relationship_type']!,
          _relationshipTypeMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_relationshipTypeMeta);
    }
    if (data.containsKey('confidence')) {
      context.handle(
        _confidenceMeta,
        confidence.isAcceptableOrUnknown(data['confidence']!, _confidenceMeta),
      );
    }
    if (data.containsKey('inferred_by')) {
      context.handle(
        _inferredByMeta,
        inferredBy.isAcceptableOrUnknown(data['inferred_by']!, _inferredByMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FamilyRelation map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FamilyRelation(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      fromContactId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}from_contact_id'],
      )!,
      toContactId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}to_contact_id'],
      )!,
      relationshipType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}relationship_type'],
      )!,
      confidence: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}confidence'],
      )!,
      inferredBy: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}inferred_by'],
      )!,
      metadata: $FamilyRelationsTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $FamilyRelationsTable createAlias(String alias) {
    return $FamilyRelationsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class FamilyRelation extends DataClass implements Insertable<FamilyRelation> {
  final String id;
  final String fromContactId;
  final String toContactId;
  final String relationshipType;
  final double confidence;
  final String inferredBy;
  final Map<String, dynamic>? metadata;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final String syncState;
  final bool isDeleted;
  final int lamportClock;
  final String? versionVector;
  const FamilyRelation({
    required this.id,
    required this.fromContactId,
    required this.toContactId,
    required this.relationshipType,
    required this.confidence,
    required this.inferredBy,
    this.metadata,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    required this.syncState,
    required this.isDeleted,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['from_contact_id'] = Variable<String>(fromContactId);
    map['to_contact_id'] = Variable<String>(toContactId);
    map['relationship_type'] = Variable<String>(relationshipType);
    map['confidence'] = Variable<double>(confidence);
    map['inferred_by'] = Variable<String>(inferredBy);
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $FamilyRelationsTable.$convertermetadatan.toSql(metadata),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    map['sync_state'] = Variable<String>(syncState);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  FamilyRelationsCompanion toCompanion(bool nullToAbsent) {
    return FamilyRelationsCompanion(
      id: Value(id),
      fromContactId: Value(fromContactId),
      toContactId: Value(toContactId),
      relationshipType: Value(relationshipType),
      confidence: Value(confidence),
      inferredBy: Value(inferredBy),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      syncState: Value(syncState),
      isDeleted: Value(isDeleted),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory FamilyRelation.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FamilyRelation(
      id: serializer.fromJson<String>(json['id']),
      fromContactId: serializer.fromJson<String>(json['fromContactId']),
      toContactId: serializer.fromJson<String>(json['toContactId']),
      relationshipType: serializer.fromJson<String>(json['relationshipType']),
      confidence: serializer.fromJson<double>(json['confidence']),
      inferredBy: serializer.fromJson<String>(json['inferredBy']),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      syncState: serializer.fromJson<String>(json['syncState']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'fromContactId': serializer.toJson<String>(fromContactId),
      'toContactId': serializer.toJson<String>(toContactId),
      'relationshipType': serializer.toJson<String>(relationshipType),
      'confidence': serializer.toJson<double>(confidence),
      'inferredBy': serializer.toJson<String>(inferredBy),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'syncState': serializer.toJson<String>(syncState),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  FamilyRelation copyWith({
    String? id,
    String? fromContactId,
    String? toContactId,
    String? relationshipType,
    double? confidence,
    String? inferredBy,
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    String? syncState,
    bool? isDeleted,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => FamilyRelation(
    id: id ?? this.id,
    fromContactId: fromContactId ?? this.fromContactId,
    toContactId: toContactId ?? this.toContactId,
    relationshipType: relationshipType ?? this.relationshipType,
    confidence: confidence ?? this.confidence,
    inferredBy: inferredBy ?? this.inferredBy,
    metadata: metadata.present ? metadata.value : this.metadata,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    syncState: syncState ?? this.syncState,
    isDeleted: isDeleted ?? this.isDeleted,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  FamilyRelation copyWithCompanion(FamilyRelationsCompanion data) {
    return FamilyRelation(
      id: data.id.present ? data.id.value : this.id,
      fromContactId: data.fromContactId.present
          ? data.fromContactId.value
          : this.fromContactId,
      toContactId: data.toContactId.present
          ? data.toContactId.value
          : this.toContactId,
      relationshipType: data.relationshipType.present
          ? data.relationshipType.value
          : this.relationshipType,
      confidence: data.confidence.present
          ? data.confidence.value
          : this.confidence,
      inferredBy: data.inferredBy.present
          ? data.inferredBy.value
          : this.inferredBy,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FamilyRelation(')
          ..write('id: $id, ')
          ..write('fromContactId: $fromContactId, ')
          ..write('toContactId: $toContactId, ')
          ..write('relationshipType: $relationshipType, ')
          ..write('confidence: $confidence, ')
          ..write('inferredBy: $inferredBy, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    fromContactId,
    toContactId,
    relationshipType,
    confidence,
    inferredBy,
    metadata,
    createdAt,
    updatedAt,
    revision,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FamilyRelation &&
          other.id == this.id &&
          other.fromContactId == this.fromContactId &&
          other.toContactId == this.toContactId &&
          other.relationshipType == this.relationshipType &&
          other.confidence == this.confidence &&
          other.inferredBy == this.inferredBy &&
          other.metadata == this.metadata &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.syncState == this.syncState &&
          other.isDeleted == this.isDeleted &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class FamilyRelationsCompanion extends UpdateCompanion<FamilyRelation> {
  final Value<String> id;
  final Value<String> fromContactId;
  final Value<String> toContactId;
  final Value<String> relationshipType;
  final Value<double> confidence;
  final Value<String> inferredBy;
  final Value<Map<String, dynamic>?> metadata;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<String> syncState;
  final Value<bool> isDeleted;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const FamilyRelationsCompanion({
    this.id = const Value.absent(),
    this.fromContactId = const Value.absent(),
    this.toContactId = const Value.absent(),
    this.relationshipType = const Value.absent(),
    this.confidence = const Value.absent(),
    this.inferredBy = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FamilyRelationsCompanion.insert({
    required String id,
    required String fromContactId,
    required String toContactId,
    required String relationshipType,
    this.confidence = const Value.absent(),
    this.inferredBy = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       fromContactId = Value(fromContactId),
       toContactId = Value(toContactId),
       relationshipType = Value(relationshipType);
  static Insertable<FamilyRelation> custom({
    Expression<String>? id,
    Expression<String>? fromContactId,
    Expression<String>? toContactId,
    Expression<String>? relationshipType,
    Expression<double>? confidence,
    Expression<String>? inferredBy,
    Expression<String>? metadata,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<String>? syncState,
    Expression<bool>? isDeleted,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (fromContactId != null) 'from_contact_id': fromContactId,
      if (toContactId != null) 'to_contact_id': toContactId,
      if (relationshipType != null) 'relationship_type': relationshipType,
      if (confidence != null) 'confidence': confidence,
      if (inferredBy != null) 'inferred_by': inferredBy,
      if (metadata != null) 'metadata': metadata,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (syncState != null) 'sync_state': syncState,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FamilyRelationsCompanion copyWith({
    Value<String>? id,
    Value<String>? fromContactId,
    Value<String>? toContactId,
    Value<String>? relationshipType,
    Value<double>? confidence,
    Value<String>? inferredBy,
    Value<Map<String, dynamic>?>? metadata,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<String>? syncState,
    Value<bool>? isDeleted,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return FamilyRelationsCompanion(
      id: id ?? this.id,
      fromContactId: fromContactId ?? this.fromContactId,
      toContactId: toContactId ?? this.toContactId,
      relationshipType: relationshipType ?? this.relationshipType,
      confidence: confidence ?? this.confidence,
      inferredBy: inferredBy ?? this.inferredBy,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      syncState: syncState ?? this.syncState,
      isDeleted: isDeleted ?? this.isDeleted,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (fromContactId.present) {
      map['from_contact_id'] = Variable<String>(fromContactId.value);
    }
    if (toContactId.present) {
      map['to_contact_id'] = Variable<String>(toContactId.value);
    }
    if (relationshipType.present) {
      map['relationship_type'] = Variable<String>(relationshipType.value);
    }
    if (confidence.present) {
      map['confidence'] = Variable<double>(confidence.value);
    }
    if (inferredBy.present) {
      map['inferred_by'] = Variable<String>(inferredBy.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $FamilyRelationsTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FamilyRelationsCompanion(')
          ..write('id: $id, ')
          ..write('fromContactId: $fromContactId, ')
          ..write('toContactId: $toContactId, ')
          ..write('relationshipType: $relationshipType, ')
          ..write('confidence: $confidence, ')
          ..write('inferredBy: $inferredBy, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $KnowledgeArticlesTable extends KnowledgeArticles
    with TableInfo<$KnowledgeArticlesTable, KnowledgeArticleData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $KnowledgeArticlesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _summaryMeta = const VerificationMeta(
    'summary',
  );
  @override
  late final GeneratedColumn<String> summary = GeneratedColumn<String>(
    'summary',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _contentMeta = const VerificationMeta(
    'content',
  );
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
    'content',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _topicMeta = const VerificationMeta('topic');
  @override
  late final GeneratedColumn<String> topic = GeneratedColumn<String>(
    'topic',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _tagsMeta = const VerificationMeta('tags');
  @override
  late final GeneratedColumn<String> tags = GeneratedColumn<String>(
    'tags',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _imageUrlMeta = const VerificationMeta(
    'imageUrl',
  );
  @override
  late final GeneratedColumn<String> imageUrl = GeneratedColumn<String>(
    'image_url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _readTimeMinutesMeta = const VerificationMeta(
    'readTimeMinutes',
  );
  @override
  late final GeneratedColumn<int> readTimeMinutes = GeneratedColumn<int>(
    'read_time_minutes',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _languageCodeMeta = const VerificationMeta(
    'languageCode',
  );
  @override
  late final GeneratedColumn<String> languageCode = GeneratedColumn<String>(
    'language_code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('en'),
  );
  static const VerificationMeta _isPremiumMeta = const VerificationMeta(
    'isPremium',
  );
  @override
  late final GeneratedColumn<bool> isPremium = GeneratedColumn<bool>(
    'is_premium',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_premium" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _publishedAtMeta = const VerificationMeta(
    'publishedAt',
  );
  @override
  late final GeneratedColumn<DateTime> publishedAt = GeneratedColumn<DateTime>(
    'published_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _baseRevisionMeta = const VerificationMeta(
    'baseRevision',
  );
  @override
  late final GeneratedColumn<int> baseRevision = GeneratedColumn<int>(
    'base_revision',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _operationIdMeta = const VerificationMeta(
    'operationId',
  );
  @override
  late final GeneratedColumn<String> operationId = GeneratedColumn<String>(
    'operation_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastModifiedByDeviceIdMeta =
      const VerificationMeta('lastModifiedByDeviceId');
  @override
  late final GeneratedColumn<String> lastModifiedByDeviceId =
      GeneratedColumn<String>(
        'last_modified_by_device_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    title,
    summary,
    content,
    topic,
    tags,
    imageUrl,
    readTimeMinutes,
    languageCode,
    isPremium,
    publishedAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'knowledge_articles';
  @override
  VerificationContext validateIntegrity(
    Insertable<KnowledgeArticleData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('summary')) {
      context.handle(
        _summaryMeta,
        summary.isAcceptableOrUnknown(data['summary']!, _summaryMeta),
      );
    } else if (isInserting) {
      context.missing(_summaryMeta);
    }
    if (data.containsKey('content')) {
      context.handle(
        _contentMeta,
        content.isAcceptableOrUnknown(data['content']!, _contentMeta),
      );
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('topic')) {
      context.handle(
        _topicMeta,
        topic.isAcceptableOrUnknown(data['topic']!, _topicMeta),
      );
    } else if (isInserting) {
      context.missing(_topicMeta);
    }
    if (data.containsKey('tags')) {
      context.handle(
        _tagsMeta,
        tags.isAcceptableOrUnknown(data['tags']!, _tagsMeta),
      );
    }
    if (data.containsKey('image_url')) {
      context.handle(
        _imageUrlMeta,
        imageUrl.isAcceptableOrUnknown(data['image_url']!, _imageUrlMeta),
      );
    }
    if (data.containsKey('read_time_minutes')) {
      context.handle(
        _readTimeMinutesMeta,
        readTimeMinutes.isAcceptableOrUnknown(
          data['read_time_minutes']!,
          _readTimeMinutesMeta,
        ),
      );
    }
    if (data.containsKey('language_code')) {
      context.handle(
        _languageCodeMeta,
        languageCode.isAcceptableOrUnknown(
          data['language_code']!,
          _languageCodeMeta,
        ),
      );
    }
    if (data.containsKey('is_premium')) {
      context.handle(
        _isPremiumMeta,
        isPremium.isAcceptableOrUnknown(data['is_premium']!, _isPremiumMeta),
      );
    }
    if (data.containsKey('published_at')) {
      context.handle(
        _publishedAtMeta,
        publishedAt.isAcceptableOrUnknown(
          data['published_at']!,
          _publishedAtMeta,
        ),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('base_revision')) {
      context.handle(
        _baseRevisionMeta,
        baseRevision.isAcceptableOrUnknown(
          data['base_revision']!,
          _baseRevisionMeta,
        ),
      );
    }
    if (data.containsKey('operation_id')) {
      context.handle(
        _operationIdMeta,
        operationId.isAcceptableOrUnknown(
          data['operation_id']!,
          _operationIdMeta,
        ),
      );
    }
    if (data.containsKey('last_modified_by_device_id')) {
      context.handle(
        _lastModifiedByDeviceIdMeta,
        lastModifiedByDeviceId.isAcceptableOrUnknown(
          data['last_modified_by_device_id']!,
          _lastModifiedByDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  KnowledgeArticleData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return KnowledgeArticleData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      summary: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}summary'],
      )!,
      content: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}content'],
      )!,
      topic: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}topic'],
      )!,
      tags: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}tags'],
      ),
      imageUrl: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_url'],
      ),
      readTimeMinutes: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}read_time_minutes'],
      )!,
      languageCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}language_code'],
      )!,
      isPremium: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_premium'],
      )!,
      publishedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}published_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      baseRevision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}base_revision'],
      ),
      operationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation_id'],
      ),
      lastModifiedByDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_modified_by_device_id'],
      ),
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $KnowledgeArticlesTable createAlias(String alias) {
    return $KnowledgeArticlesTable(attachedDatabase, alias);
  }
}

class KnowledgeArticleData extends DataClass
    implements Insertable<KnowledgeArticleData> {
  final String id;
  final String title;
  final String summary;
  final String content;
  final String topic;
  final String? tags;
  final String? imageUrl;
  final int readTimeMinutes;
  final String languageCode;
  final bool isPremium;
  final DateTime publishedAt;
  final DateTime updatedAt;
  final int revision;
  final int? baseRevision;
  final String? operationId;
  final String? lastModifiedByDeviceId;
  final String syncState;
  final bool isDeleted;
  final int lamportClock;
  final String? versionVector;
  const KnowledgeArticleData({
    required this.id,
    required this.title,
    required this.summary,
    required this.content,
    required this.topic,
    this.tags,
    this.imageUrl,
    required this.readTimeMinutes,
    required this.languageCode,
    required this.isPremium,
    required this.publishedAt,
    required this.updatedAt,
    required this.revision,
    this.baseRevision,
    this.operationId,
    this.lastModifiedByDeviceId,
    required this.syncState,
    required this.isDeleted,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['title'] = Variable<String>(title);
    map['summary'] = Variable<String>(summary);
    map['content'] = Variable<String>(content);
    map['topic'] = Variable<String>(topic);
    if (!nullToAbsent || tags != null) {
      map['tags'] = Variable<String>(tags);
    }
    if (!nullToAbsent || imageUrl != null) {
      map['image_url'] = Variable<String>(imageUrl);
    }
    map['read_time_minutes'] = Variable<int>(readTimeMinutes);
    map['language_code'] = Variable<String>(languageCode);
    map['is_premium'] = Variable<bool>(isPremium);
    map['published_at'] = Variable<DateTime>(publishedAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    if (!nullToAbsent || baseRevision != null) {
      map['base_revision'] = Variable<int>(baseRevision);
    }
    if (!nullToAbsent || operationId != null) {
      map['operation_id'] = Variable<String>(operationId);
    }
    if (!nullToAbsent || lastModifiedByDeviceId != null) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId,
      );
    }
    map['sync_state'] = Variable<String>(syncState);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  KnowledgeArticlesCompanion toCompanion(bool nullToAbsent) {
    return KnowledgeArticlesCompanion(
      id: Value(id),
      title: Value(title),
      summary: Value(summary),
      content: Value(content),
      topic: Value(topic),
      tags: tags == null && nullToAbsent ? const Value.absent() : Value(tags),
      imageUrl: imageUrl == null && nullToAbsent
          ? const Value.absent()
          : Value(imageUrl),
      readTimeMinutes: Value(readTimeMinutes),
      languageCode: Value(languageCode),
      isPremium: Value(isPremium),
      publishedAt: Value(publishedAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      baseRevision: baseRevision == null && nullToAbsent
          ? const Value.absent()
          : Value(baseRevision),
      operationId: operationId == null && nullToAbsent
          ? const Value.absent()
          : Value(operationId),
      lastModifiedByDeviceId: lastModifiedByDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedByDeviceId),
      syncState: Value(syncState),
      isDeleted: Value(isDeleted),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory KnowledgeArticleData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return KnowledgeArticleData(
      id: serializer.fromJson<String>(json['id']),
      title: serializer.fromJson<String>(json['title']),
      summary: serializer.fromJson<String>(json['summary']),
      content: serializer.fromJson<String>(json['content']),
      topic: serializer.fromJson<String>(json['topic']),
      tags: serializer.fromJson<String?>(json['tags']),
      imageUrl: serializer.fromJson<String?>(json['imageUrl']),
      readTimeMinutes: serializer.fromJson<int>(json['readTimeMinutes']),
      languageCode: serializer.fromJson<String>(json['languageCode']),
      isPremium: serializer.fromJson<bool>(json['isPremium']),
      publishedAt: serializer.fromJson<DateTime>(json['publishedAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      baseRevision: serializer.fromJson<int?>(json['baseRevision']),
      operationId: serializer.fromJson<String?>(json['operationId']),
      lastModifiedByDeviceId: serializer.fromJson<String?>(
        json['lastModifiedByDeviceId'],
      ),
      syncState: serializer.fromJson<String>(json['syncState']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'title': serializer.toJson<String>(title),
      'summary': serializer.toJson<String>(summary),
      'content': serializer.toJson<String>(content),
      'topic': serializer.toJson<String>(topic),
      'tags': serializer.toJson<String?>(tags),
      'imageUrl': serializer.toJson<String?>(imageUrl),
      'readTimeMinutes': serializer.toJson<int>(readTimeMinutes),
      'languageCode': serializer.toJson<String>(languageCode),
      'isPremium': serializer.toJson<bool>(isPremium),
      'publishedAt': serializer.toJson<DateTime>(publishedAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'baseRevision': serializer.toJson<int?>(baseRevision),
      'operationId': serializer.toJson<String?>(operationId),
      'lastModifiedByDeviceId': serializer.toJson<String?>(
        lastModifiedByDeviceId,
      ),
      'syncState': serializer.toJson<String>(syncState),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  KnowledgeArticleData copyWith({
    String? id,
    String? title,
    String? summary,
    String? content,
    String? topic,
    Value<String?> tags = const Value.absent(),
    Value<String?> imageUrl = const Value.absent(),
    int? readTimeMinutes,
    String? languageCode,
    bool? isPremium,
    DateTime? publishedAt,
    DateTime? updatedAt,
    int? revision,
    Value<int?> baseRevision = const Value.absent(),
    Value<String?> operationId = const Value.absent(),
    Value<String?> lastModifiedByDeviceId = const Value.absent(),
    String? syncState,
    bool? isDeleted,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => KnowledgeArticleData(
    id: id ?? this.id,
    title: title ?? this.title,
    summary: summary ?? this.summary,
    content: content ?? this.content,
    topic: topic ?? this.topic,
    tags: tags.present ? tags.value : this.tags,
    imageUrl: imageUrl.present ? imageUrl.value : this.imageUrl,
    readTimeMinutes: readTimeMinutes ?? this.readTimeMinutes,
    languageCode: languageCode ?? this.languageCode,
    isPremium: isPremium ?? this.isPremium,
    publishedAt: publishedAt ?? this.publishedAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    baseRevision: baseRevision.present ? baseRevision.value : this.baseRevision,
    operationId: operationId.present ? operationId.value : this.operationId,
    lastModifiedByDeviceId: lastModifiedByDeviceId.present
        ? lastModifiedByDeviceId.value
        : this.lastModifiedByDeviceId,
    syncState: syncState ?? this.syncState,
    isDeleted: isDeleted ?? this.isDeleted,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  KnowledgeArticleData copyWithCompanion(KnowledgeArticlesCompanion data) {
    return KnowledgeArticleData(
      id: data.id.present ? data.id.value : this.id,
      title: data.title.present ? data.title.value : this.title,
      summary: data.summary.present ? data.summary.value : this.summary,
      content: data.content.present ? data.content.value : this.content,
      topic: data.topic.present ? data.topic.value : this.topic,
      tags: data.tags.present ? data.tags.value : this.tags,
      imageUrl: data.imageUrl.present ? data.imageUrl.value : this.imageUrl,
      readTimeMinutes: data.readTimeMinutes.present
          ? data.readTimeMinutes.value
          : this.readTimeMinutes,
      languageCode: data.languageCode.present
          ? data.languageCode.value
          : this.languageCode,
      isPremium: data.isPremium.present ? data.isPremium.value : this.isPremium,
      publishedAt: data.publishedAt.present
          ? data.publishedAt.value
          : this.publishedAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      baseRevision: data.baseRevision.present
          ? data.baseRevision.value
          : this.baseRevision,
      operationId: data.operationId.present
          ? data.operationId.value
          : this.operationId,
      lastModifiedByDeviceId: data.lastModifiedByDeviceId.present
          ? data.lastModifiedByDeviceId.value
          : this.lastModifiedByDeviceId,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('KnowledgeArticleData(')
          ..write('id: $id, ')
          ..write('title: $title, ')
          ..write('summary: $summary, ')
          ..write('content: $content, ')
          ..write('topic: $topic, ')
          ..write('tags: $tags, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('readTimeMinutes: $readTimeMinutes, ')
          ..write('languageCode: $languageCode, ')
          ..write('isPremium: $isPremium, ')
          ..write('publishedAt: $publishedAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    title,
    summary,
    content,
    topic,
    tags,
    imageUrl,
    readTimeMinutes,
    languageCode,
    isPremium,
    publishedAt,
    updatedAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is KnowledgeArticleData &&
          other.id == this.id &&
          other.title == this.title &&
          other.summary == this.summary &&
          other.content == this.content &&
          other.topic == this.topic &&
          other.tags == this.tags &&
          other.imageUrl == this.imageUrl &&
          other.readTimeMinutes == this.readTimeMinutes &&
          other.languageCode == this.languageCode &&
          other.isPremium == this.isPremium &&
          other.publishedAt == this.publishedAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.baseRevision == this.baseRevision &&
          other.operationId == this.operationId &&
          other.lastModifiedByDeviceId == this.lastModifiedByDeviceId &&
          other.syncState == this.syncState &&
          other.isDeleted == this.isDeleted &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class KnowledgeArticlesCompanion extends UpdateCompanion<KnowledgeArticleData> {
  final Value<String> id;
  final Value<String> title;
  final Value<String> summary;
  final Value<String> content;
  final Value<String> topic;
  final Value<String?> tags;
  final Value<String?> imageUrl;
  final Value<int> readTimeMinutes;
  final Value<String> languageCode;
  final Value<bool> isPremium;
  final Value<DateTime> publishedAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<int?> baseRevision;
  final Value<String?> operationId;
  final Value<String?> lastModifiedByDeviceId;
  final Value<String> syncState;
  final Value<bool> isDeleted;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const KnowledgeArticlesCompanion({
    this.id = const Value.absent(),
    this.title = const Value.absent(),
    this.summary = const Value.absent(),
    this.content = const Value.absent(),
    this.topic = const Value.absent(),
    this.tags = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.readTimeMinutes = const Value.absent(),
    this.languageCode = const Value.absent(),
    this.isPremium = const Value.absent(),
    this.publishedAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  KnowledgeArticlesCompanion.insert({
    required String id,
    required String title,
    required String summary,
    required String content,
    required String topic,
    this.tags = const Value.absent(),
    this.imageUrl = const Value.absent(),
    this.readTimeMinutes = const Value.absent(),
    this.languageCode = const Value.absent(),
    this.isPremium = const Value.absent(),
    this.publishedAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       title = Value(title),
       summary = Value(summary),
       content = Value(content),
       topic = Value(topic);
  static Insertable<KnowledgeArticleData> custom({
    Expression<String>? id,
    Expression<String>? title,
    Expression<String>? summary,
    Expression<String>? content,
    Expression<String>? topic,
    Expression<String>? tags,
    Expression<String>? imageUrl,
    Expression<int>? readTimeMinutes,
    Expression<String>? languageCode,
    Expression<bool>? isPremium,
    Expression<DateTime>? publishedAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<int>? baseRevision,
    Expression<String>? operationId,
    Expression<String>? lastModifiedByDeviceId,
    Expression<String>? syncState,
    Expression<bool>? isDeleted,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (title != null) 'title': title,
      if (summary != null) 'summary': summary,
      if (content != null) 'content': content,
      if (topic != null) 'topic': topic,
      if (tags != null) 'tags': tags,
      if (imageUrl != null) 'image_url': imageUrl,
      if (readTimeMinutes != null) 'read_time_minutes': readTimeMinutes,
      if (languageCode != null) 'language_code': languageCode,
      if (isPremium != null) 'is_premium': isPremium,
      if (publishedAt != null) 'published_at': publishedAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (baseRevision != null) 'base_revision': baseRevision,
      if (operationId != null) 'operation_id': operationId,
      if (lastModifiedByDeviceId != null)
        'last_modified_by_device_id': lastModifiedByDeviceId,
      if (syncState != null) 'sync_state': syncState,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  KnowledgeArticlesCompanion copyWith({
    Value<String>? id,
    Value<String>? title,
    Value<String>? summary,
    Value<String>? content,
    Value<String>? topic,
    Value<String?>? tags,
    Value<String?>? imageUrl,
    Value<int>? readTimeMinutes,
    Value<String>? languageCode,
    Value<bool>? isPremium,
    Value<DateTime>? publishedAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<int?>? baseRevision,
    Value<String?>? operationId,
    Value<String?>? lastModifiedByDeviceId,
    Value<String>? syncState,
    Value<bool>? isDeleted,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return KnowledgeArticlesCompanion(
      id: id ?? this.id,
      title: title ?? this.title,
      summary: summary ?? this.summary,
      content: content ?? this.content,
      topic: topic ?? this.topic,
      tags: tags ?? this.tags,
      imageUrl: imageUrl ?? this.imageUrl,
      readTimeMinutes: readTimeMinutes ?? this.readTimeMinutes,
      languageCode: languageCode ?? this.languageCode,
      isPremium: isPremium ?? this.isPremium,
      publishedAt: publishedAt ?? this.publishedAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      baseRevision: baseRevision ?? this.baseRevision,
      operationId: operationId ?? this.operationId,
      lastModifiedByDeviceId:
          lastModifiedByDeviceId ?? this.lastModifiedByDeviceId,
      syncState: syncState ?? this.syncState,
      isDeleted: isDeleted ?? this.isDeleted,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (summary.present) {
      map['summary'] = Variable<String>(summary.value);
    }
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (topic.present) {
      map['topic'] = Variable<String>(topic.value);
    }
    if (tags.present) {
      map['tags'] = Variable<String>(tags.value);
    }
    if (imageUrl.present) {
      map['image_url'] = Variable<String>(imageUrl.value);
    }
    if (readTimeMinutes.present) {
      map['read_time_minutes'] = Variable<int>(readTimeMinutes.value);
    }
    if (languageCode.present) {
      map['language_code'] = Variable<String>(languageCode.value);
    }
    if (isPremium.present) {
      map['is_premium'] = Variable<bool>(isPremium.value);
    }
    if (publishedAt.present) {
      map['published_at'] = Variable<DateTime>(publishedAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (baseRevision.present) {
      map['base_revision'] = Variable<int>(baseRevision.value);
    }
    if (operationId.present) {
      map['operation_id'] = Variable<String>(operationId.value);
    }
    if (lastModifiedByDeviceId.present) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId.value,
      );
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('KnowledgeArticlesCompanion(')
          ..write('id: $id, ')
          ..write('title: $title, ')
          ..write('summary: $summary, ')
          ..write('content: $content, ')
          ..write('topic: $topic, ')
          ..write('tags: $tags, ')
          ..write('imageUrl: $imageUrl, ')
          ..write('readTimeMinutes: $readTimeMinutes, ')
          ..write('languageCode: $languageCode, ')
          ..write('isPremium: $isPremium, ')
          ..write('publishedAt: $publishedAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FinancialTipsTable extends FinancialTips
    with TableInfo<$FinancialTipsTable, FinancialTipData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FinancialTipsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _titleMeta = const VerificationMeta('title');
  @override
  late final GeneratedColumn<String> title = GeneratedColumn<String>(
    'title',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _contentMeta = const VerificationMeta(
    'content',
  );
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
    'content',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _categoryMeta = const VerificationMeta(
    'category',
  );
  @override
  late final GeneratedColumn<String> category = GeneratedColumn<String>(
    'category',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _actionLabelMeta = const VerificationMeta(
    'actionLabel',
  );
  @override
  late final GeneratedColumn<String> actionLabel = GeneratedColumn<String>(
    'action_label',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _actionRouteMeta = const VerificationMeta(
    'actionRoute',
  );
  @override
  late final GeneratedColumn<String> actionRoute = GeneratedColumn<String>(
    'action_route',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _languageCodeMeta = const VerificationMeta(
    'languageCode',
  );
  @override
  late final GeneratedColumn<String> languageCode = GeneratedColumn<String>(
    'language_code',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('en'),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
    'expires_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _baseRevisionMeta = const VerificationMeta(
    'baseRevision',
  );
  @override
  late final GeneratedColumn<int> baseRevision = GeneratedColumn<int>(
    'base_revision',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _operationIdMeta = const VerificationMeta(
    'operationId',
  );
  @override
  late final GeneratedColumn<String> operationId = GeneratedColumn<String>(
    'operation_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _lastModifiedByDeviceIdMeta =
      const VerificationMeta('lastModifiedByDeviceId');
  @override
  late final GeneratedColumn<String> lastModifiedByDeviceId =
      GeneratedColumn<String>(
        'last_modified_by_device_id',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    title,
    content,
    category,
    type,
    actionLabel,
    actionRoute,
    languageCode,
    createdAt,
    expiresAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'financial_tips';
  @override
  VerificationContext validateIntegrity(
    Insertable<FinancialTipData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('title')) {
      context.handle(
        _titleMeta,
        title.isAcceptableOrUnknown(data['title']!, _titleMeta),
      );
    } else if (isInserting) {
      context.missing(_titleMeta);
    }
    if (data.containsKey('content')) {
      context.handle(
        _contentMeta,
        content.isAcceptableOrUnknown(data['content']!, _contentMeta),
      );
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('category')) {
      context.handle(
        _categoryMeta,
        category.isAcceptableOrUnknown(data['category']!, _categoryMeta),
      );
    } else if (isInserting) {
      context.missing(_categoryMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('action_label')) {
      context.handle(
        _actionLabelMeta,
        actionLabel.isAcceptableOrUnknown(
          data['action_label']!,
          _actionLabelMeta,
        ),
      );
    }
    if (data.containsKey('action_route')) {
      context.handle(
        _actionRouteMeta,
        actionRoute.isAcceptableOrUnknown(
          data['action_route']!,
          _actionRouteMeta,
        ),
      );
    }
    if (data.containsKey('language_code')) {
      context.handle(
        _languageCodeMeta,
        languageCode.isAcceptableOrUnknown(
          data['language_code']!,
          _languageCodeMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('base_revision')) {
      context.handle(
        _baseRevisionMeta,
        baseRevision.isAcceptableOrUnknown(
          data['base_revision']!,
          _baseRevisionMeta,
        ),
      );
    }
    if (data.containsKey('operation_id')) {
      context.handle(
        _operationIdMeta,
        operationId.isAcceptableOrUnknown(
          data['operation_id']!,
          _operationIdMeta,
        ),
      );
    }
    if (data.containsKey('last_modified_by_device_id')) {
      context.handle(
        _lastModifiedByDeviceIdMeta,
        lastModifiedByDeviceId.isAcceptableOrUnknown(
          data['last_modified_by_device_id']!,
          _lastModifiedByDeviceIdMeta,
        ),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FinancialTipData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FinancialTipData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      title: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}title'],
      )!,
      content: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}content'],
      )!,
      category: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}category'],
      )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      actionLabel: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}action_label'],
      ),
      actionRoute: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}action_route'],
      ),
      languageCode: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}language_code'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expires_at'],
      ),
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      baseRevision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}base_revision'],
      ),
      operationId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}operation_id'],
      ),
      lastModifiedByDeviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}last_modified_by_device_id'],
      ),
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $FinancialTipsTable createAlias(String alias) {
    return $FinancialTipsTable(attachedDatabase, alias);
  }
}

class FinancialTipData extends DataClass
    implements Insertable<FinancialTipData> {
  final String id;
  final String title;
  final String content;
  final String category;
  final String type;
  final String? actionLabel;
  final String? actionRoute;
  final String languageCode;
  final DateTime createdAt;
  final DateTime? expiresAt;
  final int revision;
  final int? baseRevision;
  final String? operationId;
  final String? lastModifiedByDeviceId;
  final String syncState;
  final bool isDeleted;
  final int lamportClock;
  final String? versionVector;
  const FinancialTipData({
    required this.id,
    required this.title,
    required this.content,
    required this.category,
    required this.type,
    this.actionLabel,
    this.actionRoute,
    required this.languageCode,
    required this.createdAt,
    this.expiresAt,
    required this.revision,
    this.baseRevision,
    this.operationId,
    this.lastModifiedByDeviceId,
    required this.syncState,
    required this.isDeleted,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['title'] = Variable<String>(title);
    map['content'] = Variable<String>(content);
    map['category'] = Variable<String>(category);
    map['type'] = Variable<String>(type);
    if (!nullToAbsent || actionLabel != null) {
      map['action_label'] = Variable<String>(actionLabel);
    }
    if (!nullToAbsent || actionRoute != null) {
      map['action_route'] = Variable<String>(actionRoute);
    }
    map['language_code'] = Variable<String>(languageCode);
    map['created_at'] = Variable<DateTime>(createdAt);
    if (!nullToAbsent || expiresAt != null) {
      map['expires_at'] = Variable<DateTime>(expiresAt);
    }
    map['revision'] = Variable<int>(revision);
    if (!nullToAbsent || baseRevision != null) {
      map['base_revision'] = Variable<int>(baseRevision);
    }
    if (!nullToAbsent || operationId != null) {
      map['operation_id'] = Variable<String>(operationId);
    }
    if (!nullToAbsent || lastModifiedByDeviceId != null) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId,
      );
    }
    map['sync_state'] = Variable<String>(syncState);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  FinancialTipsCompanion toCompanion(bool nullToAbsent) {
    return FinancialTipsCompanion(
      id: Value(id),
      title: Value(title),
      content: Value(content),
      category: Value(category),
      type: Value(type),
      actionLabel: actionLabel == null && nullToAbsent
          ? const Value.absent()
          : Value(actionLabel),
      actionRoute: actionRoute == null && nullToAbsent
          ? const Value.absent()
          : Value(actionRoute),
      languageCode: Value(languageCode),
      createdAt: Value(createdAt),
      expiresAt: expiresAt == null && nullToAbsent
          ? const Value.absent()
          : Value(expiresAt),
      revision: Value(revision),
      baseRevision: baseRevision == null && nullToAbsent
          ? const Value.absent()
          : Value(baseRevision),
      operationId: operationId == null && nullToAbsent
          ? const Value.absent()
          : Value(operationId),
      lastModifiedByDeviceId: lastModifiedByDeviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(lastModifiedByDeviceId),
      syncState: Value(syncState),
      isDeleted: Value(isDeleted),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory FinancialTipData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FinancialTipData(
      id: serializer.fromJson<String>(json['id']),
      title: serializer.fromJson<String>(json['title']),
      content: serializer.fromJson<String>(json['content']),
      category: serializer.fromJson<String>(json['category']),
      type: serializer.fromJson<String>(json['type']),
      actionLabel: serializer.fromJson<String?>(json['actionLabel']),
      actionRoute: serializer.fromJson<String?>(json['actionRoute']),
      languageCode: serializer.fromJson<String>(json['languageCode']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      expiresAt: serializer.fromJson<DateTime?>(json['expiresAt']),
      revision: serializer.fromJson<int>(json['revision']),
      baseRevision: serializer.fromJson<int?>(json['baseRevision']),
      operationId: serializer.fromJson<String?>(json['operationId']),
      lastModifiedByDeviceId: serializer.fromJson<String?>(
        json['lastModifiedByDeviceId'],
      ),
      syncState: serializer.fromJson<String>(json['syncState']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'title': serializer.toJson<String>(title),
      'content': serializer.toJson<String>(content),
      'category': serializer.toJson<String>(category),
      'type': serializer.toJson<String>(type),
      'actionLabel': serializer.toJson<String?>(actionLabel),
      'actionRoute': serializer.toJson<String?>(actionRoute),
      'languageCode': serializer.toJson<String>(languageCode),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'expiresAt': serializer.toJson<DateTime?>(expiresAt),
      'revision': serializer.toJson<int>(revision),
      'baseRevision': serializer.toJson<int?>(baseRevision),
      'operationId': serializer.toJson<String?>(operationId),
      'lastModifiedByDeviceId': serializer.toJson<String?>(
        lastModifiedByDeviceId,
      ),
      'syncState': serializer.toJson<String>(syncState),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  FinancialTipData copyWith({
    String? id,
    String? title,
    String? content,
    String? category,
    String? type,
    Value<String?> actionLabel = const Value.absent(),
    Value<String?> actionRoute = const Value.absent(),
    String? languageCode,
    DateTime? createdAt,
    Value<DateTime?> expiresAt = const Value.absent(),
    int? revision,
    Value<int?> baseRevision = const Value.absent(),
    Value<String?> operationId = const Value.absent(),
    Value<String?> lastModifiedByDeviceId = const Value.absent(),
    String? syncState,
    bool? isDeleted,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => FinancialTipData(
    id: id ?? this.id,
    title: title ?? this.title,
    content: content ?? this.content,
    category: category ?? this.category,
    type: type ?? this.type,
    actionLabel: actionLabel.present ? actionLabel.value : this.actionLabel,
    actionRoute: actionRoute.present ? actionRoute.value : this.actionRoute,
    languageCode: languageCode ?? this.languageCode,
    createdAt: createdAt ?? this.createdAt,
    expiresAt: expiresAt.present ? expiresAt.value : this.expiresAt,
    revision: revision ?? this.revision,
    baseRevision: baseRevision.present ? baseRevision.value : this.baseRevision,
    operationId: operationId.present ? operationId.value : this.operationId,
    lastModifiedByDeviceId: lastModifiedByDeviceId.present
        ? lastModifiedByDeviceId.value
        : this.lastModifiedByDeviceId,
    syncState: syncState ?? this.syncState,
    isDeleted: isDeleted ?? this.isDeleted,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  FinancialTipData copyWithCompanion(FinancialTipsCompanion data) {
    return FinancialTipData(
      id: data.id.present ? data.id.value : this.id,
      title: data.title.present ? data.title.value : this.title,
      content: data.content.present ? data.content.value : this.content,
      category: data.category.present ? data.category.value : this.category,
      type: data.type.present ? data.type.value : this.type,
      actionLabel: data.actionLabel.present
          ? data.actionLabel.value
          : this.actionLabel,
      actionRoute: data.actionRoute.present
          ? data.actionRoute.value
          : this.actionRoute,
      languageCode: data.languageCode.present
          ? data.languageCode.value
          : this.languageCode,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      baseRevision: data.baseRevision.present
          ? data.baseRevision.value
          : this.baseRevision,
      operationId: data.operationId.present
          ? data.operationId.value
          : this.operationId,
      lastModifiedByDeviceId: data.lastModifiedByDeviceId.present
          ? data.lastModifiedByDeviceId.value
          : this.lastModifiedByDeviceId,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FinancialTipData(')
          ..write('id: $id, ')
          ..write('title: $title, ')
          ..write('content: $content, ')
          ..write('category: $category, ')
          ..write('type: $type, ')
          ..write('actionLabel: $actionLabel, ')
          ..write('actionRoute: $actionRoute, ')
          ..write('languageCode: $languageCode, ')
          ..write('createdAt: $createdAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    title,
    content,
    category,
    type,
    actionLabel,
    actionRoute,
    languageCode,
    createdAt,
    expiresAt,
    revision,
    baseRevision,
    operationId,
    lastModifiedByDeviceId,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FinancialTipData &&
          other.id == this.id &&
          other.title == this.title &&
          other.content == this.content &&
          other.category == this.category &&
          other.type == this.type &&
          other.actionLabel == this.actionLabel &&
          other.actionRoute == this.actionRoute &&
          other.languageCode == this.languageCode &&
          other.createdAt == this.createdAt &&
          other.expiresAt == this.expiresAt &&
          other.revision == this.revision &&
          other.baseRevision == this.baseRevision &&
          other.operationId == this.operationId &&
          other.lastModifiedByDeviceId == this.lastModifiedByDeviceId &&
          other.syncState == this.syncState &&
          other.isDeleted == this.isDeleted &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class FinancialTipsCompanion extends UpdateCompanion<FinancialTipData> {
  final Value<String> id;
  final Value<String> title;
  final Value<String> content;
  final Value<String> category;
  final Value<String> type;
  final Value<String?> actionLabel;
  final Value<String?> actionRoute;
  final Value<String> languageCode;
  final Value<DateTime> createdAt;
  final Value<DateTime?> expiresAt;
  final Value<int> revision;
  final Value<int?> baseRevision;
  final Value<String?> operationId;
  final Value<String?> lastModifiedByDeviceId;
  final Value<String> syncState;
  final Value<bool> isDeleted;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const FinancialTipsCompanion({
    this.id = const Value.absent(),
    this.title = const Value.absent(),
    this.content = const Value.absent(),
    this.category = const Value.absent(),
    this.type = const Value.absent(),
    this.actionLabel = const Value.absent(),
    this.actionRoute = const Value.absent(),
    this.languageCode = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FinancialTipsCompanion.insert({
    required String id,
    required String title,
    required String content,
    required String category,
    required String type,
    this.actionLabel = const Value.absent(),
    this.actionRoute = const Value.absent(),
    this.languageCode = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.baseRevision = const Value.absent(),
    this.operationId = const Value.absent(),
    this.lastModifiedByDeviceId = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       title = Value(title),
       content = Value(content),
       category = Value(category),
       type = Value(type);
  static Insertable<FinancialTipData> custom({
    Expression<String>? id,
    Expression<String>? title,
    Expression<String>? content,
    Expression<String>? category,
    Expression<String>? type,
    Expression<String>? actionLabel,
    Expression<String>? actionRoute,
    Expression<String>? languageCode,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? expiresAt,
    Expression<int>? revision,
    Expression<int>? baseRevision,
    Expression<String>? operationId,
    Expression<String>? lastModifiedByDeviceId,
    Expression<String>? syncState,
    Expression<bool>? isDeleted,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (title != null) 'title': title,
      if (content != null) 'content': content,
      if (category != null) 'category': category,
      if (type != null) 'type': type,
      if (actionLabel != null) 'action_label': actionLabel,
      if (actionRoute != null) 'action_route': actionRoute,
      if (languageCode != null) 'language_code': languageCode,
      if (createdAt != null) 'created_at': createdAt,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (revision != null) 'revision': revision,
      if (baseRevision != null) 'base_revision': baseRevision,
      if (operationId != null) 'operation_id': operationId,
      if (lastModifiedByDeviceId != null)
        'last_modified_by_device_id': lastModifiedByDeviceId,
      if (syncState != null) 'sync_state': syncState,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FinancialTipsCompanion copyWith({
    Value<String>? id,
    Value<String>? title,
    Value<String>? content,
    Value<String>? category,
    Value<String>? type,
    Value<String?>? actionLabel,
    Value<String?>? actionRoute,
    Value<String>? languageCode,
    Value<DateTime>? createdAt,
    Value<DateTime?>? expiresAt,
    Value<int>? revision,
    Value<int?>? baseRevision,
    Value<String?>? operationId,
    Value<String?>? lastModifiedByDeviceId,
    Value<String>? syncState,
    Value<bool>? isDeleted,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return FinancialTipsCompanion(
      id: id ?? this.id,
      title: title ?? this.title,
      content: content ?? this.content,
      category: category ?? this.category,
      type: type ?? this.type,
      actionLabel: actionLabel ?? this.actionLabel,
      actionRoute: actionRoute ?? this.actionRoute,
      languageCode: languageCode ?? this.languageCode,
      createdAt: createdAt ?? this.createdAt,
      expiresAt: expiresAt ?? this.expiresAt,
      revision: revision ?? this.revision,
      baseRevision: baseRevision ?? this.baseRevision,
      operationId: operationId ?? this.operationId,
      lastModifiedByDeviceId:
          lastModifiedByDeviceId ?? this.lastModifiedByDeviceId,
      syncState: syncState ?? this.syncState,
      isDeleted: isDeleted ?? this.isDeleted,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (title.present) {
      map['title'] = Variable<String>(title.value);
    }
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (category.present) {
      map['category'] = Variable<String>(category.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (actionLabel.present) {
      map['action_label'] = Variable<String>(actionLabel.value);
    }
    if (actionRoute.present) {
      map['action_route'] = Variable<String>(actionRoute.value);
    }
    if (languageCode.present) {
      map['language_code'] = Variable<String>(languageCode.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (baseRevision.present) {
      map['base_revision'] = Variable<int>(baseRevision.value);
    }
    if (operationId.present) {
      map['operation_id'] = Variable<String>(operationId.value);
    }
    if (lastModifiedByDeviceId.present) {
      map['last_modified_by_device_id'] = Variable<String>(
        lastModifiedByDeviceId.value,
      );
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FinancialTipsCompanion(')
          ..write('id: $id, ')
          ..write('title: $title, ')
          ..write('content: $content, ')
          ..write('category: $category, ')
          ..write('type: $type, ')
          ..write('actionLabel: $actionLabel, ')
          ..write('actionRoute: $actionRoute, ')
          ..write('languageCode: $languageCode, ')
          ..write('createdAt: $createdAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('revision: $revision, ')
          ..write('baseRevision: $baseRevision, ')
          ..write('operationId: $operationId, ')
          ..write('lastModifiedByDeviceId: $lastModifiedByDeviceId, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $AssetsTable extends Assets with TableInfo<$AssetsTable, Asset> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $AssetsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currentValueMeta = const VerificationMeta(
    'currentValue',
  );
  @override
  late final GeneratedColumn<int> currentValue = GeneratedColumn<int>(
    'current_value',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currencyMeta = const VerificationMeta(
    'currency',
  );
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
    'currency',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('EUR'),
  );
  static const VerificationMeta _isAutomatedMeta = const VerificationMeta(
    'isAutomated',
  );
  @override
  late final GeneratedColumn<bool> isAutomated = GeneratedColumn<bool>(
    'is_automated',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_automated" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _InstitutionNameMeta = const VerificationMeta(
    'InstitutionName',
  );
  @override
  late final GeneratedColumn<String> InstitutionName = GeneratedColumn<String>(
    'institution_name',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _acquiredAtMeta = const VerificationMeta(
    'acquiredAt',
  );
  @override
  late final GeneratedColumn<DateTime> acquiredAt = GeneratedColumn<DateTime>(
    'acquired_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  metadata = GeneratedColumn<String>(
    'metadata',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  ).withConverter<Map<String, dynamic>?>($AssetsTable.$convertermetadatan);
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    name,
    type,
    currentValue,
    currency,
    isAutomated,
    InstitutionName,
    acquiredAt,
    notes,
    metadata,
    createdAt,
    updatedAt,
    revision,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'assets';
  @override
  VerificationContext validateIntegrity(
    Insertable<Asset> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('current_value')) {
      context.handle(
        _currentValueMeta,
        currentValue.isAcceptableOrUnknown(
          data['current_value']!,
          _currentValueMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_currentValueMeta);
    }
    if (data.containsKey('currency')) {
      context.handle(
        _currencyMeta,
        currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta),
      );
    }
    if (data.containsKey('is_automated')) {
      context.handle(
        _isAutomatedMeta,
        isAutomated.isAcceptableOrUnknown(
          data['is_automated']!,
          _isAutomatedMeta,
        ),
      );
    }
    if (data.containsKey('institution_name')) {
      context.handle(
        _InstitutionNameMeta,
        InstitutionName.isAcceptableOrUnknown(
          data['institution_name']!,
          _InstitutionNameMeta,
        ),
      );
    }
    if (data.containsKey('acquired_at')) {
      context.handle(
        _acquiredAtMeta,
        acquiredAt.isAcceptableOrUnknown(data['acquired_at']!, _acquiredAtMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Asset map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Asset(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      currentValue: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}current_value'],
      )!,
      currency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}currency'],
      )!,
      isAutomated: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_automated'],
      )!,
      InstitutionName: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}institution_name'],
      ),
      acquiredAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}acquired_at'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      metadata: $AssetsTable.$convertermetadatan.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}metadata'],
        ),
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $AssetsTable createAlias(String alias) {
    return $AssetsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertermetadata =
      const MetadataConverter();
  static TypeConverter<Map<String, dynamic>?, String?> $convertermetadatan =
      NullAwareTypeConverter.wrap($convertermetadata);
}

class Asset extends DataClass implements Insertable<Asset> {
  final String id;
  final String userId;
  final String name;
  final String type;
  final int currentValue;
  final String currency;
  final bool isAutomated;
  final String? InstitutionName;
  final DateTime? acquiredAt;
  final String? notes;
  final Map<String, dynamic>? metadata;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final String syncState;
  final bool isDeleted;
  final int lamportClock;
  final String? versionVector;
  const Asset({
    required this.id,
    required this.userId,
    required this.name,
    required this.type,
    required this.currentValue,
    required this.currency,
    required this.isAutomated,
    this.InstitutionName,
    this.acquiredAt,
    this.notes,
    this.metadata,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    required this.syncState,
    required this.isDeleted,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['name'] = Variable<String>(name);
    map['type'] = Variable<String>(type);
    map['current_value'] = Variable<int>(currentValue);
    map['currency'] = Variable<String>(currency);
    map['is_automated'] = Variable<bool>(isAutomated);
    if (!nullToAbsent || InstitutionName != null) {
      map['institution_name'] = Variable<String>(InstitutionName);
    }
    if (!nullToAbsent || acquiredAt != null) {
      map['acquired_at'] = Variable<DateTime>(acquiredAt);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    if (!nullToAbsent || metadata != null) {
      map['metadata'] = Variable<String>(
        $AssetsTable.$convertermetadatan.toSql(metadata),
      );
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    map['sync_state'] = Variable<String>(syncState);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  AssetsCompanion toCompanion(bool nullToAbsent) {
    return AssetsCompanion(
      id: Value(id),
      userId: Value(userId),
      name: Value(name),
      type: Value(type),
      currentValue: Value(currentValue),
      currency: Value(currency),
      isAutomated: Value(isAutomated),
      InstitutionName: InstitutionName == null && nullToAbsent
          ? const Value.absent()
          : Value(InstitutionName),
      acquiredAt: acquiredAt == null && nullToAbsent
          ? const Value.absent()
          : Value(acquiredAt),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      metadata: metadata == null && nullToAbsent
          ? const Value.absent()
          : Value(metadata),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      syncState: Value(syncState),
      isDeleted: Value(isDeleted),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory Asset.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Asset(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      name: serializer.fromJson<String>(json['name']),
      type: serializer.fromJson<String>(json['type']),
      currentValue: serializer.fromJson<int>(json['currentValue']),
      currency: serializer.fromJson<String>(json['currency']),
      isAutomated: serializer.fromJson<bool>(json['isAutomated']),
      InstitutionName: serializer.fromJson<String?>(json['InstitutionName']),
      acquiredAt: serializer.fromJson<DateTime?>(json['acquiredAt']),
      notes: serializer.fromJson<String?>(json['notes']),
      metadata: serializer.fromJson<Map<String, dynamic>?>(json['metadata']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      syncState: serializer.fromJson<String>(json['syncState']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'name': serializer.toJson<String>(name),
      'type': serializer.toJson<String>(type),
      'currentValue': serializer.toJson<int>(currentValue),
      'currency': serializer.toJson<String>(currency),
      'isAutomated': serializer.toJson<bool>(isAutomated),
      'InstitutionName': serializer.toJson<String?>(InstitutionName),
      'acquiredAt': serializer.toJson<DateTime?>(acquiredAt),
      'notes': serializer.toJson<String?>(notes),
      'metadata': serializer.toJson<Map<String, dynamic>?>(metadata),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'syncState': serializer.toJson<String>(syncState),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  Asset copyWith({
    String? id,
    String? userId,
    String? name,
    String? type,
    int? currentValue,
    String? currency,
    bool? isAutomated,
    Value<String?> InstitutionName = const Value.absent(),
    Value<DateTime?> acquiredAt = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    Value<Map<String, dynamic>?> metadata = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    String? syncState,
    bool? isDeleted,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => Asset(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    name: name ?? this.name,
    type: type ?? this.type,
    currentValue: currentValue ?? this.currentValue,
    currency: currency ?? this.currency,
    isAutomated: isAutomated ?? this.isAutomated,
    InstitutionName: InstitutionName.present
        ? InstitutionName.value
        : this.InstitutionName,
    acquiredAt: acquiredAt.present ? acquiredAt.value : this.acquiredAt,
    notes: notes.present ? notes.value : this.notes,
    metadata: metadata.present ? metadata.value : this.metadata,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    syncState: syncState ?? this.syncState,
    isDeleted: isDeleted ?? this.isDeleted,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  Asset copyWithCompanion(AssetsCompanion data) {
    return Asset(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      name: data.name.present ? data.name.value : this.name,
      type: data.type.present ? data.type.value : this.type,
      currentValue: data.currentValue.present
          ? data.currentValue.value
          : this.currentValue,
      currency: data.currency.present ? data.currency.value : this.currency,
      isAutomated: data.isAutomated.present
          ? data.isAutomated.value
          : this.isAutomated,
      InstitutionName: data.InstitutionName.present
          ? data.InstitutionName.value
          : this.InstitutionName,
      acquiredAt: data.acquiredAt.present
          ? data.acquiredAt.value
          : this.acquiredAt,
      notes: data.notes.present ? data.notes.value : this.notes,
      metadata: data.metadata.present ? data.metadata.value : this.metadata,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Asset(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('name: $name, ')
          ..write('type: $type, ')
          ..write('currentValue: $currentValue, ')
          ..write('currency: $currency, ')
          ..write('isAutomated: $isAutomated, ')
          ..write('InstitutionName: $InstitutionName, ')
          ..write('acquiredAt: $acquiredAt, ')
          ..write('notes: $notes, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    name,
    type,
    currentValue,
    currency,
    isAutomated,
    InstitutionName,
    acquiredAt,
    notes,
    metadata,
    createdAt,
    updatedAt,
    revision,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Asset &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.name == this.name &&
          other.type == this.type &&
          other.currentValue == this.currentValue &&
          other.currency == this.currency &&
          other.isAutomated == this.isAutomated &&
          other.InstitutionName == this.InstitutionName &&
          other.acquiredAt == this.acquiredAt &&
          other.notes == this.notes &&
          other.metadata == this.metadata &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.syncState == this.syncState &&
          other.isDeleted == this.isDeleted &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class AssetsCompanion extends UpdateCompanion<Asset> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String> name;
  final Value<String> type;
  final Value<int> currentValue;
  final Value<String> currency;
  final Value<bool> isAutomated;
  final Value<String?> InstitutionName;
  final Value<DateTime?> acquiredAt;
  final Value<String?> notes;
  final Value<Map<String, dynamic>?> metadata;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<String> syncState;
  final Value<bool> isDeleted;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const AssetsCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.name = const Value.absent(),
    this.type = const Value.absent(),
    this.currentValue = const Value.absent(),
    this.currency = const Value.absent(),
    this.isAutomated = const Value.absent(),
    this.InstitutionName = const Value.absent(),
    this.acquiredAt = const Value.absent(),
    this.notes = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  AssetsCompanion.insert({
    required String id,
    required String userId,
    required String name,
    required String type,
    required int currentValue,
    this.currency = const Value.absent(),
    this.isAutomated = const Value.absent(),
    this.InstitutionName = const Value.absent(),
    this.acquiredAt = const Value.absent(),
    this.notes = const Value.absent(),
    this.metadata = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       name = Value(name),
       type = Value(type),
       currentValue = Value(currentValue);
  static Insertable<Asset> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? name,
    Expression<String>? type,
    Expression<int>? currentValue,
    Expression<String>? currency,
    Expression<bool>? isAutomated,
    Expression<String>? InstitutionName,
    Expression<DateTime>? acquiredAt,
    Expression<String>? notes,
    Expression<String>? metadata,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<String>? syncState,
    Expression<bool>? isDeleted,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (name != null) 'name': name,
      if (type != null) 'type': type,
      if (currentValue != null) 'current_value': currentValue,
      if (currency != null) 'currency': currency,
      if (isAutomated != null) 'is_automated': isAutomated,
      if (InstitutionName != null) 'institution_name': InstitutionName,
      if (acquiredAt != null) 'acquired_at': acquiredAt,
      if (notes != null) 'notes': notes,
      if (metadata != null) 'metadata': metadata,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (syncState != null) 'sync_state': syncState,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  AssetsCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String>? name,
    Value<String>? type,
    Value<int>? currentValue,
    Value<String>? currency,
    Value<bool>? isAutomated,
    Value<String?>? InstitutionName,
    Value<DateTime?>? acquiredAt,
    Value<String?>? notes,
    Value<Map<String, dynamic>?>? metadata,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<String>? syncState,
    Value<bool>? isDeleted,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return AssetsCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      name: name ?? this.name,
      type: type ?? this.type,
      currentValue: currentValue ?? this.currentValue,
      currency: currency ?? this.currency,
      isAutomated: isAutomated ?? this.isAutomated,
      InstitutionName: InstitutionName ?? this.InstitutionName,
      acquiredAt: acquiredAt ?? this.acquiredAt,
      notes: notes ?? this.notes,
      metadata: metadata ?? this.metadata,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      syncState: syncState ?? this.syncState,
      isDeleted: isDeleted ?? this.isDeleted,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (currentValue.present) {
      map['current_value'] = Variable<int>(currentValue.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (isAutomated.present) {
      map['is_automated'] = Variable<bool>(isAutomated.value);
    }
    if (InstitutionName.present) {
      map['institution_name'] = Variable<String>(InstitutionName.value);
    }
    if (acquiredAt.present) {
      map['acquired_at'] = Variable<DateTime>(acquiredAt.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (metadata.present) {
      map['metadata'] = Variable<String>(
        $AssetsTable.$convertermetadatan.toSql(metadata.value),
      );
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('AssetsCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('name: $name, ')
          ..write('type: $type, ')
          ..write('currentValue: $currentValue, ')
          ..write('currency: $currency, ')
          ..write('isAutomated: $isAutomated, ')
          ..write('InstitutionName: $InstitutionName, ')
          ..write('acquiredAt: $acquiredAt, ')
          ..write('notes: $notes, ')
          ..write('metadata: $metadata, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LiabilitiesTable extends Liabilities
    with TableInfo<$LiabilitiesTable, Liability> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LiabilitiesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currentBalanceMeta = const VerificationMeta(
    'currentBalance',
  );
  @override
  late final GeneratedColumn<int> currentBalance = GeneratedColumn<int>(
    'current_balance',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currencyMeta = const VerificationMeta(
    'currency',
  );
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
    'currency',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('EUR'),
  );
  static const VerificationMeta _interestRateMeta = const VerificationMeta(
    'interestRate',
  );
  @override
  late final GeneratedColumn<double> interestRate = GeneratedColumn<double>(
    'interest_rate',
    aliasedName,
    true,
    type: DriftSqlType.double,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _dueDateMeta = const VerificationMeta(
    'dueDate',
  );
  @override
  late final GeneratedColumn<DateTime> dueDate = GeneratedColumn<DateTime>(
    'due_date',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _minPaymentMeta = const VerificationMeta(
    'minPayment',
  );
  @override
  late final GeneratedColumn<int> minPayment = GeneratedColumn<int>(
    'min_payment',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  static const VerificationMeta _isDeletedMeta = const VerificationMeta(
    'isDeleted',
  );
  @override
  late final GeneratedColumn<bool> isDeleted = GeneratedColumn<bool>(
    'is_deleted',
    aliasedName,
    false,
    type: DriftSqlType.bool,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'CHECK ("is_deleted" IN (0, 1))',
    ),
    defaultValue: const Constant(false),
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    name,
    type,
    currentBalance,
    currency,
    interestRate,
    dueDate,
    minPayment,
    notes,
    createdAt,
    updatedAt,
    revision,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'liabilities';
  @override
  VerificationContext validateIntegrity(
    Insertable<Liability> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('current_balance')) {
      context.handle(
        _currentBalanceMeta,
        currentBalance.isAcceptableOrUnknown(
          data['current_balance']!,
          _currentBalanceMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_currentBalanceMeta);
    }
    if (data.containsKey('currency')) {
      context.handle(
        _currencyMeta,
        currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta),
      );
    }
    if (data.containsKey('interest_rate')) {
      context.handle(
        _interestRateMeta,
        interestRate.isAcceptableOrUnknown(
          data['interest_rate']!,
          _interestRateMeta,
        ),
      );
    }
    if (data.containsKey('due_date')) {
      context.handle(
        _dueDateMeta,
        dueDate.isAcceptableOrUnknown(data['due_date']!, _dueDateMeta),
      );
    }
    if (data.containsKey('min_payment')) {
      context.handle(
        _minPaymentMeta,
        minPayment.isAcceptableOrUnknown(data['min_payment']!, _minPaymentMeta),
      );
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    if (data.containsKey('is_deleted')) {
      context.handle(
        _isDeletedMeta,
        isDeleted.isAcceptableOrUnknown(data['is_deleted']!, _isDeletedMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Liability map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Liability(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      currentBalance: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}current_balance'],
      )!,
      currency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}currency'],
      )!,
      interestRate: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}interest_rate'],
      ),
      dueDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}due_date'],
      ),
      minPayment: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}min_payment'],
      ),
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
      isDeleted: attachedDatabase.typeMapping.read(
        DriftSqlType.bool,
        data['${effectivePrefix}is_deleted'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
    );
  }

  @override
  $LiabilitiesTable createAlias(String alias) {
    return $LiabilitiesTable(attachedDatabase, alias);
  }
}

class Liability extends DataClass implements Insertable<Liability> {
  final String id;
  final String userId;
  final String name;
  final String type;
  final int currentBalance;
  final String currency;
  final double? interestRate;
  final DateTime? dueDate;
  final int? minPayment;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final String syncState;
  final bool isDeleted;
  final int lamportClock;
  final String? versionVector;
  const Liability({
    required this.id,
    required this.userId,
    required this.name,
    required this.type,
    required this.currentBalance,
    required this.currency,
    this.interestRate,
    this.dueDate,
    this.minPayment,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    required this.syncState,
    required this.isDeleted,
    required this.lamportClock,
    this.versionVector,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['name'] = Variable<String>(name);
    map['type'] = Variable<String>(type);
    map['current_balance'] = Variable<int>(currentBalance);
    map['currency'] = Variable<String>(currency);
    if (!nullToAbsent || interestRate != null) {
      map['interest_rate'] = Variable<double>(interestRate);
    }
    if (!nullToAbsent || dueDate != null) {
      map['due_date'] = Variable<DateTime>(dueDate);
    }
    if (!nullToAbsent || minPayment != null) {
      map['min_payment'] = Variable<int>(minPayment);
    }
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    map['sync_state'] = Variable<String>(syncState);
    map['is_deleted'] = Variable<bool>(isDeleted);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    return map;
  }

  LiabilitiesCompanion toCompanion(bool nullToAbsent) {
    return LiabilitiesCompanion(
      id: Value(id),
      userId: Value(userId),
      name: Value(name),
      type: Value(type),
      currentBalance: Value(currentBalance),
      currency: Value(currency),
      interestRate: interestRate == null && nullToAbsent
          ? const Value.absent()
          : Value(interestRate),
      dueDate: dueDate == null && nullToAbsent
          ? const Value.absent()
          : Value(dueDate),
      minPayment: minPayment == null && nullToAbsent
          ? const Value.absent()
          : Value(minPayment),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      syncState: Value(syncState),
      isDeleted: Value(isDeleted),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
    );
  }

  factory Liability.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Liability(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      name: serializer.fromJson<String>(json['name']),
      type: serializer.fromJson<String>(json['type']),
      currentBalance: serializer.fromJson<int>(json['currentBalance']),
      currency: serializer.fromJson<String>(json['currency']),
      interestRate: serializer.fromJson<double?>(json['interestRate']),
      dueDate: serializer.fromJson<DateTime?>(json['dueDate']),
      minPayment: serializer.fromJson<int?>(json['minPayment']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      syncState: serializer.fromJson<String>(json['syncState']),
      isDeleted: serializer.fromJson<bool>(json['isDeleted']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'name': serializer.toJson<String>(name),
      'type': serializer.toJson<String>(type),
      'currentBalance': serializer.toJson<int>(currentBalance),
      'currency': serializer.toJson<String>(currency),
      'interestRate': serializer.toJson<double?>(interestRate),
      'dueDate': serializer.toJson<DateTime?>(dueDate),
      'minPayment': serializer.toJson<int?>(minPayment),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'syncState': serializer.toJson<String>(syncState),
      'isDeleted': serializer.toJson<bool>(isDeleted),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
    };
  }

  Liability copyWith({
    String? id,
    String? userId,
    String? name,
    String? type,
    int? currentBalance,
    String? currency,
    Value<double?> interestRate = const Value.absent(),
    Value<DateTime?> dueDate = const Value.absent(),
    Value<int?> minPayment = const Value.absent(),
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    String? syncState,
    bool? isDeleted,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
  }) => Liability(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    name: name ?? this.name,
    type: type ?? this.type,
    currentBalance: currentBalance ?? this.currentBalance,
    currency: currency ?? this.currency,
    interestRate: interestRate.present ? interestRate.value : this.interestRate,
    dueDate: dueDate.present ? dueDate.value : this.dueDate,
    minPayment: minPayment.present ? minPayment.value : this.minPayment,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    syncState: syncState ?? this.syncState,
    isDeleted: isDeleted ?? this.isDeleted,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
  );
  Liability copyWithCompanion(LiabilitiesCompanion data) {
    return Liability(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      name: data.name.present ? data.name.value : this.name,
      type: data.type.present ? data.type.value : this.type,
      currentBalance: data.currentBalance.present
          ? data.currentBalance.value
          : this.currentBalance,
      currency: data.currency.present ? data.currency.value : this.currency,
      interestRate: data.interestRate.present
          ? data.interestRate.value
          : this.interestRate,
      dueDate: data.dueDate.present ? data.dueDate.value : this.dueDate,
      minPayment: data.minPayment.present
          ? data.minPayment.value
          : this.minPayment,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
      isDeleted: data.isDeleted.present ? data.isDeleted.value : this.isDeleted,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Liability(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('name: $name, ')
          ..write('type: $type, ')
          ..write('currentBalance: $currentBalance, ')
          ..write('currency: $currency, ')
          ..write('interestRate: $interestRate, ')
          ..write('dueDate: $dueDate, ')
          ..write('minPayment: $minPayment, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    name,
    type,
    currentBalance,
    currency,
    interestRate,
    dueDate,
    minPayment,
    notes,
    createdAt,
    updatedAt,
    revision,
    syncState,
    isDeleted,
    lamportClock,
    versionVector,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Liability &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.name == this.name &&
          other.type == this.type &&
          other.currentBalance == this.currentBalance &&
          other.currency == this.currency &&
          other.interestRate == this.interestRate &&
          other.dueDate == this.dueDate &&
          other.minPayment == this.minPayment &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.syncState == this.syncState &&
          other.isDeleted == this.isDeleted &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector);
}

class LiabilitiesCompanion extends UpdateCompanion<Liability> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String> name;
  final Value<String> type;
  final Value<int> currentBalance;
  final Value<String> currency;
  final Value<double?> interestRate;
  final Value<DateTime?> dueDate;
  final Value<int?> minPayment;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<String> syncState;
  final Value<bool> isDeleted;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<int> rowid;
  const LiabilitiesCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.name = const Value.absent(),
    this.type = const Value.absent(),
    this.currentBalance = const Value.absent(),
    this.currency = const Value.absent(),
    this.interestRate = const Value.absent(),
    this.dueDate = const Value.absent(),
    this.minPayment = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  LiabilitiesCompanion.insert({
    required String id,
    required String userId,
    required String name,
    required String type,
    required int currentBalance,
    this.currency = const Value.absent(),
    this.interestRate = const Value.absent(),
    this.dueDate = const Value.absent(),
    this.minPayment = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.isDeleted = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       name = Value(name),
       type = Value(type),
       currentBalance = Value(currentBalance);
  static Insertable<Liability> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? name,
    Expression<String>? type,
    Expression<int>? currentBalance,
    Expression<String>? currency,
    Expression<double>? interestRate,
    Expression<DateTime>? dueDate,
    Expression<int>? minPayment,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<String>? syncState,
    Expression<bool>? isDeleted,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (name != null) 'name': name,
      if (type != null) 'type': type,
      if (currentBalance != null) 'current_balance': currentBalance,
      if (currency != null) 'currency': currency,
      if (interestRate != null) 'interest_rate': interestRate,
      if (dueDate != null) 'due_date': dueDate,
      if (minPayment != null) 'min_payment': minPayment,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (syncState != null) 'sync_state': syncState,
      if (isDeleted != null) 'is_deleted': isDeleted,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LiabilitiesCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String>? name,
    Value<String>? type,
    Value<int>? currentBalance,
    Value<String>? currency,
    Value<double?>? interestRate,
    Value<DateTime?>? dueDate,
    Value<int?>? minPayment,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<String>? syncState,
    Value<bool>? isDeleted,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<int>? rowid,
  }) {
    return LiabilitiesCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      name: name ?? this.name,
      type: type ?? this.type,
      currentBalance: currentBalance ?? this.currentBalance,
      currency: currency ?? this.currency,
      interestRate: interestRate ?? this.interestRate,
      dueDate: dueDate ?? this.dueDate,
      minPayment: minPayment ?? this.minPayment,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      syncState: syncState ?? this.syncState,
      isDeleted: isDeleted ?? this.isDeleted,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (currentBalance.present) {
      map['current_balance'] = Variable<int>(currentBalance.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (interestRate.present) {
      map['interest_rate'] = Variable<double>(interestRate.value);
    }
    if (dueDate.present) {
      map['due_date'] = Variable<DateTime>(dueDate.value);
    }
    if (minPayment.present) {
      map['min_payment'] = Variable<int>(minPayment.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (isDeleted.present) {
      map['is_deleted'] = Variable<bool>(isDeleted.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LiabilitiesCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('name: $name, ')
          ..write('type: $type, ')
          ..write('currentBalance: $currentBalance, ')
          ..write('currency: $currency, ')
          ..write('interestRate: $interestRate, ')
          ..write('dueDate: $dueDate, ')
          ..write('minPayment: $minPayment, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('isDeleted: $isDeleted, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $ValuationHistoryTable extends ValuationHistory
    with TableInfo<$ValuationHistoryTable, ValuationHistoryData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $ValuationHistoryTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityIdMeta = const VerificationMeta(
    'entityId',
  );
  @override
  late final GeneratedColumn<String> entityId = GeneratedColumn<String>(
    'entity_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _valueMeta = const VerificationMeta('value');
  @override
  late final GeneratedColumn<int> value = GeneratedColumn<int>(
    'value',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _dateMeta = const VerificationMeta('date');
  @override
  late final GeneratedColumn<DateTime> date = GeneratedColumn<DateTime>(
    'date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _recordedAtMeta = const VerificationMeta(
    'recordedAt',
  );
  @override
  late final GeneratedColumn<DateTime> recordedAt = GeneratedColumn<DateTime>(
    'recorded_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    entityType,
    entityId,
    value,
    date,
    recordedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'valuation_history';
  @override
  VerificationContext validateIntegrity(
    Insertable<ValuationHistoryData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('entity_id')) {
      context.handle(
        _entityIdMeta,
        entityId.isAcceptableOrUnknown(data['entity_id']!, _entityIdMeta),
      );
    } else if (isInserting) {
      context.missing(_entityIdMeta);
    }
    if (data.containsKey('value')) {
      context.handle(
        _valueMeta,
        value.isAcceptableOrUnknown(data['value']!, _valueMeta),
      );
    } else if (isInserting) {
      context.missing(_valueMeta);
    }
    if (data.containsKey('date')) {
      context.handle(
        _dateMeta,
        date.isAcceptableOrUnknown(data['date']!, _dateMeta),
      );
    } else if (isInserting) {
      context.missing(_dateMeta);
    }
    if (data.containsKey('recorded_at')) {
      context.handle(
        _recordedAtMeta,
        recordedAt.isAcceptableOrUnknown(data['recorded_at']!, _recordedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  ValuationHistoryData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return ValuationHistoryData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      entityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_id'],
      )!,
      value: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}value'],
      )!,
      date: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}date'],
      )!,
      recordedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}recorded_at'],
      )!,
    );
  }

  @override
  $ValuationHistoryTable createAlias(String alias) {
    return $ValuationHistoryTable(attachedDatabase, alias);
  }
}

class ValuationHistoryData extends DataClass
    implements Insertable<ValuationHistoryData> {
  final String id;
  final String entityType;
  final String entityId;
  final int value;
  final DateTime date;
  final DateTime recordedAt;
  const ValuationHistoryData({
    required this.id,
    required this.entityType,
    required this.entityId,
    required this.value,
    required this.date,
    required this.recordedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['entity_type'] = Variable<String>(entityType);
    map['entity_id'] = Variable<String>(entityId);
    map['value'] = Variable<int>(value);
    map['date'] = Variable<DateTime>(date);
    map['recorded_at'] = Variable<DateTime>(recordedAt);
    return map;
  }

  ValuationHistoryCompanion toCompanion(bool nullToAbsent) {
    return ValuationHistoryCompanion(
      id: Value(id),
      entityType: Value(entityType),
      entityId: Value(entityId),
      value: Value(value),
      date: Value(date),
      recordedAt: Value(recordedAt),
    );
  }

  factory ValuationHistoryData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return ValuationHistoryData(
      id: serializer.fromJson<String>(json['id']),
      entityType: serializer.fromJson<String>(json['entityType']),
      entityId: serializer.fromJson<String>(json['entityId']),
      value: serializer.fromJson<int>(json['value']),
      date: serializer.fromJson<DateTime>(json['date']),
      recordedAt: serializer.fromJson<DateTime>(json['recordedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'entityType': serializer.toJson<String>(entityType),
      'entityId': serializer.toJson<String>(entityId),
      'value': serializer.toJson<int>(value),
      'date': serializer.toJson<DateTime>(date),
      'recordedAt': serializer.toJson<DateTime>(recordedAt),
    };
  }

  ValuationHistoryData copyWith({
    String? id,
    String? entityType,
    String? entityId,
    int? value,
    DateTime? date,
    DateTime? recordedAt,
  }) => ValuationHistoryData(
    id: id ?? this.id,
    entityType: entityType ?? this.entityType,
    entityId: entityId ?? this.entityId,
    value: value ?? this.value,
    date: date ?? this.date,
    recordedAt: recordedAt ?? this.recordedAt,
  );
  ValuationHistoryData copyWithCompanion(ValuationHistoryCompanion data) {
    return ValuationHistoryData(
      id: data.id.present ? data.id.value : this.id,
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      entityId: data.entityId.present ? data.entityId.value : this.entityId,
      value: data.value.present ? data.value.value : this.value,
      date: data.date.present ? data.date.value : this.date,
      recordedAt: data.recordedAt.present
          ? data.recordedAt.value
          : this.recordedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('ValuationHistoryData(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('value: $value, ')
          ..write('date: $date, ')
          ..write('recordedAt: $recordedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, entityType, entityId, value, date, recordedAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is ValuationHistoryData &&
          other.id == this.id &&
          other.entityType == this.entityType &&
          other.entityId == this.entityId &&
          other.value == this.value &&
          other.date == this.date &&
          other.recordedAt == this.recordedAt);
}

class ValuationHistoryCompanion extends UpdateCompanion<ValuationHistoryData> {
  final Value<String> id;
  final Value<String> entityType;
  final Value<String> entityId;
  final Value<int> value;
  final Value<DateTime> date;
  final Value<DateTime> recordedAt;
  final Value<int> rowid;
  const ValuationHistoryCompanion({
    this.id = const Value.absent(),
    this.entityType = const Value.absent(),
    this.entityId = const Value.absent(),
    this.value = const Value.absent(),
    this.date = const Value.absent(),
    this.recordedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  ValuationHistoryCompanion.insert({
    required String id,
    required String entityType,
    required String entityId,
    required int value,
    required DateTime date,
    this.recordedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       entityType = Value(entityType),
       entityId = Value(entityId),
       value = Value(value),
       date = Value(date);
  static Insertable<ValuationHistoryData> custom({
    Expression<String>? id,
    Expression<String>? entityType,
    Expression<String>? entityId,
    Expression<int>? value,
    Expression<DateTime>? date,
    Expression<DateTime>? recordedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (entityType != null) 'entity_type': entityType,
      if (entityId != null) 'entity_id': entityId,
      if (value != null) 'value': value,
      if (date != null) 'date': date,
      if (recordedAt != null) 'recorded_at': recordedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  ValuationHistoryCompanion copyWith({
    Value<String>? id,
    Value<String>? entityType,
    Value<String>? entityId,
    Value<int>? value,
    Value<DateTime>? date,
    Value<DateTime>? recordedAt,
    Value<int>? rowid,
  }) {
    return ValuationHistoryCompanion(
      id: id ?? this.id,
      entityType: entityType ?? this.entityType,
      entityId: entityId ?? this.entityId,
      value: value ?? this.value,
      date: date ?? this.date,
      recordedAt: recordedAt ?? this.recordedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (entityId.present) {
      map['entity_id'] = Variable<String>(entityId.value);
    }
    if (value.present) {
      map['value'] = Variable<int>(value.value);
    }
    if (date.present) {
      map['date'] = Variable<DateTime>(date.value);
    }
    if (recordedAt.present) {
      map['recorded_at'] = Variable<DateTime>(recordedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('ValuationHistoryCompanion(')
          ..write('id: $id, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('value: $value, ')
          ..write('date: $date, ')
          ..write('recordedAt: $recordedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $LedgerEventsTable extends LedgerEvents
    with TableInfo<$LedgerEventsTable, LedgerEvent> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $LedgerEventsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _eventIdMeta = const VerificationMeta(
    'eventId',
  );
  @override
  late final GeneratedColumn<String> eventId = GeneratedColumn<String>(
    'event_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _eventTypeMeta = const VerificationMeta(
    'eventType',
  );
  @override
  late final GeneratedColumn<String> eventType = GeneratedColumn<String>(
    'event_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityTypeMeta = const VerificationMeta(
    'entityType',
  );
  @override
  late final GeneratedColumn<String> entityType = GeneratedColumn<String>(
    'entity_type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _entityIdMeta = const VerificationMeta(
    'entityId',
  );
  @override
  late final GeneratedColumn<String> entityId = GeneratedColumn<String>(
    'entity_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _deviceIdMeta = const VerificationMeta(
    'deviceId',
  );
  @override
  late final GeneratedColumn<String> deviceId = GeneratedColumn<String>(
    'device_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  late final GeneratedColumnWithTypeConverter<Map<String, dynamic>, String>
  eventData = GeneratedColumn<String>(
    'event_data',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  ).withConverter<Map<String, dynamic>>($LedgerEventsTable.$convertereventData);
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _lamportClockMeta = const VerificationMeta(
    'lamportClock',
  );
  @override
  late final GeneratedColumn<int> lamportClock = GeneratedColumn<int>(
    'lamport_clock',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _versionVectorMeta = const VerificationMeta(
    'versionVector',
  );
  @override
  late final GeneratedColumn<String> versionVector = GeneratedColumn<String>(
    'version_vector',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _previousEventHashMeta = const VerificationMeta(
    'previousEventHash',
  );
  @override
  late final GeneratedColumn<String> previousEventHash =
      GeneratedColumn<String>(
        'previous_event_hash',
        aliasedName,
        true,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
      );
  static const VerificationMeta _hashMeta = const VerificationMeta('hash');
  @override
  late final GeneratedColumn<String> hash = GeneratedColumn<String>(
    'hash',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    eventId,
    eventType,
    entityType,
    entityId,
    userId,
    deviceId,
    eventData,
    timestamp,
    lamportClock,
    versionVector,
    previousEventHash,
    hash,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'ledger_events';
  @override
  VerificationContext validateIntegrity(
    Insertable<LedgerEvent> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('event_id')) {
      context.handle(
        _eventIdMeta,
        eventId.isAcceptableOrUnknown(data['event_id']!, _eventIdMeta),
      );
    } else if (isInserting) {
      context.missing(_eventIdMeta);
    }
    if (data.containsKey('event_type')) {
      context.handle(
        _eventTypeMeta,
        eventType.isAcceptableOrUnknown(data['event_type']!, _eventTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_eventTypeMeta);
    }
    if (data.containsKey('entity_type')) {
      context.handle(
        _entityTypeMeta,
        entityType.isAcceptableOrUnknown(data['entity_type']!, _entityTypeMeta),
      );
    } else if (isInserting) {
      context.missing(_entityTypeMeta);
    }
    if (data.containsKey('entity_id')) {
      context.handle(
        _entityIdMeta,
        entityId.isAcceptableOrUnknown(data['entity_id']!, _entityIdMeta),
      );
    } else if (isInserting) {
      context.missing(_entityIdMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('device_id')) {
      context.handle(
        _deviceIdMeta,
        deviceId.isAcceptableOrUnknown(data['device_id']!, _deviceIdMeta),
      );
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    }
    if (data.containsKey('lamport_clock')) {
      context.handle(
        _lamportClockMeta,
        lamportClock.isAcceptableOrUnknown(
          data['lamport_clock']!,
          _lamportClockMeta,
        ),
      );
    }
    if (data.containsKey('version_vector')) {
      context.handle(
        _versionVectorMeta,
        versionVector.isAcceptableOrUnknown(
          data['version_vector']!,
          _versionVectorMeta,
        ),
      );
    }
    if (data.containsKey('previous_event_hash')) {
      context.handle(
        _previousEventHashMeta,
        previousEventHash.isAcceptableOrUnknown(
          data['previous_event_hash']!,
          _previousEventHashMeta,
        ),
      );
    }
    if (data.containsKey('hash')) {
      context.handle(
        _hashMeta,
        hash.isAcceptableOrUnknown(data['hash']!, _hashMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {eventId};
  @override
  LedgerEvent map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return LedgerEvent(
      eventId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}event_id'],
      )!,
      eventType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}event_type'],
      )!,
      entityType: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_type'],
      )!,
      entityId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}entity_id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      deviceId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}device_id'],
      ),
      eventData: $LedgerEventsTable.$convertereventData.fromSql(
        attachedDatabase.typeMapping.read(
          DriftSqlType.string,
          data['${effectivePrefix}event_data'],
        )!,
      ),
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
      lamportClock: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}lamport_clock'],
      )!,
      versionVector: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}version_vector'],
      ),
      previousEventHash: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}previous_event_hash'],
      ),
      hash: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}hash'],
      ),
    );
  }

  @override
  $LedgerEventsTable createAlias(String alias) {
    return $LedgerEventsTable(attachedDatabase, alias);
  }

  static TypeConverter<Map<String, dynamic>, String> $convertereventData =
      const MetadataConverter();
}

class LedgerEvent extends DataClass implements Insertable<LedgerEvent> {
  final String eventId;
  final String eventType;
  final String entityType;
  final String entityId;
  final String userId;
  final String? deviceId;
  final Map<String, dynamic> eventData;
  final DateTime timestamp;
  final int lamportClock;
  final String? versionVector;
  final String? previousEventHash;
  final String? hash;
  const LedgerEvent({
    required this.eventId,
    required this.eventType,
    required this.entityType,
    required this.entityId,
    required this.userId,
    this.deviceId,
    required this.eventData,
    required this.timestamp,
    required this.lamportClock,
    this.versionVector,
    this.previousEventHash,
    this.hash,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['event_id'] = Variable<String>(eventId);
    map['event_type'] = Variable<String>(eventType);
    map['entity_type'] = Variable<String>(entityType);
    map['entity_id'] = Variable<String>(entityId);
    map['user_id'] = Variable<String>(userId);
    if (!nullToAbsent || deviceId != null) {
      map['device_id'] = Variable<String>(deviceId);
    }
    {
      map['event_data'] = Variable<String>(
        $LedgerEventsTable.$convertereventData.toSql(eventData),
      );
    }
    map['timestamp'] = Variable<DateTime>(timestamp);
    map['lamport_clock'] = Variable<int>(lamportClock);
    if (!nullToAbsent || versionVector != null) {
      map['version_vector'] = Variable<String>(versionVector);
    }
    if (!nullToAbsent || previousEventHash != null) {
      map['previous_event_hash'] = Variable<String>(previousEventHash);
    }
    if (!nullToAbsent || hash != null) {
      map['hash'] = Variable<String>(hash);
    }
    return map;
  }

  LedgerEventsCompanion toCompanion(bool nullToAbsent) {
    return LedgerEventsCompanion(
      eventId: Value(eventId),
      eventType: Value(eventType),
      entityType: Value(entityType),
      entityId: Value(entityId),
      userId: Value(userId),
      deviceId: deviceId == null && nullToAbsent
          ? const Value.absent()
          : Value(deviceId),
      eventData: Value(eventData),
      timestamp: Value(timestamp),
      lamportClock: Value(lamportClock),
      versionVector: versionVector == null && nullToAbsent
          ? const Value.absent()
          : Value(versionVector),
      previousEventHash: previousEventHash == null && nullToAbsent
          ? const Value.absent()
          : Value(previousEventHash),
      hash: hash == null && nullToAbsent ? const Value.absent() : Value(hash),
    );
  }

  factory LedgerEvent.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return LedgerEvent(
      eventId: serializer.fromJson<String>(json['eventId']),
      eventType: serializer.fromJson<String>(json['eventType']),
      entityType: serializer.fromJson<String>(json['entityType']),
      entityId: serializer.fromJson<String>(json['entityId']),
      userId: serializer.fromJson<String>(json['userId']),
      deviceId: serializer.fromJson<String?>(json['deviceId']),
      eventData: serializer.fromJson<Map<String, dynamic>>(json['eventData']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
      lamportClock: serializer.fromJson<int>(json['lamportClock']),
      versionVector: serializer.fromJson<String?>(json['versionVector']),
      previousEventHash: serializer.fromJson<String?>(
        json['previousEventHash'],
      ),
      hash: serializer.fromJson<String?>(json['hash']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'eventId': serializer.toJson<String>(eventId),
      'eventType': serializer.toJson<String>(eventType),
      'entityType': serializer.toJson<String>(entityType),
      'entityId': serializer.toJson<String>(entityId),
      'userId': serializer.toJson<String>(userId),
      'deviceId': serializer.toJson<String?>(deviceId),
      'eventData': serializer.toJson<Map<String, dynamic>>(eventData),
      'timestamp': serializer.toJson<DateTime>(timestamp),
      'lamportClock': serializer.toJson<int>(lamportClock),
      'versionVector': serializer.toJson<String?>(versionVector),
      'previousEventHash': serializer.toJson<String?>(previousEventHash),
      'hash': serializer.toJson<String?>(hash),
    };
  }

  LedgerEvent copyWith({
    String? eventId,
    String? eventType,
    String? entityType,
    String? entityId,
    String? userId,
    Value<String?> deviceId = const Value.absent(),
    Map<String, dynamic>? eventData,
    DateTime? timestamp,
    int? lamportClock,
    Value<String?> versionVector = const Value.absent(),
    Value<String?> previousEventHash = const Value.absent(),
    Value<String?> hash = const Value.absent(),
  }) => LedgerEvent(
    eventId: eventId ?? this.eventId,
    eventType: eventType ?? this.eventType,
    entityType: entityType ?? this.entityType,
    entityId: entityId ?? this.entityId,
    userId: userId ?? this.userId,
    deviceId: deviceId.present ? deviceId.value : this.deviceId,
    eventData: eventData ?? this.eventData,
    timestamp: timestamp ?? this.timestamp,
    lamportClock: lamportClock ?? this.lamportClock,
    versionVector: versionVector.present
        ? versionVector.value
        : this.versionVector,
    previousEventHash: previousEventHash.present
        ? previousEventHash.value
        : this.previousEventHash,
    hash: hash.present ? hash.value : this.hash,
  );
  LedgerEvent copyWithCompanion(LedgerEventsCompanion data) {
    return LedgerEvent(
      eventId: data.eventId.present ? data.eventId.value : this.eventId,
      eventType: data.eventType.present ? data.eventType.value : this.eventType,
      entityType: data.entityType.present
          ? data.entityType.value
          : this.entityType,
      entityId: data.entityId.present ? data.entityId.value : this.entityId,
      userId: data.userId.present ? data.userId.value : this.userId,
      deviceId: data.deviceId.present ? data.deviceId.value : this.deviceId,
      eventData: data.eventData.present ? data.eventData.value : this.eventData,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
      lamportClock: data.lamportClock.present
          ? data.lamportClock.value
          : this.lamportClock,
      versionVector: data.versionVector.present
          ? data.versionVector.value
          : this.versionVector,
      previousEventHash: data.previousEventHash.present
          ? data.previousEventHash.value
          : this.previousEventHash,
      hash: data.hash.present ? data.hash.value : this.hash,
    );
  }

  @override
  String toString() {
    return (StringBuffer('LedgerEvent(')
          ..write('eventId: $eventId, ')
          ..write('eventType: $eventType, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('userId: $userId, ')
          ..write('deviceId: $deviceId, ')
          ..write('eventData: $eventData, ')
          ..write('timestamp: $timestamp, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('previousEventHash: $previousEventHash, ')
          ..write('hash: $hash')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    eventId,
    eventType,
    entityType,
    entityId,
    userId,
    deviceId,
    eventData,
    timestamp,
    lamportClock,
    versionVector,
    previousEventHash,
    hash,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is LedgerEvent &&
          other.eventId == this.eventId &&
          other.eventType == this.eventType &&
          other.entityType == this.entityType &&
          other.entityId == this.entityId &&
          other.userId == this.userId &&
          other.deviceId == this.deviceId &&
          other.eventData == this.eventData &&
          other.timestamp == this.timestamp &&
          other.lamportClock == this.lamportClock &&
          other.versionVector == this.versionVector &&
          other.previousEventHash == this.previousEventHash &&
          other.hash == this.hash);
}

class LedgerEventsCompanion extends UpdateCompanion<LedgerEvent> {
  final Value<String> eventId;
  final Value<String> eventType;
  final Value<String> entityType;
  final Value<String> entityId;
  final Value<String> userId;
  final Value<String?> deviceId;
  final Value<Map<String, dynamic>> eventData;
  final Value<DateTime> timestamp;
  final Value<int> lamportClock;
  final Value<String?> versionVector;
  final Value<String?> previousEventHash;
  final Value<String?> hash;
  final Value<int> rowid;
  const LedgerEventsCompanion({
    this.eventId = const Value.absent(),
    this.eventType = const Value.absent(),
    this.entityType = const Value.absent(),
    this.entityId = const Value.absent(),
    this.userId = const Value.absent(),
    this.deviceId = const Value.absent(),
    this.eventData = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.previousEventHash = const Value.absent(),
    this.hash = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  LedgerEventsCompanion.insert({
    required String eventId,
    required String eventType,
    required String entityType,
    required String entityId,
    required String userId,
    this.deviceId = const Value.absent(),
    required Map<String, dynamic> eventData,
    this.timestamp = const Value.absent(),
    this.lamportClock = const Value.absent(),
    this.versionVector = const Value.absent(),
    this.previousEventHash = const Value.absent(),
    this.hash = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : eventId = Value(eventId),
       eventType = Value(eventType),
       entityType = Value(entityType),
       entityId = Value(entityId),
       userId = Value(userId),
       eventData = Value(eventData);
  static Insertable<LedgerEvent> custom({
    Expression<String>? eventId,
    Expression<String>? eventType,
    Expression<String>? entityType,
    Expression<String>? entityId,
    Expression<String>? userId,
    Expression<String>? deviceId,
    Expression<String>? eventData,
    Expression<DateTime>? timestamp,
    Expression<int>? lamportClock,
    Expression<String>? versionVector,
    Expression<String>? previousEventHash,
    Expression<String>? hash,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (eventId != null) 'event_id': eventId,
      if (eventType != null) 'event_type': eventType,
      if (entityType != null) 'entity_type': entityType,
      if (entityId != null) 'entity_id': entityId,
      if (userId != null) 'user_id': userId,
      if (deviceId != null) 'device_id': deviceId,
      if (eventData != null) 'event_data': eventData,
      if (timestamp != null) 'timestamp': timestamp,
      if (lamportClock != null) 'lamport_clock': lamportClock,
      if (versionVector != null) 'version_vector': versionVector,
      if (previousEventHash != null) 'previous_event_hash': previousEventHash,
      if (hash != null) 'hash': hash,
      if (rowid != null) 'rowid': rowid,
    });
  }

  LedgerEventsCompanion copyWith({
    Value<String>? eventId,
    Value<String>? eventType,
    Value<String>? entityType,
    Value<String>? entityId,
    Value<String>? userId,
    Value<String?>? deviceId,
    Value<Map<String, dynamic>>? eventData,
    Value<DateTime>? timestamp,
    Value<int>? lamportClock,
    Value<String?>? versionVector,
    Value<String?>? previousEventHash,
    Value<String?>? hash,
    Value<int>? rowid,
  }) {
    return LedgerEventsCompanion(
      eventId: eventId ?? this.eventId,
      eventType: eventType ?? this.eventType,
      entityType: entityType ?? this.entityType,
      entityId: entityId ?? this.entityId,
      userId: userId ?? this.userId,
      deviceId: deviceId ?? this.deviceId,
      eventData: eventData ?? this.eventData,
      timestamp: timestamp ?? this.timestamp,
      lamportClock: lamportClock ?? this.lamportClock,
      versionVector: versionVector ?? this.versionVector,
      previousEventHash: previousEventHash ?? this.previousEventHash,
      hash: hash ?? this.hash,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (eventId.present) {
      map['event_id'] = Variable<String>(eventId.value);
    }
    if (eventType.present) {
      map['event_type'] = Variable<String>(eventType.value);
    }
    if (entityType.present) {
      map['entity_type'] = Variable<String>(entityType.value);
    }
    if (entityId.present) {
      map['entity_id'] = Variable<String>(entityId.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (deviceId.present) {
      map['device_id'] = Variable<String>(deviceId.value);
    }
    if (eventData.present) {
      map['event_data'] = Variable<String>(
        $LedgerEventsTable.$convertereventData.toSql(eventData.value),
      );
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (lamportClock.present) {
      map['lamport_clock'] = Variable<int>(lamportClock.value);
    }
    if (versionVector.present) {
      map['version_vector'] = Variable<String>(versionVector.value);
    }
    if (previousEventHash.present) {
      map['previous_event_hash'] = Variable<String>(previousEventHash.value);
    }
    if (hash.present) {
      map['hash'] = Variable<String>(hash.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('LedgerEventsCompanion(')
          ..write('eventId: $eventId, ')
          ..write('eventType: $eventType, ')
          ..write('entityType: $entityType, ')
          ..write('entityId: $entityId, ')
          ..write('userId: $userId, ')
          ..write('deviceId: $deviceId, ')
          ..write('eventData: $eventData, ')
          ..write('timestamp: $timestamp, ')
          ..write('lamportClock: $lamportClock, ')
          ..write('versionVector: $versionVector, ')
          ..write('previousEventHash: $previousEventHash, ')
          ..write('hash: $hash, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $BudgetHealthSnapshotsTable extends BudgetHealthSnapshots
    with TableInfo<$BudgetHealthSnapshotsTable, BudgetHealthSnapshot> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $BudgetHealthSnapshotsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _overallScoreMeta = const VerificationMeta(
    'overallScore',
  );
  @override
  late final GeneratedColumn<double> overallScore = GeneratedColumn<double>(
    'overall_score',
    aliasedName,
    false,
    type: DriftSqlType.double,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _metricsJsonMeta = const VerificationMeta(
    'metricsJson',
  );
  @override
  late final GeneratedColumn<String> metricsJson = GeneratedColumn<String>(
    'metrics_json',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _timestampMeta = const VerificationMeta(
    'timestamp',
  );
  @override
  late final GeneratedColumn<DateTime> timestamp = GeneratedColumn<DateTime>(
    'timestamp',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    overallScore,
    metricsJson,
    timestamp,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'budget_health_snapshots';
  @override
  VerificationContext validateIntegrity(
    Insertable<BudgetHealthSnapshot> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('overall_score')) {
      context.handle(
        _overallScoreMeta,
        overallScore.isAcceptableOrUnknown(
          data['overall_score']!,
          _overallScoreMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_overallScoreMeta);
    }
    if (data.containsKey('metrics_json')) {
      context.handle(
        _metricsJsonMeta,
        metricsJson.isAcceptableOrUnknown(
          data['metrics_json']!,
          _metricsJsonMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_metricsJsonMeta);
    }
    if (data.containsKey('timestamp')) {
      context.handle(
        _timestampMeta,
        timestamp.isAcceptableOrUnknown(data['timestamp']!, _timestampMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  BudgetHealthSnapshot map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return BudgetHealthSnapshot(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      overallScore: attachedDatabase.typeMapping.read(
        DriftSqlType.double,
        data['${effectivePrefix}overall_score'],
      )!,
      metricsJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}metrics_json'],
      )!,
      timestamp: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}timestamp'],
      )!,
    );
  }

  @override
  $BudgetHealthSnapshotsTable createAlias(String alias) {
    return $BudgetHealthSnapshotsTable(attachedDatabase, alias);
  }
}

class BudgetHealthSnapshot extends DataClass
    implements Insertable<BudgetHealthSnapshot> {
  final String id;
  final String userId;
  final double overallScore;
  final String metricsJson;
  final DateTime timestamp;
  const BudgetHealthSnapshot({
    required this.id,
    required this.userId,
    required this.overallScore,
    required this.metricsJson,
    required this.timestamp,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['overall_score'] = Variable<double>(overallScore);
    map['metrics_json'] = Variable<String>(metricsJson);
    map['timestamp'] = Variable<DateTime>(timestamp);
    return map;
  }

  BudgetHealthSnapshotsCompanion toCompanion(bool nullToAbsent) {
    return BudgetHealthSnapshotsCompanion(
      id: Value(id),
      userId: Value(userId),
      overallScore: Value(overallScore),
      metricsJson: Value(metricsJson),
      timestamp: Value(timestamp),
    );
  }

  factory BudgetHealthSnapshot.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return BudgetHealthSnapshot(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      overallScore: serializer.fromJson<double>(json['overallScore']),
      metricsJson: serializer.fromJson<String>(json['metricsJson']),
      timestamp: serializer.fromJson<DateTime>(json['timestamp']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'overallScore': serializer.toJson<double>(overallScore),
      'metricsJson': serializer.toJson<String>(metricsJson),
      'timestamp': serializer.toJson<DateTime>(timestamp),
    };
  }

  BudgetHealthSnapshot copyWith({
    String? id,
    String? userId,
    double? overallScore,
    String? metricsJson,
    DateTime? timestamp,
  }) => BudgetHealthSnapshot(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    overallScore: overallScore ?? this.overallScore,
    metricsJson: metricsJson ?? this.metricsJson,
    timestamp: timestamp ?? this.timestamp,
  );
  BudgetHealthSnapshot copyWithCompanion(BudgetHealthSnapshotsCompanion data) {
    return BudgetHealthSnapshot(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      overallScore: data.overallScore.present
          ? data.overallScore.value
          : this.overallScore,
      metricsJson: data.metricsJson.present
          ? data.metricsJson.value
          : this.metricsJson,
      timestamp: data.timestamp.present ? data.timestamp.value : this.timestamp,
    );
  }

  @override
  String toString() {
    return (StringBuffer('BudgetHealthSnapshot(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('overallScore: $overallScore, ')
          ..write('metricsJson: $metricsJson, ')
          ..write('timestamp: $timestamp')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode =>
      Object.hash(id, userId, overallScore, metricsJson, timestamp);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is BudgetHealthSnapshot &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.overallScore == this.overallScore &&
          other.metricsJson == this.metricsJson &&
          other.timestamp == this.timestamp);
}

class BudgetHealthSnapshotsCompanion
    extends UpdateCompanion<BudgetHealthSnapshot> {
  final Value<String> id;
  final Value<String> userId;
  final Value<double> overallScore;
  final Value<String> metricsJson;
  final Value<DateTime> timestamp;
  final Value<int> rowid;
  const BudgetHealthSnapshotsCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.overallScore = const Value.absent(),
    this.metricsJson = const Value.absent(),
    this.timestamp = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  BudgetHealthSnapshotsCompanion.insert({
    required String id,
    required String userId,
    required double overallScore,
    required String metricsJson,
    this.timestamp = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       overallScore = Value(overallScore),
       metricsJson = Value(metricsJson);
  static Insertable<BudgetHealthSnapshot> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<double>? overallScore,
    Expression<String>? metricsJson,
    Expression<DateTime>? timestamp,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (overallScore != null) 'overall_score': overallScore,
      if (metricsJson != null) 'metrics_json': metricsJson,
      if (timestamp != null) 'timestamp': timestamp,
      if (rowid != null) 'rowid': rowid,
    });
  }

  BudgetHealthSnapshotsCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<double>? overallScore,
    Value<String>? metricsJson,
    Value<DateTime>? timestamp,
    Value<int>? rowid,
  }) {
    return BudgetHealthSnapshotsCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      overallScore: overallScore ?? this.overallScore,
      metricsJson: metricsJson ?? this.metricsJson,
      timestamp: timestamp ?? this.timestamp,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (overallScore.present) {
      map['overall_score'] = Variable<double>(overallScore.value);
    }
    if (metricsJson.present) {
      map['metrics_json'] = Variable<String>(metricsJson.value);
    }
    if (timestamp.present) {
      map['timestamp'] = Variable<DateTime>(timestamp.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('BudgetHealthSnapshotsCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('overallScore: $overallScore, ')
          ..write('metricsJson: $metricsJson, ')
          ..write('timestamp: $timestamp, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $CanonicalLedgerTable extends CanonicalLedger
    with TableInfo<$CanonicalLedgerTable, CanonicalLedgerData> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CanonicalLedgerTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _sourceMeta = const VerificationMeta('source');
  @override
  late final GeneratedColumn<String> source = GeneratedColumn<String>(
    'source',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _sourceReferenceMeta = const VerificationMeta(
    'sourceReference',
  );
  @override
  late final GeneratedColumn<String> sourceReference = GeneratedColumn<String>(
    'source_reference',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<int> amount = GeneratedColumn<int>(
    'amount',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _currencyMeta = const VerificationMeta(
    'currency',
  );
  @override
  late final GeneratedColumn<String> currency = GeneratedColumn<String>(
    'currency',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('EUR'),
  );
  static const VerificationMeta _bookingDateMeta = const VerificationMeta(
    'bookingDate',
  );
  @override
  late final GeneratedColumn<DateTime> bookingDate = GeneratedColumn<DateTime>(
    'booking_date',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _descriptionMeta = const VerificationMeta(
    'description',
  );
  @override
  late final GeneratedColumn<String> description = GeneratedColumn<String>(
    'description',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _verificationStatusMeta =
      const VerificationMeta('verificationStatus');
  @override
  late final GeneratedColumn<String> verificationStatus =
      GeneratedColumn<String>(
        'verification_status',
        aliasedName,
        false,
        type: DriftSqlType.string,
        requiredDuringInsert: false,
        defaultValue: const Constant('pending'),
      );
  static const VerificationMeta _derivedExpenseIdMeta = const VerificationMeta(
    'derivedExpenseId',
  );
  @override
  late final GeneratedColumn<String> derivedExpenseId = GeneratedColumn<String>(
    'derived_expense_id',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES expenses (id)',
    ),
  );
  static const VerificationMeta _payloadHashMeta = const VerificationMeta(
    'payloadHash',
  );
  @override
  late final GeneratedColumn<String> payloadHash = GeneratedColumn<String>(
    'payload_hash',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    source,
    sourceReference,
    amount,
    currency,
    bookingDate,
    description,
    verificationStatus,
    derivedExpenseId,
    payloadHash,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'canonical_ledger';
  @override
  VerificationContext validateIntegrity(
    Insertable<CanonicalLedgerData> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('source')) {
      context.handle(
        _sourceMeta,
        source.isAcceptableOrUnknown(data['source']!, _sourceMeta),
      );
    } else if (isInserting) {
      context.missing(_sourceMeta);
    }
    if (data.containsKey('source_reference')) {
      context.handle(
        _sourceReferenceMeta,
        sourceReference.isAcceptableOrUnknown(
          data['source_reference']!,
          _sourceReferenceMeta,
        ),
      );
    }
    if (data.containsKey('amount')) {
      context.handle(
        _amountMeta,
        amount.isAcceptableOrUnknown(data['amount']!, _amountMeta),
      );
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('currency')) {
      context.handle(
        _currencyMeta,
        currency.isAcceptableOrUnknown(data['currency']!, _currencyMeta),
      );
    }
    if (data.containsKey('booking_date')) {
      context.handle(
        _bookingDateMeta,
        bookingDate.isAcceptableOrUnknown(
          data['booking_date']!,
          _bookingDateMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_bookingDateMeta);
    }
    if (data.containsKey('description')) {
      context.handle(
        _descriptionMeta,
        description.isAcceptableOrUnknown(
          data['description']!,
          _descriptionMeta,
        ),
      );
    }
    if (data.containsKey('verification_status')) {
      context.handle(
        _verificationStatusMeta,
        verificationStatus.isAcceptableOrUnknown(
          data['verification_status']!,
          _verificationStatusMeta,
        ),
      );
    }
    if (data.containsKey('derived_expense_id')) {
      context.handle(
        _derivedExpenseIdMeta,
        derivedExpenseId.isAcceptableOrUnknown(
          data['derived_expense_id']!,
          _derivedExpenseIdMeta,
        ),
      );
    }
    if (data.containsKey('payload_hash')) {
      context.handle(
        _payloadHashMeta,
        payloadHash.isAcceptableOrUnknown(
          data['payload_hash']!,
          _payloadHashMeta,
        ),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  CanonicalLedgerData map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return CanonicalLedgerData(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      source: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source'],
      )!,
      sourceReference: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}source_reference'],
      ),
      amount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}amount'],
      )!,
      currency: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}currency'],
      )!,
      bookingDate: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}booking_date'],
      )!,
      description: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}description'],
      ),
      verificationStatus: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}verification_status'],
      )!,
      derivedExpenseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}derived_expense_id'],
      ),
      payloadHash: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}payload_hash'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $CanonicalLedgerTable createAlias(String alias) {
    return $CanonicalLedgerTable(attachedDatabase, alias);
  }
}

class CanonicalLedgerData extends DataClass
    implements Insertable<CanonicalLedgerData> {
  final String id;
  final String userId;

  /// Source identifier: 'nordigen', 'ocr', 'manual'
  final String source;

  /// External reference (Bank Transaction ID, Receipt ID)
  final String? sourceReference;
  final int amount;
  final String currency;
  final DateTime bookingDate;
  final String? description;

  /// Verification status: 'verified', 'pending', 'contested'
  final String verificationStatus;

  /// Reference to derived expense record
  final String? derivedExpenseId;

  /// Hash of raw fields for integrity verification (Tamper-evidence)
  final String? payloadHash;
  final DateTime createdAt;
  final DateTime updatedAt;
  const CanonicalLedgerData({
    required this.id,
    required this.userId,
    required this.source,
    this.sourceReference,
    required this.amount,
    required this.currency,
    required this.bookingDate,
    this.description,
    required this.verificationStatus,
    this.derivedExpenseId,
    this.payloadHash,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['source'] = Variable<String>(source);
    if (!nullToAbsent || sourceReference != null) {
      map['source_reference'] = Variable<String>(sourceReference);
    }
    map['amount'] = Variable<int>(amount);
    map['currency'] = Variable<String>(currency);
    map['booking_date'] = Variable<DateTime>(bookingDate);
    if (!nullToAbsent || description != null) {
      map['description'] = Variable<String>(description);
    }
    map['verification_status'] = Variable<String>(verificationStatus);
    if (!nullToAbsent || derivedExpenseId != null) {
      map['derived_expense_id'] = Variable<String>(derivedExpenseId);
    }
    if (!nullToAbsent || payloadHash != null) {
      map['payload_hash'] = Variable<String>(payloadHash);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    return map;
  }

  CanonicalLedgerCompanion toCompanion(bool nullToAbsent) {
    return CanonicalLedgerCompanion(
      id: Value(id),
      userId: Value(userId),
      source: Value(source),
      sourceReference: sourceReference == null && nullToAbsent
          ? const Value.absent()
          : Value(sourceReference),
      amount: Value(amount),
      currency: Value(currency),
      bookingDate: Value(bookingDate),
      description: description == null && nullToAbsent
          ? const Value.absent()
          : Value(description),
      verificationStatus: Value(verificationStatus),
      derivedExpenseId: derivedExpenseId == null && nullToAbsent
          ? const Value.absent()
          : Value(derivedExpenseId),
      payloadHash: payloadHash == null && nullToAbsent
          ? const Value.absent()
          : Value(payloadHash),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory CanonicalLedgerData.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return CanonicalLedgerData(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      source: serializer.fromJson<String>(json['source']),
      sourceReference: serializer.fromJson<String?>(json['sourceReference']),
      amount: serializer.fromJson<int>(json['amount']),
      currency: serializer.fromJson<String>(json['currency']),
      bookingDate: serializer.fromJson<DateTime>(json['bookingDate']),
      description: serializer.fromJson<String?>(json['description']),
      verificationStatus: serializer.fromJson<String>(
        json['verificationStatus'],
      ),
      derivedExpenseId: serializer.fromJson<String?>(json['derivedExpenseId']),
      payloadHash: serializer.fromJson<String?>(json['payloadHash']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'source': serializer.toJson<String>(source),
      'sourceReference': serializer.toJson<String?>(sourceReference),
      'amount': serializer.toJson<int>(amount),
      'currency': serializer.toJson<String>(currency),
      'bookingDate': serializer.toJson<DateTime>(bookingDate),
      'description': serializer.toJson<String?>(description),
      'verificationStatus': serializer.toJson<String>(verificationStatus),
      'derivedExpenseId': serializer.toJson<String?>(derivedExpenseId),
      'payloadHash': serializer.toJson<String?>(payloadHash),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
    };
  }

  CanonicalLedgerData copyWith({
    String? id,
    String? userId,
    String? source,
    Value<String?> sourceReference = const Value.absent(),
    int? amount,
    String? currency,
    DateTime? bookingDate,
    Value<String?> description = const Value.absent(),
    String? verificationStatus,
    Value<String?> derivedExpenseId = const Value.absent(),
    Value<String?> payloadHash = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
  }) => CanonicalLedgerData(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    source: source ?? this.source,
    sourceReference: sourceReference.present
        ? sourceReference.value
        : this.sourceReference,
    amount: amount ?? this.amount,
    currency: currency ?? this.currency,
    bookingDate: bookingDate ?? this.bookingDate,
    description: description.present ? description.value : this.description,
    verificationStatus: verificationStatus ?? this.verificationStatus,
    derivedExpenseId: derivedExpenseId.present
        ? derivedExpenseId.value
        : this.derivedExpenseId,
    payloadHash: payloadHash.present ? payloadHash.value : this.payloadHash,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  CanonicalLedgerData copyWithCompanion(CanonicalLedgerCompanion data) {
    return CanonicalLedgerData(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      source: data.source.present ? data.source.value : this.source,
      sourceReference: data.sourceReference.present
          ? data.sourceReference.value
          : this.sourceReference,
      amount: data.amount.present ? data.amount.value : this.amount,
      currency: data.currency.present ? data.currency.value : this.currency,
      bookingDate: data.bookingDate.present
          ? data.bookingDate.value
          : this.bookingDate,
      description: data.description.present
          ? data.description.value
          : this.description,
      verificationStatus: data.verificationStatus.present
          ? data.verificationStatus.value
          : this.verificationStatus,
      derivedExpenseId: data.derivedExpenseId.present
          ? data.derivedExpenseId.value
          : this.derivedExpenseId,
      payloadHash: data.payloadHash.present
          ? data.payloadHash.value
          : this.payloadHash,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('CanonicalLedgerData(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('source: $source, ')
          ..write('sourceReference: $sourceReference, ')
          ..write('amount: $amount, ')
          ..write('currency: $currency, ')
          ..write('bookingDate: $bookingDate, ')
          ..write('description: $description, ')
          ..write('verificationStatus: $verificationStatus, ')
          ..write('derivedExpenseId: $derivedExpenseId, ')
          ..write('payloadHash: $payloadHash, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    source,
    sourceReference,
    amount,
    currency,
    bookingDate,
    description,
    verificationStatus,
    derivedExpenseId,
    payloadHash,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is CanonicalLedgerData &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.source == this.source &&
          other.sourceReference == this.sourceReference &&
          other.amount == this.amount &&
          other.currency == this.currency &&
          other.bookingDate == this.bookingDate &&
          other.description == this.description &&
          other.verificationStatus == this.verificationStatus &&
          other.derivedExpenseId == this.derivedExpenseId &&
          other.payloadHash == this.payloadHash &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class CanonicalLedgerCompanion extends UpdateCompanion<CanonicalLedgerData> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String> source;
  final Value<String?> sourceReference;
  final Value<int> amount;
  final Value<String> currency;
  final Value<DateTime> bookingDate;
  final Value<String?> description;
  final Value<String> verificationStatus;
  final Value<String?> derivedExpenseId;
  final Value<String?> payloadHash;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> rowid;
  const CanonicalLedgerCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.source = const Value.absent(),
    this.sourceReference = const Value.absent(),
    this.amount = const Value.absent(),
    this.currency = const Value.absent(),
    this.bookingDate = const Value.absent(),
    this.description = const Value.absent(),
    this.verificationStatus = const Value.absent(),
    this.derivedExpenseId = const Value.absent(),
    this.payloadHash = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  CanonicalLedgerCompanion.insert({
    required String id,
    required String userId,
    required String source,
    this.sourceReference = const Value.absent(),
    required int amount,
    this.currency = const Value.absent(),
    required DateTime bookingDate,
    this.description = const Value.absent(),
    this.verificationStatus = const Value.absent(),
    this.derivedExpenseId = const Value.absent(),
    this.payloadHash = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       source = Value(source),
       amount = Value(amount),
       bookingDate = Value(bookingDate);
  static Insertable<CanonicalLedgerData> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? source,
    Expression<String>? sourceReference,
    Expression<int>? amount,
    Expression<String>? currency,
    Expression<DateTime>? bookingDate,
    Expression<String>? description,
    Expression<String>? verificationStatus,
    Expression<String>? derivedExpenseId,
    Expression<String>? payloadHash,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (source != null) 'source': source,
      if (sourceReference != null) 'source_reference': sourceReference,
      if (amount != null) 'amount': amount,
      if (currency != null) 'currency': currency,
      if (bookingDate != null) 'booking_date': bookingDate,
      if (description != null) 'description': description,
      if (verificationStatus != null) 'verification_status': verificationStatus,
      if (derivedExpenseId != null) 'derived_expense_id': derivedExpenseId,
      if (payloadHash != null) 'payload_hash': payloadHash,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (rowid != null) 'rowid': rowid,
    });
  }

  CanonicalLedgerCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String>? source,
    Value<String?>? sourceReference,
    Value<int>? amount,
    Value<String>? currency,
    Value<DateTime>? bookingDate,
    Value<String?>? description,
    Value<String>? verificationStatus,
    Value<String?>? derivedExpenseId,
    Value<String?>? payloadHash,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? rowid,
  }) {
    return CanonicalLedgerCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      source: source ?? this.source,
      sourceReference: sourceReference ?? this.sourceReference,
      amount: amount ?? this.amount,
      currency: currency ?? this.currency,
      bookingDate: bookingDate ?? this.bookingDate,
      description: description ?? this.description,
      verificationStatus: verificationStatus ?? this.verificationStatus,
      derivedExpenseId: derivedExpenseId ?? this.derivedExpenseId,
      payloadHash: payloadHash ?? this.payloadHash,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (source.present) {
      map['source'] = Variable<String>(source.value);
    }
    if (sourceReference.present) {
      map['source_reference'] = Variable<String>(sourceReference.value);
    }
    if (amount.present) {
      map['amount'] = Variable<int>(amount.value);
    }
    if (currency.present) {
      map['currency'] = Variable<String>(currency.value);
    }
    if (bookingDate.present) {
      map['booking_date'] = Variable<DateTime>(bookingDate.value);
    }
    if (description.present) {
      map['description'] = Variable<String>(description.value);
    }
    if (verificationStatus.present) {
      map['verification_status'] = Variable<String>(verificationStatus.value);
    }
    if (derivedExpenseId.present) {
      map['derived_expense_id'] = Variable<String>(derivedExpenseId.value);
    }
    if (payloadHash.present) {
      map['payload_hash'] = Variable<String>(payloadHash.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CanonicalLedgerCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('source: $source, ')
          ..write('sourceReference: $sourceReference, ')
          ..write('amount: $amount, ')
          ..write('currency: $currency, ')
          ..write('bookingDate: $bookingDate, ')
          ..write('description: $description, ')
          ..write('verificationStatus: $verificationStatus, ')
          ..write('derivedExpenseId: $derivedExpenseId, ')
          ..write('payloadHash: $payloadHash, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $UserConsentsTable extends UserConsents
    with TableInfo<$UserConsentsTable, UserConsent> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $UserConsentsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _userIdMeta = const VerificationMeta('userId');
  @override
  late final GeneratedColumn<String> userId = GeneratedColumn<String>(
    'user_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES users (id)',
    ),
  );
  static const VerificationMeta _scopeMeta = const VerificationMeta('scope');
  @override
  late final GeneratedColumn<String> scope = GeneratedColumn<String>(
    'scope',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('active'),
  );
  static const VerificationMeta _grantedAtMeta = const VerificationMeta(
    'grantedAt',
  );
  @override
  late final GeneratedColumn<DateTime> grantedAt = GeneratedColumn<DateTime>(
    'granted_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _expiresAtMeta = const VerificationMeta(
    'expiresAt',
  );
  @override
  late final GeneratedColumn<DateTime> expiresAt = GeneratedColumn<DateTime>(
    'expires_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _evidenceJsonMeta = const VerificationMeta(
    'evidenceJson',
  );
  @override
  late final GeneratedColumn<String> evidenceJson = GeneratedColumn<String>(
    'evidence_json',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    userId,
    scope,
    status,
    grantedAt,
    expiresAt,
    evidenceJson,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'user_consents';
  @override
  VerificationContext validateIntegrity(
    Insertable<UserConsent> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('user_id')) {
      context.handle(
        _userIdMeta,
        userId.isAcceptableOrUnknown(data['user_id']!, _userIdMeta),
      );
    } else if (isInserting) {
      context.missing(_userIdMeta);
    }
    if (data.containsKey('scope')) {
      context.handle(
        _scopeMeta,
        scope.isAcceptableOrUnknown(data['scope']!, _scopeMeta),
      );
    } else if (isInserting) {
      context.missing(_scopeMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    }
    if (data.containsKey('granted_at')) {
      context.handle(
        _grantedAtMeta,
        grantedAt.isAcceptableOrUnknown(data['granted_at']!, _grantedAtMeta),
      );
    }
    if (data.containsKey('expires_at')) {
      context.handle(
        _expiresAtMeta,
        expiresAt.isAcceptableOrUnknown(data['expires_at']!, _expiresAtMeta),
      );
    }
    if (data.containsKey('evidence_json')) {
      context.handle(
        _evidenceJsonMeta,
        evidenceJson.isAcceptableOrUnknown(
          data['evidence_json']!,
          _evidenceJsonMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  UserConsent map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return UserConsent(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      userId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}user_id'],
      )!,
      scope: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}scope'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      grantedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}granted_at'],
      )!,
      expiresAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}expires_at'],
      ),
      evidenceJson: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}evidence_json'],
      ),
    );
  }

  @override
  $UserConsentsTable createAlias(String alias) {
    return $UserConsentsTable(attachedDatabase, alias);
  }
}

class UserConsent extends DataClass implements Insertable<UserConsent> {
  final String id;
  final String userId;

  /// Permission scope: 'bank_read_transactions', 'ocr_storage'
  final String scope;
  final String status;
  final DateTime grantedAt;
  final DateTime? expiresAt;

  /// Compliance evidence (e.g., signed agreement hash)
  final String? evidenceJson;
  const UserConsent({
    required this.id,
    required this.userId,
    required this.scope,
    required this.status,
    required this.grantedAt,
    this.expiresAt,
    this.evidenceJson,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['user_id'] = Variable<String>(userId);
    map['scope'] = Variable<String>(scope);
    map['status'] = Variable<String>(status);
    map['granted_at'] = Variable<DateTime>(grantedAt);
    if (!nullToAbsent || expiresAt != null) {
      map['expires_at'] = Variable<DateTime>(expiresAt);
    }
    if (!nullToAbsent || evidenceJson != null) {
      map['evidence_json'] = Variable<String>(evidenceJson);
    }
    return map;
  }

  UserConsentsCompanion toCompanion(bool nullToAbsent) {
    return UserConsentsCompanion(
      id: Value(id),
      userId: Value(userId),
      scope: Value(scope),
      status: Value(status),
      grantedAt: Value(grantedAt),
      expiresAt: expiresAt == null && nullToAbsent
          ? const Value.absent()
          : Value(expiresAt),
      evidenceJson: evidenceJson == null && nullToAbsent
          ? const Value.absent()
          : Value(evidenceJson),
    );
  }

  factory UserConsent.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return UserConsent(
      id: serializer.fromJson<String>(json['id']),
      userId: serializer.fromJson<String>(json['userId']),
      scope: serializer.fromJson<String>(json['scope']),
      status: serializer.fromJson<String>(json['status']),
      grantedAt: serializer.fromJson<DateTime>(json['grantedAt']),
      expiresAt: serializer.fromJson<DateTime?>(json['expiresAt']),
      evidenceJson: serializer.fromJson<String?>(json['evidenceJson']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'userId': serializer.toJson<String>(userId),
      'scope': serializer.toJson<String>(scope),
      'status': serializer.toJson<String>(status),
      'grantedAt': serializer.toJson<DateTime>(grantedAt),
      'expiresAt': serializer.toJson<DateTime?>(expiresAt),
      'evidenceJson': serializer.toJson<String?>(evidenceJson),
    };
  }

  UserConsent copyWith({
    String? id,
    String? userId,
    String? scope,
    String? status,
    DateTime? grantedAt,
    Value<DateTime?> expiresAt = const Value.absent(),
    Value<String?> evidenceJson = const Value.absent(),
  }) => UserConsent(
    id: id ?? this.id,
    userId: userId ?? this.userId,
    scope: scope ?? this.scope,
    status: status ?? this.status,
    grantedAt: grantedAt ?? this.grantedAt,
    expiresAt: expiresAt.present ? expiresAt.value : this.expiresAt,
    evidenceJson: evidenceJson.present ? evidenceJson.value : this.evidenceJson,
  );
  UserConsent copyWithCompanion(UserConsentsCompanion data) {
    return UserConsent(
      id: data.id.present ? data.id.value : this.id,
      userId: data.userId.present ? data.userId.value : this.userId,
      scope: data.scope.present ? data.scope.value : this.scope,
      status: data.status.present ? data.status.value : this.status,
      grantedAt: data.grantedAt.present ? data.grantedAt.value : this.grantedAt,
      expiresAt: data.expiresAt.present ? data.expiresAt.value : this.expiresAt,
      evidenceJson: data.evidenceJson.present
          ? data.evidenceJson.value
          : this.evidenceJson,
    );
  }

  @override
  String toString() {
    return (StringBuffer('UserConsent(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('scope: $scope, ')
          ..write('status: $status, ')
          ..write('grantedAt: $grantedAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('evidenceJson: $evidenceJson')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    userId,
    scope,
    status,
    grantedAt,
    expiresAt,
    evidenceJson,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is UserConsent &&
          other.id == this.id &&
          other.userId == this.userId &&
          other.scope == this.scope &&
          other.status == this.status &&
          other.grantedAt == this.grantedAt &&
          other.expiresAt == this.expiresAt &&
          other.evidenceJson == this.evidenceJson);
}

class UserConsentsCompanion extends UpdateCompanion<UserConsent> {
  final Value<String> id;
  final Value<String> userId;
  final Value<String> scope;
  final Value<String> status;
  final Value<DateTime> grantedAt;
  final Value<DateTime?> expiresAt;
  final Value<String?> evidenceJson;
  final Value<int> rowid;
  const UserConsentsCompanion({
    this.id = const Value.absent(),
    this.userId = const Value.absent(),
    this.scope = const Value.absent(),
    this.status = const Value.absent(),
    this.grantedAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.evidenceJson = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  UserConsentsCompanion.insert({
    required String id,
    required String userId,
    required String scope,
    this.status = const Value.absent(),
    this.grantedAt = const Value.absent(),
    this.expiresAt = const Value.absent(),
    this.evidenceJson = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       userId = Value(userId),
       scope = Value(scope);
  static Insertable<UserConsent> custom({
    Expression<String>? id,
    Expression<String>? userId,
    Expression<String>? scope,
    Expression<String>? status,
    Expression<DateTime>? grantedAt,
    Expression<DateTime>? expiresAt,
    Expression<String>? evidenceJson,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (userId != null) 'user_id': userId,
      if (scope != null) 'scope': scope,
      if (status != null) 'status': status,
      if (grantedAt != null) 'granted_at': grantedAt,
      if (expiresAt != null) 'expires_at': expiresAt,
      if (evidenceJson != null) 'evidence_json': evidenceJson,
      if (rowid != null) 'rowid': rowid,
    });
  }

  UserConsentsCompanion copyWith({
    Value<String>? id,
    Value<String>? userId,
    Value<String>? scope,
    Value<String>? status,
    Value<DateTime>? grantedAt,
    Value<DateTime?>? expiresAt,
    Value<String?>? evidenceJson,
    Value<int>? rowid,
  }) {
    return UserConsentsCompanion(
      id: id ?? this.id,
      userId: userId ?? this.userId,
      scope: scope ?? this.scope,
      status: status ?? this.status,
      grantedAt: grantedAt ?? this.grantedAt,
      expiresAt: expiresAt ?? this.expiresAt,
      evidenceJson: evidenceJson ?? this.evidenceJson,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (userId.present) {
      map['user_id'] = Variable<String>(userId.value);
    }
    if (scope.present) {
      map['scope'] = Variable<String>(scope.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (grantedAt.present) {
      map['granted_at'] = Variable<DateTime>(grantedAt.value);
    }
    if (expiresAt.present) {
      map['expires_at'] = Variable<DateTime>(expiresAt.value);
    }
    if (evidenceJson.present) {
      map['evidence_json'] = Variable<String>(evidenceJson.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('UserConsentsCompanion(')
          ..write('id: $id, ')
          ..write('userId: $userId, ')
          ..write('scope: $scope, ')
          ..write('status: $status, ')
          ..write('grantedAt: $grantedAt, ')
          ..write('expiresAt: $expiresAt, ')
          ..write('evidenceJson: $evidenceJson, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $FinancialIngestionLogsTable extends FinancialIngestionLogs
    with TableInfo<$FinancialIngestionLogsTable, FinancialIngestionLog> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $FinancialIngestionLogsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _providerMeta = const VerificationMeta(
    'provider',
  );
  @override
  late final GeneratedColumn<String> provider = GeneratedColumn<String>(
    'provider',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _statusMeta = const VerificationMeta('status');
  @override
  late final GeneratedColumn<String> status = GeneratedColumn<String>(
    'status',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _startedAtMeta = const VerificationMeta(
    'startedAt',
  );
  @override
  late final GeneratedColumn<DateTime> startedAt = GeneratedColumn<DateTime>(
    'started_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _completedAtMeta = const VerificationMeta(
    'completedAt',
  );
  @override
  late final GeneratedColumn<DateTime> completedAt = GeneratedColumn<DateTime>(
    'completed_at',
    aliasedName,
    true,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _recordsCountMeta = const VerificationMeta(
    'recordsCount',
  );
  @override
  late final GeneratedColumn<int> recordsCount = GeneratedColumn<int>(
    'records_count',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _errorMessageMeta = const VerificationMeta(
    'errorMessage',
  );
  @override
  late final GeneratedColumn<String> errorMessage = GeneratedColumn<String>(
    'error_message',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    provider,
    status,
    startedAt,
    completedAt,
    recordsCount,
    errorMessage,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'financial_ingestion_logs';
  @override
  VerificationContext validateIntegrity(
    Insertable<FinancialIngestionLog> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('provider')) {
      context.handle(
        _providerMeta,
        provider.isAcceptableOrUnknown(data['provider']!, _providerMeta),
      );
    } else if (isInserting) {
      context.missing(_providerMeta);
    }
    if (data.containsKey('status')) {
      context.handle(
        _statusMeta,
        status.isAcceptableOrUnknown(data['status']!, _statusMeta),
      );
    } else if (isInserting) {
      context.missing(_statusMeta);
    }
    if (data.containsKey('started_at')) {
      context.handle(
        _startedAtMeta,
        startedAt.isAcceptableOrUnknown(data['started_at']!, _startedAtMeta),
      );
    }
    if (data.containsKey('completed_at')) {
      context.handle(
        _completedAtMeta,
        completedAt.isAcceptableOrUnknown(
          data['completed_at']!,
          _completedAtMeta,
        ),
      );
    }
    if (data.containsKey('records_count')) {
      context.handle(
        _recordsCountMeta,
        recordsCount.isAcceptableOrUnknown(
          data['records_count']!,
          _recordsCountMeta,
        ),
      );
    }
    if (data.containsKey('error_message')) {
      context.handle(
        _errorMessageMeta,
        errorMessage.isAcceptableOrUnknown(
          data['error_message']!,
          _errorMessageMeta,
        ),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  FinancialIngestionLog map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return FinancialIngestionLog(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      provider: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}provider'],
      )!,
      status: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}status'],
      )!,
      startedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}started_at'],
      )!,
      completedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}completed_at'],
      ),
      recordsCount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}records_count'],
      ),
      errorMessage: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}error_message'],
      ),
    );
  }

  @override
  $FinancialIngestionLogsTable createAlias(String alias) {
    return $FinancialIngestionLogsTable(attachedDatabase, alias);
  }
}

class FinancialIngestionLog extends DataClass
    implements Insertable<FinancialIngestionLog> {
  final String id;
  final String provider;

  /// Status: 'started', 'normalizing', 'completed', 'failed'
  final String status;
  final DateTime startedAt;
  final DateTime? completedAt;
  final int? recordsCount;
  final String? errorMessage;
  const FinancialIngestionLog({
    required this.id,
    required this.provider,
    required this.status,
    required this.startedAt,
    this.completedAt,
    this.recordsCount,
    this.errorMessage,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['provider'] = Variable<String>(provider);
    map['status'] = Variable<String>(status);
    map['started_at'] = Variable<DateTime>(startedAt);
    if (!nullToAbsent || completedAt != null) {
      map['completed_at'] = Variable<DateTime>(completedAt);
    }
    if (!nullToAbsent || recordsCount != null) {
      map['records_count'] = Variable<int>(recordsCount);
    }
    if (!nullToAbsent || errorMessage != null) {
      map['error_message'] = Variable<String>(errorMessage);
    }
    return map;
  }

  FinancialIngestionLogsCompanion toCompanion(bool nullToAbsent) {
    return FinancialIngestionLogsCompanion(
      id: Value(id),
      provider: Value(provider),
      status: Value(status),
      startedAt: Value(startedAt),
      completedAt: completedAt == null && nullToAbsent
          ? const Value.absent()
          : Value(completedAt),
      recordsCount: recordsCount == null && nullToAbsent
          ? const Value.absent()
          : Value(recordsCount),
      errorMessage: errorMessage == null && nullToAbsent
          ? const Value.absent()
          : Value(errorMessage),
    );
  }

  factory FinancialIngestionLog.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return FinancialIngestionLog(
      id: serializer.fromJson<String>(json['id']),
      provider: serializer.fromJson<String>(json['provider']),
      status: serializer.fromJson<String>(json['status']),
      startedAt: serializer.fromJson<DateTime>(json['startedAt']),
      completedAt: serializer.fromJson<DateTime?>(json['completedAt']),
      recordsCount: serializer.fromJson<int?>(json['recordsCount']),
      errorMessage: serializer.fromJson<String?>(json['errorMessage']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'provider': serializer.toJson<String>(provider),
      'status': serializer.toJson<String>(status),
      'startedAt': serializer.toJson<DateTime>(startedAt),
      'completedAt': serializer.toJson<DateTime?>(completedAt),
      'recordsCount': serializer.toJson<int?>(recordsCount),
      'errorMessage': serializer.toJson<String?>(errorMessage),
    };
  }

  FinancialIngestionLog copyWith({
    String? id,
    String? provider,
    String? status,
    DateTime? startedAt,
    Value<DateTime?> completedAt = const Value.absent(),
    Value<int?> recordsCount = const Value.absent(),
    Value<String?> errorMessage = const Value.absent(),
  }) => FinancialIngestionLog(
    id: id ?? this.id,
    provider: provider ?? this.provider,
    status: status ?? this.status,
    startedAt: startedAt ?? this.startedAt,
    completedAt: completedAt.present ? completedAt.value : this.completedAt,
    recordsCount: recordsCount.present ? recordsCount.value : this.recordsCount,
    errorMessage: errorMessage.present ? errorMessage.value : this.errorMessage,
  );
  FinancialIngestionLog copyWithCompanion(
    FinancialIngestionLogsCompanion data,
  ) {
    return FinancialIngestionLog(
      id: data.id.present ? data.id.value : this.id,
      provider: data.provider.present ? data.provider.value : this.provider,
      status: data.status.present ? data.status.value : this.status,
      startedAt: data.startedAt.present ? data.startedAt.value : this.startedAt,
      completedAt: data.completedAt.present
          ? data.completedAt.value
          : this.completedAt,
      recordsCount: data.recordsCount.present
          ? data.recordsCount.value
          : this.recordsCount,
      errorMessage: data.errorMessage.present
          ? data.errorMessage.value
          : this.errorMessage,
    );
  }

  @override
  String toString() {
    return (StringBuffer('FinancialIngestionLog(')
          ..write('id: $id, ')
          ..write('provider: $provider, ')
          ..write('status: $status, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('recordsCount: $recordsCount, ')
          ..write('errorMessage: $errorMessage')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    provider,
    status,
    startedAt,
    completedAt,
    recordsCount,
    errorMessage,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is FinancialIngestionLog &&
          other.id == this.id &&
          other.provider == this.provider &&
          other.status == this.status &&
          other.startedAt == this.startedAt &&
          other.completedAt == this.completedAt &&
          other.recordsCount == this.recordsCount &&
          other.errorMessage == this.errorMessage);
}

class FinancialIngestionLogsCompanion
    extends UpdateCompanion<FinancialIngestionLog> {
  final Value<String> id;
  final Value<String> provider;
  final Value<String> status;
  final Value<DateTime> startedAt;
  final Value<DateTime?> completedAt;
  final Value<int?> recordsCount;
  final Value<String?> errorMessage;
  final Value<int> rowid;
  const FinancialIngestionLogsCompanion({
    this.id = const Value.absent(),
    this.provider = const Value.absent(),
    this.status = const Value.absent(),
    this.startedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.recordsCount = const Value.absent(),
    this.errorMessage = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  FinancialIngestionLogsCompanion.insert({
    required String id,
    required String provider,
    required String status,
    this.startedAt = const Value.absent(),
    this.completedAt = const Value.absent(),
    this.recordsCount = const Value.absent(),
    this.errorMessage = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       provider = Value(provider),
       status = Value(status);
  static Insertable<FinancialIngestionLog> custom({
    Expression<String>? id,
    Expression<String>? provider,
    Expression<String>? status,
    Expression<DateTime>? startedAt,
    Expression<DateTime>? completedAt,
    Expression<int>? recordsCount,
    Expression<String>? errorMessage,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (provider != null) 'provider': provider,
      if (status != null) 'status': status,
      if (startedAt != null) 'started_at': startedAt,
      if (completedAt != null) 'completed_at': completedAt,
      if (recordsCount != null) 'records_count': recordsCount,
      if (errorMessage != null) 'error_message': errorMessage,
      if (rowid != null) 'rowid': rowid,
    });
  }

  FinancialIngestionLogsCompanion copyWith({
    Value<String>? id,
    Value<String>? provider,
    Value<String>? status,
    Value<DateTime>? startedAt,
    Value<DateTime?>? completedAt,
    Value<int?>? recordsCount,
    Value<String?>? errorMessage,
    Value<int>? rowid,
  }) {
    return FinancialIngestionLogsCompanion(
      id: id ?? this.id,
      provider: provider ?? this.provider,
      status: status ?? this.status,
      startedAt: startedAt ?? this.startedAt,
      completedAt: completedAt ?? this.completedAt,
      recordsCount: recordsCount ?? this.recordsCount,
      errorMessage: errorMessage ?? this.errorMessage,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (provider.present) {
      map['provider'] = Variable<String>(provider.value);
    }
    if (status.present) {
      map['status'] = Variable<String>(status.value);
    }
    if (startedAt.present) {
      map['started_at'] = Variable<DateTime>(startedAt.value);
    }
    if (completedAt.present) {
      map['completed_at'] = Variable<DateTime>(completedAt.value);
    }
    if (recordsCount.present) {
      map['records_count'] = Variable<int>(recordsCount.value);
    }
    if (errorMessage.present) {
      map['error_message'] = Variable<String>(errorMessage.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('FinancialIngestionLogsCompanion(')
          ..write('id: $id, ')
          ..write('provider: $provider, ')
          ..write('status: $status, ')
          ..write('startedAt: $startedAt, ')
          ..write('completedAt: $completedAt, ')
          ..write('recordsCount: $recordsCount, ')
          ..write('errorMessage: $errorMessage, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

class $SplitTransactionsTable extends SplitTransactions
    with TableInfo<$SplitTransactionsTable, SplitTransaction> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SplitTransactionsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<String> id = GeneratedColumn<String>(
    'id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _expenseIdMeta = const VerificationMeta(
    'expenseId',
  );
  @override
  late final GeneratedColumn<String> expenseId = GeneratedColumn<String>(
    'expense_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES expenses (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _semiBudgetIdMeta = const VerificationMeta(
    'semiBudgetId',
  );
  @override
  late final GeneratedColumn<String> semiBudgetId = GeneratedColumn<String>(
    'semi_budget_id',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES semi_budgets (id) ON DELETE CASCADE',
    ),
  );
  static const VerificationMeta _amountMeta = const VerificationMeta('amount');
  @override
  late final GeneratedColumn<int> amount = GeneratedColumn<int>(
    'amount',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _notesMeta = const VerificationMeta('notes');
  @override
  late final GeneratedColumn<String> notes = GeneratedColumn<String>(
    'notes',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<DateTime> createdAt = GeneratedColumn<DateTime>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<DateTime> updatedAt = GeneratedColumn<DateTime>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.dateTime,
    requiredDuringInsert: false,
    defaultValue: currentDateAndTime,
  );
  static const VerificationMeta _revisionMeta = const VerificationMeta(
    'revision',
  );
  @override
  late final GeneratedColumn<int> revision = GeneratedColumn<int>(
    'revision',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultValue: const Constant(0),
  );
  static const VerificationMeta _syncStateMeta = const VerificationMeta(
    'syncState',
  );
  @override
  late final GeneratedColumn<String> syncState = GeneratedColumn<String>(
    'sync_state',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
    defaultValue: const Constant('clean'),
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    expenseId,
    semiBudgetId,
    amount,
    notes,
    createdAt,
    updatedAt,
    revision,
    syncState,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'split_transactions';
  @override
  VerificationContext validateIntegrity(
    Insertable<SplitTransaction> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    } else if (isInserting) {
      context.missing(_idMeta);
    }
    if (data.containsKey('expense_id')) {
      context.handle(
        _expenseIdMeta,
        expenseId.isAcceptableOrUnknown(data['expense_id']!, _expenseIdMeta),
      );
    } else if (isInserting) {
      context.missing(_expenseIdMeta);
    }
    if (data.containsKey('semi_budget_id')) {
      context.handle(
        _semiBudgetIdMeta,
        semiBudgetId.isAcceptableOrUnknown(
          data['semi_budget_id']!,
          _semiBudgetIdMeta,
        ),
      );
    } else if (isInserting) {
      context.missing(_semiBudgetIdMeta);
    }
    if (data.containsKey('amount')) {
      context.handle(
        _amountMeta,
        amount.isAcceptableOrUnknown(data['amount']!, _amountMeta),
      );
    } else if (isInserting) {
      context.missing(_amountMeta);
    }
    if (data.containsKey('notes')) {
      context.handle(
        _notesMeta,
        notes.isAcceptableOrUnknown(data['notes']!, _notesMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    }
    if (data.containsKey('revision')) {
      context.handle(
        _revisionMeta,
        revision.isAcceptableOrUnknown(data['revision']!, _revisionMeta),
      );
    }
    if (data.containsKey('sync_state')) {
      context.handle(
        _syncStateMeta,
        syncState.isAcceptableOrUnknown(data['sync_state']!, _syncStateMeta),
      );
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  SplitTransaction map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return SplitTransaction(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}id'],
      )!,
      expenseId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}expense_id'],
      )!,
      semiBudgetId: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}semi_budget_id'],
      )!,
      amount: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}amount'],
      )!,
      notes: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}notes'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.dateTime,
        data['${effectivePrefix}updated_at'],
      )!,
      revision: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}revision'],
      )!,
      syncState: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}sync_state'],
      )!,
    );
  }

  @override
  $SplitTransactionsTable createAlias(String alias) {
    return $SplitTransactionsTable(attachedDatabase, alias);
  }
}

class SplitTransaction extends DataClass
    implements Insertable<SplitTransaction> {
  final String id;
  final String expenseId;
  final String semiBudgetId;
  final int amount;
  final String? notes;
  final DateTime createdAt;
  final DateTime updatedAt;
  final int revision;
  final String syncState;
  const SplitTransaction({
    required this.id,
    required this.expenseId,
    required this.semiBudgetId,
    required this.amount,
    this.notes,
    required this.createdAt,
    required this.updatedAt,
    required this.revision,
    required this.syncState,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<String>(id);
    map['expense_id'] = Variable<String>(expenseId);
    map['semi_budget_id'] = Variable<String>(semiBudgetId);
    map['amount'] = Variable<int>(amount);
    if (!nullToAbsent || notes != null) {
      map['notes'] = Variable<String>(notes);
    }
    map['created_at'] = Variable<DateTime>(createdAt);
    map['updated_at'] = Variable<DateTime>(updatedAt);
    map['revision'] = Variable<int>(revision);
    map['sync_state'] = Variable<String>(syncState);
    return map;
  }

  SplitTransactionsCompanion toCompanion(bool nullToAbsent) {
    return SplitTransactionsCompanion(
      id: Value(id),
      expenseId: Value(expenseId),
      semiBudgetId: Value(semiBudgetId),
      amount: Value(amount),
      notes: notes == null && nullToAbsent
          ? const Value.absent()
          : Value(notes),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
      revision: Value(revision),
      syncState: Value(syncState),
    );
  }

  factory SplitTransaction.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return SplitTransaction(
      id: serializer.fromJson<String>(json['id']),
      expenseId: serializer.fromJson<String>(json['expenseId']),
      semiBudgetId: serializer.fromJson<String>(json['semiBudgetId']),
      amount: serializer.fromJson<int>(json['amount']),
      notes: serializer.fromJson<String?>(json['notes']),
      createdAt: serializer.fromJson<DateTime>(json['createdAt']),
      updatedAt: serializer.fromJson<DateTime>(json['updatedAt']),
      revision: serializer.fromJson<int>(json['revision']),
      syncState: serializer.fromJson<String>(json['syncState']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<String>(id),
      'expenseId': serializer.toJson<String>(expenseId),
      'semiBudgetId': serializer.toJson<String>(semiBudgetId),
      'amount': serializer.toJson<int>(amount),
      'notes': serializer.toJson<String?>(notes),
      'createdAt': serializer.toJson<DateTime>(createdAt),
      'updatedAt': serializer.toJson<DateTime>(updatedAt),
      'revision': serializer.toJson<int>(revision),
      'syncState': serializer.toJson<String>(syncState),
    };
  }

  SplitTransaction copyWith({
    String? id,
    String? expenseId,
    String? semiBudgetId,
    int? amount,
    Value<String?> notes = const Value.absent(),
    DateTime? createdAt,
    DateTime? updatedAt,
    int? revision,
    String? syncState,
  }) => SplitTransaction(
    id: id ?? this.id,
    expenseId: expenseId ?? this.expenseId,
    semiBudgetId: semiBudgetId ?? this.semiBudgetId,
    amount: amount ?? this.amount,
    notes: notes.present ? notes.value : this.notes,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
    revision: revision ?? this.revision,
    syncState: syncState ?? this.syncState,
  );
  SplitTransaction copyWithCompanion(SplitTransactionsCompanion data) {
    return SplitTransaction(
      id: data.id.present ? data.id.value : this.id,
      expenseId: data.expenseId.present ? data.expenseId.value : this.expenseId,
      semiBudgetId: data.semiBudgetId.present
          ? data.semiBudgetId.value
          : this.semiBudgetId,
      amount: data.amount.present ? data.amount.value : this.amount,
      notes: data.notes.present ? data.notes.value : this.notes,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
      revision: data.revision.present ? data.revision.value : this.revision,
      syncState: data.syncState.present ? data.syncState.value : this.syncState,
    );
  }

  @override
  String toString() {
    return (StringBuffer('SplitTransaction(')
          ..write('id: $id, ')
          ..write('expenseId: $expenseId, ')
          ..write('semiBudgetId: $semiBudgetId, ')
          ..write('amount: $amount, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    expenseId,
    semiBudgetId,
    amount,
    notes,
    createdAt,
    updatedAt,
    revision,
    syncState,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is SplitTransaction &&
          other.id == this.id &&
          other.expenseId == this.expenseId &&
          other.semiBudgetId == this.semiBudgetId &&
          other.amount == this.amount &&
          other.notes == this.notes &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt &&
          other.revision == this.revision &&
          other.syncState == this.syncState);
}

class SplitTransactionsCompanion extends UpdateCompanion<SplitTransaction> {
  final Value<String> id;
  final Value<String> expenseId;
  final Value<String> semiBudgetId;
  final Value<int> amount;
  final Value<String?> notes;
  final Value<DateTime> createdAt;
  final Value<DateTime> updatedAt;
  final Value<int> revision;
  final Value<String> syncState;
  final Value<int> rowid;
  const SplitTransactionsCompanion({
    this.id = const Value.absent(),
    this.expenseId = const Value.absent(),
    this.semiBudgetId = const Value.absent(),
    this.amount = const Value.absent(),
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.rowid = const Value.absent(),
  });
  SplitTransactionsCompanion.insert({
    required String id,
    required String expenseId,
    required String semiBudgetId,
    required int amount,
    this.notes = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
    this.revision = const Value.absent(),
    this.syncState = const Value.absent(),
    this.rowid = const Value.absent(),
  }) : id = Value(id),
       expenseId = Value(expenseId),
       semiBudgetId = Value(semiBudgetId),
       amount = Value(amount);
  static Insertable<SplitTransaction> custom({
    Expression<String>? id,
    Expression<String>? expenseId,
    Expression<String>? semiBudgetId,
    Expression<int>? amount,
    Expression<String>? notes,
    Expression<DateTime>? createdAt,
    Expression<DateTime>? updatedAt,
    Expression<int>? revision,
    Expression<String>? syncState,
    Expression<int>? rowid,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (expenseId != null) 'expense_id': expenseId,
      if (semiBudgetId != null) 'semi_budget_id': semiBudgetId,
      if (amount != null) 'amount': amount,
      if (notes != null) 'notes': notes,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
      if (revision != null) 'revision': revision,
      if (syncState != null) 'sync_state': syncState,
      if (rowid != null) 'rowid': rowid,
    });
  }

  SplitTransactionsCompanion copyWith({
    Value<String>? id,
    Value<String>? expenseId,
    Value<String>? semiBudgetId,
    Value<int>? amount,
    Value<String?>? notes,
    Value<DateTime>? createdAt,
    Value<DateTime>? updatedAt,
    Value<int>? revision,
    Value<String>? syncState,
    Value<int>? rowid,
  }) {
    return SplitTransactionsCompanion(
      id: id ?? this.id,
      expenseId: expenseId ?? this.expenseId,
      semiBudgetId: semiBudgetId ?? this.semiBudgetId,
      amount: amount ?? this.amount,
      notes: notes ?? this.notes,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      revision: revision ?? this.revision,
      syncState: syncState ?? this.syncState,
      rowid: rowid ?? this.rowid,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<String>(id.value);
    }
    if (expenseId.present) {
      map['expense_id'] = Variable<String>(expenseId.value);
    }
    if (semiBudgetId.present) {
      map['semi_budget_id'] = Variable<String>(semiBudgetId.value);
    }
    if (amount.present) {
      map['amount'] = Variable<int>(amount.value);
    }
    if (notes.present) {
      map['notes'] = Variable<String>(notes.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<DateTime>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<DateTime>(updatedAt.value);
    }
    if (revision.present) {
      map['revision'] = Variable<int>(revision.value);
    }
    if (syncState.present) {
      map['sync_state'] = Variable<String>(syncState.value);
    }
    if (rowid.present) {
      map['rowid'] = Variable<int>(rowid.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SplitTransactionsCompanion(')
          ..write('id: $id, ')
          ..write('expenseId: $expenseId, ')
          ..write('semiBudgetId: $semiBudgetId, ')
          ..write('amount: $amount, ')
          ..write('notes: $notes, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt, ')
          ..write('revision: $revision, ')
          ..write('syncState: $syncState, ')
          ..write('rowid: $rowid')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $UsersTable users = $UsersTable(this);
  late final $BudgetsTable budgets = $BudgetsTable(this);
  late final $CategoriesTable categories = $CategoriesTable(this);
  late final $SemiBudgetsTable semiBudgets = $SemiBudgetsTable(this);
  late final $AccountsTable accounts = $AccountsTable(this);
  late final $SubCategoriesTable subCategories = $SubCategoriesTable(this);
  late final $ExpensesTable expenses = $ExpensesTable(this);
  late final $BudgetMembersTable budgetMembers = $BudgetMembersTable(this);
  late final $ActivityLogsTable activityLogs = $ActivityLogsTable(this);
  late final $AuditLogsTable auditLogs = $AuditLogsTable(this);
  late final $SyncQueueTable syncQueue = $SyncQueueTable(this);
  late final $RecurringExpensesTable recurringExpenses =
      $RecurringExpensesTable(this);
  late final $SubscriptionsTable subscriptions = $SubscriptionsTable(this);
  late final $SavingsGoalsTable savingsGoals = $SavingsGoalsTable(this);
  late final $LocationsTable locations = $LocationsTable(this);
  late final $GeocodingCacheTable geocodingCache = $GeocodingCacheTable(this);
  late final $ExpenseLocationsTable expenseLocations = $ExpenseLocationsTable(
    this,
  );
  late final $RecurringExpenseLocationsTable recurringExpenseLocations =
      $RecurringExpenseLocationsTable(this);
  late final $LocationAnalyticsTable locationAnalytics =
      $LocationAnalyticsTable(this);
  late final $GeofencesTable geofences = $GeofencesTable(this);
  late final $GeofenceEventsTable geofenceEvents = $GeofenceEventsTable(this);
  late final $ConflictsTable conflicts = $ConflictsTable(this);
  late final $AuditEventsTable auditEvents = $AuditEventsTable(this);
  late final $OutboxEventsTable outboxEvents = $OutboxEventsTable(this);
  late final $CategoryLearningTable categoryLearning = $CategoryLearningTable(
    this,
  );
  late final $SyncRecoveryStateTable syncRecoveryState =
      $SyncRecoveryStateTable(this);
  late final $SyncOperationsLogTable syncOperationsLog =
      $SyncOperationsLogTable(this);
  late final $SyncStateTransitionsTable syncStateTransitions =
      $SyncStateTransitionsTable(this);
  late final $FamilyGroupsTable familyGroups = $FamilyGroupsTable(this);
  late final $FamilyContactsTable familyContacts = $FamilyContactsTable(this);
  late final $FamilyRelationsTable familyRelations = $FamilyRelationsTable(
    this,
  );
  late final $KnowledgeArticlesTable knowledgeArticles =
      $KnowledgeArticlesTable(this);
  late final $FinancialTipsTable financialTips = $FinancialTipsTable(this);
  late final $AssetsTable assets = $AssetsTable(this);
  late final $LiabilitiesTable liabilities = $LiabilitiesTable(this);
  late final $ValuationHistoryTable valuationHistory = $ValuationHistoryTable(
    this,
  );
  late final $LedgerEventsTable ledgerEvents = $LedgerEventsTable(this);
  late final $BudgetHealthSnapshotsTable budgetHealthSnapshots =
      $BudgetHealthSnapshotsTable(this);
  late final $CanonicalLedgerTable canonicalLedger = $CanonicalLedgerTable(
    this,
  );
  late final $UserConsentsTable userConsents = $UserConsentsTable(this);
  late final $FinancialIngestionLogsTable financialIngestionLogs =
      $FinancialIngestionLogsTable(this);
  late final $SplitTransactionsTable splitTransactions =
      $SplitTransactionsTable(this);
  late final Index idxBudgetsOwner = Index(
    'idx_budgets_owner',
    'CREATE INDEX idx_budgets_owner ON budgets (owner_id)',
  );
  late final Index idxBudgetsDates = Index(
    'idx_budgets_dates',
    'CREATE INDEX idx_budgets_dates ON budgets (start_date, end_date)',
  );
  late final Index idxBudgetsType = Index(
    'idx_budgets_type',
    'CREATE INDEX idx_budgets_type ON budgets (type)',
  );
  late final Index idxBudgetsOwnerDates = Index(
    'idx_budgets_owner_dates',
    'CREATE INDEX idx_budgets_owner_dates ON budgets (owner_id, start_date, end_date)',
  );
  late final Index idxSemiBudgetsBudget = Index(
    'idx_semi_budgets_budget',
    'CREATE INDEX idx_semi_budgets_budget ON semi_budgets (budget_id)',
  );
  late final Index idxExpensesDate = Index(
    'idx_expenses_date',
    'CREATE INDEX idx_expenses_date ON expenses (date)',
  );
  late final Index idxExpensesBudget = Index(
    'idx_expenses_budget',
    'CREATE INDEX idx_expenses_budget ON expenses (budget_id)',
  );
  late final Index idxExpensesSemiBudget = Index(
    'idx_expenses_semi_budget',
    'CREATE INDEX idx_expenses_semi_budget ON expenses (semi_budget_id)',
  );
  late final Index idxExpensesCategory = Index(
    'idx_expenses_category',
    'CREATE INDEX idx_expenses_category ON expenses (category_id)',
  );
  late final Index idxExpensesEnteredBy = Index(
    'idx_expenses_entered_by',
    'CREATE INDEX idx_expenses_entered_by ON expenses (entered_by)',
  );
  late final Index idxExpensesUserDate = Index(
    'idx_expenses_user_date',
    'CREATE INDEX idx_expenses_user_date ON expenses (entered_by, date)',
  );
  late final Index idxExpensesMerchant = Index(
    'idx_expenses_merchant',
    'CREATE INDEX idx_expenses_merchant ON expenses (merchant_name)',
  );
  late final Index idxConflictsStatus = Index(
    'idx_conflicts_status',
    'CREATE INDEX idx_conflicts_status ON conflicts (status)',
  );
  late final Index idxConflictsEntity = Index(
    'idx_conflicts_entity',
    'CREATE INDEX idx_conflicts_entity ON conflicts (entity_type, entity_id)',
  );
  late final Index idxSubcategoriesCategory = Index(
    'idx_subcategories_category',
    'CREATE INDEX idx_subcategories_category ON sub_categories (category_id)',
  );
  late final Index idxAuditEventsType = Index(
    'idx_audit_events_type',
    'CREATE INDEX idx_audit_events_type ON audit_events (event_type)',
  );
  late final Index idxAuditEventsDate = Index(
    'idx_audit_events_date',
    'CREATE INDEX idx_audit_events_date ON audit_events (created_at)',
  );
  late final Index idxOutboxStatus = Index(
    'idx_outbox_status',
    'CREATE INDEX idx_outbox_status ON outbox_events (status)',
  );
  late final Index idxCategoryLearningPattern = Index(
    'idx_category_learning_pattern',
    'CREATE INDEX idx_category_learning_pattern ON category_learning (merchant_pattern)',
  );
  late final Index idxLearningTokens = Index(
    'idx_learning_tokens',
    'CREATE INDEX idx_learning_tokens ON category_learning (semantic_tokens)',
  );
  late final Index idxRelationsFrom = Index(
    'idx_relations_from',
    'CREATE INDEX idx_relations_from ON family_relations (from_contact_id)',
  );
  late final Index idxRelationsTo = Index(
    'idx_relations_to',
    'CREATE INDEX idx_relations_to ON family_relations (to_contact_id)',
  );
  late final Index idxKnowledgeTopic = Index(
    'idx_knowledge_topic',
    'CREATE INDEX idx_knowledge_topic ON knowledge_articles (topic)',
  );
  late final Index idxTipsCategory = Index(
    'idx_tips_category',
    'CREATE INDEX idx_tips_category ON financial_tips (category)',
  );
  late final Index idxAssetsUser = Index(
    'idx_assets_user',
    'CREATE INDEX idx_assets_user ON assets (user_id)',
  );
  late final Index idxAssetsType = Index(
    'idx_assets_type',
    'CREATE INDEX idx_assets_type ON assets (type)',
  );
  late final Index idxLiabilitiesUser = Index(
    'idx_liabilities_user',
    'CREATE INDEX idx_liabilities_user ON liabilities (user_id)',
  );
  late final Index idxValuationEntity = Index(
    'idx_valuation_entity',
    'CREATE INDEX idx_valuation_entity ON valuation_history (entity_type, entity_id)',
  );
  late final Index idxValuationDate = Index(
    'idx_valuation_date',
    'CREATE INDEX idx_valuation_date ON valuation_history (date)',
  );
  late final Index idxLedgerTimestamp = Index(
    'idx_ledger_timestamp',
    'CREATE INDEX idx_ledger_timestamp ON ledger_events (timestamp)',
  );
  late final Index idxLedgerEntity = Index(
    'idx_ledger_entity',
    'CREATE INDEX idx_ledger_entity ON ledger_events (entity_type, entity_id)',
  );
  late final Index idxHealthSnapshotsUser = Index(
    'idx_health_snapshots_user',
    'CREATE INDEX idx_health_snapshots_user ON budget_health_snapshots (user_id)',
  );
  late final Index idxHealthSnapshotsDate = Index(
    'idx_health_snapshots_date',
    'CREATE INDEX idx_health_snapshots_date ON budget_health_snapshots (timestamp)',
  );
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [
    users,
    budgets,
    categories,
    semiBudgets,
    accounts,
    subCategories,
    expenses,
    budgetMembers,
    activityLogs,
    auditLogs,
    syncQueue,
    recurringExpenses,
    subscriptions,
    savingsGoals,
    locations,
    geocodingCache,
    expenseLocations,
    recurringExpenseLocations,
    locationAnalytics,
    geofences,
    geofenceEvents,
    conflicts,
    auditEvents,
    outboxEvents,
    categoryLearning,
    syncRecoveryState,
    syncOperationsLog,
    syncStateTransitions,
    familyGroups,
    familyContacts,
    familyRelations,
    knowledgeArticles,
    financialTips,
    assets,
    liabilities,
    valuationHistory,
    ledgerEvents,
    budgetHealthSnapshots,
    canonicalLedger,
    userConsents,
    financialIngestionLogs,
    splitTransactions,
    idxBudgetsOwner,
    idxBudgetsDates,
    idxBudgetsType,
    idxBudgetsOwnerDates,
    idxSemiBudgetsBudget,
    idxExpensesDate,
    idxExpensesBudget,
    idxExpensesSemiBudget,
    idxExpensesCategory,
    idxExpensesEnteredBy,
    idxExpensesUserDate,
    idxExpensesMerchant,
    idxConflictsStatus,
    idxConflictsEntity,
    idxSubcategoriesCategory,
    idxAuditEventsType,
    idxAuditEventsDate,
    idxOutboxStatus,
    idxCategoryLearningPattern,
    idxLearningTokens,
    idxRelationsFrom,
    idxRelationsTo,
    idxKnowledgeTopic,
    idxTipsCategory,
    idxAssetsUser,
    idxAssetsType,
    idxLiabilitiesUser,
    idxValuationEntity,
    idxValuationDate,
    idxLedgerTimestamp,
    idxLedgerEntity,
    idxHealthSnapshotsUser,
    idxHealthSnapshotsDate,
  ];
  @override
  StreamQueryUpdateRules get streamUpdateRules => const StreamQueryUpdateRules([
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'users',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('budgets', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'budgets',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('semi_budgets', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'semi_budgets',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('semi_budgets', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'categories',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('sub_categories', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'budgets',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('expenses', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'semi_budgets',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('expenses', kind: UpdateKind.update)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'users',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('expenses', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'budgets',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('budget_members', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'sub_categories',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('category_learning', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'users',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('family_groups', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'users',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('family_contacts', kind: UpdateKind.update)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'family_contacts',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('family_relations', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'family_contacts',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('family_relations', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'users',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('assets', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'users',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('liabilities', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'users',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('budget_health_snapshots', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'expenses',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('split_transactions', kind: UpdateKind.delete)],
    ),
    WritePropagation(
      on: TableUpdateQuery.onTableName(
        'semi_budgets',
        limitUpdateKind: UpdateKind.delete,
      ),
      result: [TableUpdate('split_transactions', kind: UpdateKind.delete)],
    ),
  ]);
}

typedef $$UsersTableCreateCompanionBuilder =
    UsersCompanion Function({
      required String id,
      required String name,
      required String email,
      Value<String> languagePreference,
      Value<String?> avatarUrl,
      Value<String> subscriptionTier,
      Value<String> subscriptionStatus,
      Value<DateTime?> trialStartedAt,
      Value<DateTime?> trialExpiresAt,
      Value<DateTime?> subscriptionExpiresAt,
      Value<DateTime?> lastPaymentDate,
      Value<String?> paymentProvider,
      Value<String?> paymentProviderId,
      Value<int> ocrUsageCount,
      Value<DateTime?> ocrUsageResetAt,
      Value<String> experienceMode,
      Value<String> role,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<bool> isDeleted,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$UsersTableUpdateCompanionBuilder =
    UsersCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String> email,
      Value<String> languagePreference,
      Value<String?> avatarUrl,
      Value<String> subscriptionTier,
      Value<String> subscriptionStatus,
      Value<DateTime?> trialStartedAt,
      Value<DateTime?> trialExpiresAt,
      Value<DateTime?> subscriptionExpiresAt,
      Value<DateTime?> lastPaymentDate,
      Value<String?> paymentProvider,
      Value<String?> paymentProviderId,
      Value<int> ocrUsageCount,
      Value<DateTime?> ocrUsageResetAt,
      Value<String> experienceMode,
      Value<String> role,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<bool> isDeleted,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$UsersTableReferences
    extends BaseReferences<_$AppDatabase, $UsersTable, User> {
  $$UsersTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$BudgetsTable, List<Budget>> _budgetsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.budgets,
    aliasName: $_aliasNameGenerator(db.users.id, db.budgets.ownerId),
  );

  $$BudgetsTableProcessedTableManager get budgetsRefs {
    final manager = $$BudgetsTableTableManager(
      $_db,
      $_db.budgets,
    ).filter((f) => f.ownerId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_budgetsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$CategoriesTable, List<Category>>
  _categoriesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.categories,
    aliasName: $_aliasNameGenerator(db.users.id, db.categories.ownerId),
  );

  $$CategoriesTableProcessedTableManager get categoriesRefs {
    final manager = $$CategoriesTableTableManager(
      $_db,
      $_db.categories,
    ).filter((f) => f.ownerId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_categoriesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$AccountsTable, List<Account>> _accountsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.accounts,
    aliasName: $_aliasNameGenerator(db.users.id, db.accounts.userId),
  );

  $$AccountsTableProcessedTableManager get accountsRefs {
    final manager = $$AccountsTableTableManager(
      $_db,
      $_db.accounts,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_accountsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SubCategoriesTable, List<SubCategory>>
  _subCategoriesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.subCategories,
    aliasName: $_aliasNameGenerator(db.users.id, db.subCategories.ownerId),
  );

  $$SubCategoriesTableProcessedTableManager get subCategoriesRefs {
    final manager = $$SubCategoriesTableTableManager(
      $_db,
      $_db.subCategories,
    ).filter((f) => f.ownerId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_subCategoriesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ExpensesTable, List<Expense>> _expensesRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.expenses,
    aliasName: $_aliasNameGenerator(db.users.id, db.expenses.enteredBy),
  );

  $$ExpensesTableProcessedTableManager get expensesRefs {
    final manager = $$ExpensesTableTableManager(
      $_db,
      $_db.expenses,
    ).filter((f) => f.enteredBy.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_expensesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ActivityLogsTable, List<ActivityLog>>
  _activityLogsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.activityLogs,
    aliasName: $_aliasNameGenerator(db.users.id, db.activityLogs.userId),
  );

  $$ActivityLogsTableProcessedTableManager get activityLogsRefs {
    final manager = $$ActivityLogsTableTableManager(
      $_db,
      $_db.activityLogs,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_activityLogsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$AuditLogsTable, List<AuditLog>>
  _auditLogsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.auditLogs,
    aliasName: $_aliasNameGenerator(db.users.id, db.auditLogs.userId),
  );

  $$AuditLogsTableProcessedTableManager get auditLogsRefs {
    final manager = $$AuditLogsTableTableManager(
      $_db,
      $_db.auditLogs,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_auditLogsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$RecurringExpensesTable, List<RecurringExpense>>
  _recurringExpensesRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.recurringExpenses,
        aliasName: $_aliasNameGenerator(
          db.users.id,
          db.recurringExpenses.userId,
        ),
      );

  $$RecurringExpensesTableProcessedTableManager get recurringExpensesRefs {
    final manager = $$RecurringExpensesTableTableManager(
      $_db,
      $_db.recurringExpenses,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _recurringExpensesRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SubscriptionsTable, List<Subscription>>
  _subscriptionsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.subscriptions,
    aliasName: $_aliasNameGenerator(db.users.id, db.subscriptions.userId),
  );

  $$SubscriptionsTableProcessedTableManager get subscriptionsRefs {
    final manager = $$SubscriptionsTableTableManager(
      $_db,
      $_db.subscriptions,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_subscriptionsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SavingsGoalsTable, List<SavingsGoal>>
  _savingsGoalsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.savingsGoals,
    aliasName: $_aliasNameGenerator(db.users.id, db.savingsGoals.userId),
  );

  $$SavingsGoalsTableProcessedTableManager get savingsGoalsRefs {
    final manager = $$SavingsGoalsTableTableManager(
      $_db,
      $_db.savingsGoals,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_savingsGoalsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$LocationsTable, List<Location>>
  _locationsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.locations,
    aliasName: $_aliasNameGenerator(db.users.id, db.locations.userId),
  );

  $$LocationsTableProcessedTableManager get locationsRefs {
    final manager = $$LocationsTableTableManager(
      $_db,
      $_db.locations,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_locationsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$LocationAnalyticsTable, List<LocationAnalytic>>
  _locationAnalyticsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.locationAnalytics,
        aliasName: $_aliasNameGenerator(
          db.users.id,
          db.locationAnalytics.userId,
        ),
      );

  $$LocationAnalyticsTableProcessedTableManager get locationAnalyticsRefs {
    final manager = $$LocationAnalyticsTableTableManager(
      $_db,
      $_db.locationAnalytics,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _locationAnalyticsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$GeofencesTable, List<Geofence>>
  _geofencesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.geofences,
    aliasName: $_aliasNameGenerator(db.users.id, db.geofences.userId),
  );

  $$GeofencesTableProcessedTableManager get geofencesRefs {
    final manager = $$GeofencesTableTableManager(
      $_db,
      $_db.geofences,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_geofencesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$FamilyGroupsTable, List<FamilyGroup>>
  _familyGroupsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.familyGroups,
    aliasName: $_aliasNameGenerator(db.users.id, db.familyGroups.ownerId),
  );

  $$FamilyGroupsTableProcessedTableManager get familyGroupsRefs {
    final manager = $$FamilyGroupsTableTableManager(
      $_db,
      $_db.familyGroups,
    ).filter((f) => f.ownerId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_familyGroupsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$FamilyContactsTable, List<FamilyContact>>
  _familyContactsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.familyContacts,
    aliasName: $_aliasNameGenerator(
      db.users.id,
      db.familyContacts.linkedUserId,
    ),
  );

  $$FamilyContactsTableProcessedTableManager get familyContactsRefs {
    final manager = $$FamilyContactsTableTableManager(
      $_db,
      $_db.familyContacts,
    ).filter((f) => f.linkedUserId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_familyContactsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$AssetsTable, List<Asset>> _assetsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.assets,
    aliasName: $_aliasNameGenerator(db.users.id, db.assets.userId),
  );

  $$AssetsTableProcessedTableManager get assetsRefs {
    final manager = $$AssetsTableTableManager(
      $_db,
      $_db.assets,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_assetsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$LiabilitiesTable, List<Liability>>
  _liabilitiesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.liabilities,
    aliasName: $_aliasNameGenerator(db.users.id, db.liabilities.userId),
  );

  $$LiabilitiesTableProcessedTableManager get liabilitiesRefs {
    final manager = $$LiabilitiesTableTableManager(
      $_db,
      $_db.liabilities,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_liabilitiesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$LedgerEventsTable, List<LedgerEvent>>
  _ledgerEventsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.ledgerEvents,
    aliasName: $_aliasNameGenerator(db.users.id, db.ledgerEvents.userId),
  );

  $$LedgerEventsTableProcessedTableManager get ledgerEventsRefs {
    final manager = $$LedgerEventsTableTableManager(
      $_db,
      $_db.ledgerEvents,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_ledgerEventsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $BudgetHealthSnapshotsTable,
    List<BudgetHealthSnapshot>
  >
  _budgetHealthSnapshotsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.budgetHealthSnapshots,
        aliasName: $_aliasNameGenerator(
          db.users.id,
          db.budgetHealthSnapshots.userId,
        ),
      );

  $$BudgetHealthSnapshotsTableProcessedTableManager
  get budgetHealthSnapshotsRefs {
    final manager = $$BudgetHealthSnapshotsTableTableManager(
      $_db,
      $_db.budgetHealthSnapshots,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _budgetHealthSnapshotsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$CanonicalLedgerTable, List<CanonicalLedgerData>>
  _canonicalLedgerRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.canonicalLedger,
    aliasName: $_aliasNameGenerator(db.users.id, db.canonicalLedger.userId),
  );

  $$CanonicalLedgerTableProcessedTableManager get canonicalLedgerRefs {
    final manager = $$CanonicalLedgerTableTableManager(
      $_db,
      $_db.canonicalLedger,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _canonicalLedgerRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$UserConsentsTable, List<UserConsent>>
  _userConsentsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.userConsents,
    aliasName: $_aliasNameGenerator(db.users.id, db.userConsents.userId),
  );

  $$UserConsentsTableProcessedTableManager get userConsentsRefs {
    final manager = $$UserConsentsTableTableManager(
      $_db,
      $_db.userConsents,
    ).filter((f) => f.userId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_userConsentsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$UsersTableFilterComposer extends Composer<_$AppDatabase, $UsersTable> {
  $$UsersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get languagePreference => $composableBuilder(
    column: $table.languagePreference,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get avatarUrl => $composableBuilder(
    column: $table.avatarUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get subscriptionTier => $composableBuilder(
    column: $table.subscriptionTier,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get subscriptionStatus => $composableBuilder(
    column: $table.subscriptionStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get trialStartedAt => $composableBuilder(
    column: $table.trialStartedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get trialExpiresAt => $composableBuilder(
    column: $table.trialExpiresAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get subscriptionExpiresAt => $composableBuilder(
    column: $table.subscriptionExpiresAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastPaymentDate => $composableBuilder(
    column: $table.lastPaymentDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get paymentProvider => $composableBuilder(
    column: $table.paymentProvider,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get paymentProviderId => $composableBuilder(
    column: $table.paymentProviderId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get ocrUsageCount => $composableBuilder(
    column: $table.ocrUsageCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get ocrUsageResetAt => $composableBuilder(
    column: $table.ocrUsageResetAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get experienceMode => $composableBuilder(
    column: $table.experienceMode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get role => $composableBuilder(
    column: $table.role,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> budgetsRefs(
    Expression<bool> Function($$BudgetsTableFilterComposer f) f,
  ) {
    final $$BudgetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableFilterComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> categoriesRefs(
    Expression<bool> Function($$CategoriesTableFilterComposer f) f,
  ) {
    final $$CategoriesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableFilterComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> accountsRefs(
    Expression<bool> Function($$AccountsTableFilterComposer f) f,
  ) {
    final $$AccountsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.accounts,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AccountsTableFilterComposer(
            $db: $db,
            $table: $db.accounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> subCategoriesRefs(
    Expression<bool> Function($$SubCategoriesTableFilterComposer f) f,
  ) {
    final $$SubCategoriesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.subCategories,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SubCategoriesTableFilterComposer(
            $db: $db,
            $table: $db.subCategories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> expensesRefs(
    Expression<bool> Function($$ExpensesTableFilterComposer f) f,
  ) {
    final $$ExpensesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.enteredBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableFilterComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> activityLogsRefs(
    Expression<bool> Function($$ActivityLogsTableFilterComposer f) f,
  ) {
    final $$ActivityLogsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.activityLogs,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivityLogsTableFilterComposer(
            $db: $db,
            $table: $db.activityLogs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> auditLogsRefs(
    Expression<bool> Function($$AuditLogsTableFilterComposer f) f,
  ) {
    final $$AuditLogsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.auditLogs,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AuditLogsTableFilterComposer(
            $db: $db,
            $table: $db.auditLogs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> recurringExpensesRefs(
    Expression<bool> Function($$RecurringExpensesTableFilterComposer f) f,
  ) {
    final $$RecurringExpensesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.recurringExpenses,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RecurringExpensesTableFilterComposer(
            $db: $db,
            $table: $db.recurringExpenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> subscriptionsRefs(
    Expression<bool> Function($$SubscriptionsTableFilterComposer f) f,
  ) {
    final $$SubscriptionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.subscriptions,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SubscriptionsTableFilterComposer(
            $db: $db,
            $table: $db.subscriptions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> savingsGoalsRefs(
    Expression<bool> Function($$SavingsGoalsTableFilterComposer f) f,
  ) {
    final $$SavingsGoalsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.savingsGoals,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SavingsGoalsTableFilterComposer(
            $db: $db,
            $table: $db.savingsGoals,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> locationsRefs(
    Expression<bool> Function($$LocationsTableFilterComposer f) f,
  ) {
    final $$LocationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.locations,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LocationsTableFilterComposer(
            $db: $db,
            $table: $db.locations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> locationAnalyticsRefs(
    Expression<bool> Function($$LocationAnalyticsTableFilterComposer f) f,
  ) {
    final $$LocationAnalyticsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.locationAnalytics,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LocationAnalyticsTableFilterComposer(
            $db: $db,
            $table: $db.locationAnalytics,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> geofencesRefs(
    Expression<bool> Function($$GeofencesTableFilterComposer f) f,
  ) {
    final $$GeofencesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.geofences,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GeofencesTableFilterComposer(
            $db: $db,
            $table: $db.geofences,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> familyGroupsRefs(
    Expression<bool> Function($$FamilyGroupsTableFilterComposer f) f,
  ) {
    final $$FamilyGroupsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.familyGroups,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyGroupsTableFilterComposer(
            $db: $db,
            $table: $db.familyGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> familyContactsRefs(
    Expression<bool> Function($$FamilyContactsTableFilterComposer f) f,
  ) {
    final $$FamilyContactsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.familyContacts,
      getReferencedColumn: (t) => t.linkedUserId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyContactsTableFilterComposer(
            $db: $db,
            $table: $db.familyContacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> assetsRefs(
    Expression<bool> Function($$AssetsTableFilterComposer f) f,
  ) {
    final $$AssetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.assets,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AssetsTableFilterComposer(
            $db: $db,
            $table: $db.assets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> liabilitiesRefs(
    Expression<bool> Function($$LiabilitiesTableFilterComposer f) f,
  ) {
    final $$LiabilitiesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.liabilities,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LiabilitiesTableFilterComposer(
            $db: $db,
            $table: $db.liabilities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> ledgerEventsRefs(
    Expression<bool> Function($$LedgerEventsTableFilterComposer f) f,
  ) {
    final $$LedgerEventsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.ledgerEvents,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LedgerEventsTableFilterComposer(
            $db: $db,
            $table: $db.ledgerEvents,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> budgetHealthSnapshotsRefs(
    Expression<bool> Function($$BudgetHealthSnapshotsTableFilterComposer f) f,
  ) {
    final $$BudgetHealthSnapshotsTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.budgetHealthSnapshots,
          getReferencedColumn: (t) => t.userId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$BudgetHealthSnapshotsTableFilterComposer(
                $db: $db,
                $table: $db.budgetHealthSnapshots,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<bool> canonicalLedgerRefs(
    Expression<bool> Function($$CanonicalLedgerTableFilterComposer f) f,
  ) {
    final $$CanonicalLedgerTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.canonicalLedger,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CanonicalLedgerTableFilterComposer(
            $db: $db,
            $table: $db.canonicalLedger,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> userConsentsRefs(
    Expression<bool> Function($$UserConsentsTableFilterComposer f) f,
  ) {
    final $$UserConsentsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userConsents,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserConsentsTableFilterComposer(
            $db: $db,
            $table: $db.userConsents,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UsersTableOrderingComposer
    extends Composer<_$AppDatabase, $UsersTable> {
  $$UsersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get languagePreference => $composableBuilder(
    column: $table.languagePreference,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get avatarUrl => $composableBuilder(
    column: $table.avatarUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get subscriptionTier => $composableBuilder(
    column: $table.subscriptionTier,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get subscriptionStatus => $composableBuilder(
    column: $table.subscriptionStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get trialStartedAt => $composableBuilder(
    column: $table.trialStartedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get trialExpiresAt => $composableBuilder(
    column: $table.trialExpiresAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get subscriptionExpiresAt => $composableBuilder(
    column: $table.subscriptionExpiresAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastPaymentDate => $composableBuilder(
    column: $table.lastPaymentDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get paymentProvider => $composableBuilder(
    column: $table.paymentProvider,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get paymentProviderId => $composableBuilder(
    column: $table.paymentProviderId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get ocrUsageCount => $composableBuilder(
    column: $table.ocrUsageCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get ocrUsageResetAt => $composableBuilder(
    column: $table.ocrUsageResetAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get experienceMode => $composableBuilder(
    column: $table.experienceMode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get role => $composableBuilder(
    column: $table.role,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$UsersTableAnnotationComposer
    extends Composer<_$AppDatabase, $UsersTable> {
  $$UsersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get languagePreference => $composableBuilder(
    column: $table.languagePreference,
    builder: (column) => column,
  );

  GeneratedColumn<String> get avatarUrl =>
      $composableBuilder(column: $table.avatarUrl, builder: (column) => column);

  GeneratedColumn<String> get subscriptionTier => $composableBuilder(
    column: $table.subscriptionTier,
    builder: (column) => column,
  );

  GeneratedColumn<String> get subscriptionStatus => $composableBuilder(
    column: $table.subscriptionStatus,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get trialStartedAt => $composableBuilder(
    column: $table.trialStartedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get trialExpiresAt => $composableBuilder(
    column: $table.trialExpiresAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get subscriptionExpiresAt => $composableBuilder(
    column: $table.subscriptionExpiresAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastPaymentDate => $composableBuilder(
    column: $table.lastPaymentDate,
    builder: (column) => column,
  );

  GeneratedColumn<String> get paymentProvider => $composableBuilder(
    column: $table.paymentProvider,
    builder: (column) => column,
  );

  GeneratedColumn<String> get paymentProviderId => $composableBuilder(
    column: $table.paymentProviderId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get ocrUsageCount => $composableBuilder(
    column: $table.ocrUsageCount,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get ocrUsageResetAt => $composableBuilder(
    column: $table.ocrUsageResetAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get experienceMode => $composableBuilder(
    column: $table.experienceMode,
    builder: (column) => column,
  );

  GeneratedColumn<String> get role =>
      $composableBuilder(column: $table.role, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => column,
  );

  GeneratedColumn<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  Expression<T> budgetsRefs<T extends Object>(
    Expression<T> Function($$BudgetsTableAnnotationComposer a) f,
  ) {
    final $$BudgetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableAnnotationComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> categoriesRefs<T extends Object>(
    Expression<T> Function($$CategoriesTableAnnotationComposer a) f,
  ) {
    final $$CategoriesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableAnnotationComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> accountsRefs<T extends Object>(
    Expression<T> Function($$AccountsTableAnnotationComposer a) f,
  ) {
    final $$AccountsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.accounts,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AccountsTableAnnotationComposer(
            $db: $db,
            $table: $db.accounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> subCategoriesRefs<T extends Object>(
    Expression<T> Function($$SubCategoriesTableAnnotationComposer a) f,
  ) {
    final $$SubCategoriesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.subCategories,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SubCategoriesTableAnnotationComposer(
            $db: $db,
            $table: $db.subCategories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> expensesRefs<T extends Object>(
    Expression<T> Function($$ExpensesTableAnnotationComposer a) f,
  ) {
    final $$ExpensesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.enteredBy,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableAnnotationComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> activityLogsRefs<T extends Object>(
    Expression<T> Function($$ActivityLogsTableAnnotationComposer a) f,
  ) {
    final $$ActivityLogsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.activityLogs,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivityLogsTableAnnotationComposer(
            $db: $db,
            $table: $db.activityLogs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> auditLogsRefs<T extends Object>(
    Expression<T> Function($$AuditLogsTableAnnotationComposer a) f,
  ) {
    final $$AuditLogsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.auditLogs,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AuditLogsTableAnnotationComposer(
            $db: $db,
            $table: $db.auditLogs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> recurringExpensesRefs<T extends Object>(
    Expression<T> Function($$RecurringExpensesTableAnnotationComposer a) f,
  ) {
    final $$RecurringExpensesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.recurringExpenses,
          getReferencedColumn: (t) => t.userId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$RecurringExpensesTableAnnotationComposer(
                $db: $db,
                $table: $db.recurringExpenses,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> subscriptionsRefs<T extends Object>(
    Expression<T> Function($$SubscriptionsTableAnnotationComposer a) f,
  ) {
    final $$SubscriptionsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.subscriptions,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SubscriptionsTableAnnotationComposer(
            $db: $db,
            $table: $db.subscriptions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> savingsGoalsRefs<T extends Object>(
    Expression<T> Function($$SavingsGoalsTableAnnotationComposer a) f,
  ) {
    final $$SavingsGoalsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.savingsGoals,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SavingsGoalsTableAnnotationComposer(
            $db: $db,
            $table: $db.savingsGoals,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> locationsRefs<T extends Object>(
    Expression<T> Function($$LocationsTableAnnotationComposer a) f,
  ) {
    final $$LocationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.locations,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LocationsTableAnnotationComposer(
            $db: $db,
            $table: $db.locations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> locationAnalyticsRefs<T extends Object>(
    Expression<T> Function($$LocationAnalyticsTableAnnotationComposer a) f,
  ) {
    final $$LocationAnalyticsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.locationAnalytics,
          getReferencedColumn: (t) => t.userId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$LocationAnalyticsTableAnnotationComposer(
                $db: $db,
                $table: $db.locationAnalytics,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> geofencesRefs<T extends Object>(
    Expression<T> Function($$GeofencesTableAnnotationComposer a) f,
  ) {
    final $$GeofencesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.geofences,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GeofencesTableAnnotationComposer(
            $db: $db,
            $table: $db.geofences,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> familyGroupsRefs<T extends Object>(
    Expression<T> Function($$FamilyGroupsTableAnnotationComposer a) f,
  ) {
    final $$FamilyGroupsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.familyGroups,
      getReferencedColumn: (t) => t.ownerId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyGroupsTableAnnotationComposer(
            $db: $db,
            $table: $db.familyGroups,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> familyContactsRefs<T extends Object>(
    Expression<T> Function($$FamilyContactsTableAnnotationComposer a) f,
  ) {
    final $$FamilyContactsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.familyContacts,
      getReferencedColumn: (t) => t.linkedUserId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyContactsTableAnnotationComposer(
            $db: $db,
            $table: $db.familyContacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> assetsRefs<T extends Object>(
    Expression<T> Function($$AssetsTableAnnotationComposer a) f,
  ) {
    final $$AssetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.assets,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AssetsTableAnnotationComposer(
            $db: $db,
            $table: $db.assets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> liabilitiesRefs<T extends Object>(
    Expression<T> Function($$LiabilitiesTableAnnotationComposer a) f,
  ) {
    final $$LiabilitiesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.liabilities,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LiabilitiesTableAnnotationComposer(
            $db: $db,
            $table: $db.liabilities,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> ledgerEventsRefs<T extends Object>(
    Expression<T> Function($$LedgerEventsTableAnnotationComposer a) f,
  ) {
    final $$LedgerEventsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.ledgerEvents,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LedgerEventsTableAnnotationComposer(
            $db: $db,
            $table: $db.ledgerEvents,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> budgetHealthSnapshotsRefs<T extends Object>(
    Expression<T> Function($$BudgetHealthSnapshotsTableAnnotationComposer a) f,
  ) {
    final $$BudgetHealthSnapshotsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.budgetHealthSnapshots,
          getReferencedColumn: (t) => t.userId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$BudgetHealthSnapshotsTableAnnotationComposer(
                $db: $db,
                $table: $db.budgetHealthSnapshots,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> canonicalLedgerRefs<T extends Object>(
    Expression<T> Function($$CanonicalLedgerTableAnnotationComposer a) f,
  ) {
    final $$CanonicalLedgerTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.canonicalLedger,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CanonicalLedgerTableAnnotationComposer(
            $db: $db,
            $table: $db.canonicalLedger,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> userConsentsRefs<T extends Object>(
    Expression<T> Function($$UserConsentsTableAnnotationComposer a) f,
  ) {
    final $$UserConsentsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.userConsents,
      getReferencedColumn: (t) => t.userId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UserConsentsTableAnnotationComposer(
            $db: $db,
            $table: $db.userConsents,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$UsersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UsersTable,
          User,
          $$UsersTableFilterComposer,
          $$UsersTableOrderingComposer,
          $$UsersTableAnnotationComposer,
          $$UsersTableCreateCompanionBuilder,
          $$UsersTableUpdateCompanionBuilder,
          (User, $$UsersTableReferences),
          User,
          PrefetchHooks Function({
            bool budgetsRefs,
            bool categoriesRefs,
            bool accountsRefs,
            bool subCategoriesRefs,
            bool expensesRefs,
            bool activityLogsRefs,
            bool auditLogsRefs,
            bool recurringExpensesRefs,
            bool subscriptionsRefs,
            bool savingsGoalsRefs,
            bool locationsRefs,
            bool locationAnalyticsRefs,
            bool geofencesRefs,
            bool familyGroupsRefs,
            bool familyContactsRefs,
            bool assetsRefs,
            bool liabilitiesRefs,
            bool ledgerEventsRefs,
            bool budgetHealthSnapshotsRefs,
            bool canonicalLedgerRefs,
            bool userConsentsRefs,
          })
        > {
  $$UsersTableTableManager(_$AppDatabase db, $UsersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UsersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UsersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UsersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> email = const Value.absent(),
                Value<String> languagePreference = const Value.absent(),
                Value<String?> avatarUrl = const Value.absent(),
                Value<String> subscriptionTier = const Value.absent(),
                Value<String> subscriptionStatus = const Value.absent(),
                Value<DateTime?> trialStartedAt = const Value.absent(),
                Value<DateTime?> trialExpiresAt = const Value.absent(),
                Value<DateTime?> subscriptionExpiresAt = const Value.absent(),
                Value<DateTime?> lastPaymentDate = const Value.absent(),
                Value<String?> paymentProvider = const Value.absent(),
                Value<String?> paymentProviderId = const Value.absent(),
                Value<int> ocrUsageCount = const Value.absent(),
                Value<DateTime?> ocrUsageResetAt = const Value.absent(),
                Value<String> experienceMode = const Value.absent(),
                Value<String> role = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UsersCompanion(
                id: id,
                name: name,
                email: email,
                languagePreference: languagePreference,
                avatarUrl: avatarUrl,
                subscriptionTier: subscriptionTier,
                subscriptionStatus: subscriptionStatus,
                trialStartedAt: trialStartedAt,
                trialExpiresAt: trialExpiresAt,
                subscriptionExpiresAt: subscriptionExpiresAt,
                lastPaymentDate: lastPaymentDate,
                paymentProvider: paymentProvider,
                paymentProviderId: paymentProviderId,
                ocrUsageCount: ocrUsageCount,
                ocrUsageResetAt: ocrUsageResetAt,
                experienceMode: experienceMode,
                role: role,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                isDeleted: isDeleted,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                required String email,
                Value<String> languagePreference = const Value.absent(),
                Value<String?> avatarUrl = const Value.absent(),
                Value<String> subscriptionTier = const Value.absent(),
                Value<String> subscriptionStatus = const Value.absent(),
                Value<DateTime?> trialStartedAt = const Value.absent(),
                Value<DateTime?> trialExpiresAt = const Value.absent(),
                Value<DateTime?> subscriptionExpiresAt = const Value.absent(),
                Value<DateTime?> lastPaymentDate = const Value.absent(),
                Value<String?> paymentProvider = const Value.absent(),
                Value<String?> paymentProviderId = const Value.absent(),
                Value<int> ocrUsageCount = const Value.absent(),
                Value<DateTime?> ocrUsageResetAt = const Value.absent(),
                Value<String> experienceMode = const Value.absent(),
                Value<String> role = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UsersCompanion.insert(
                id: id,
                name: name,
                email: email,
                languagePreference: languagePreference,
                avatarUrl: avatarUrl,
                subscriptionTier: subscriptionTier,
                subscriptionStatus: subscriptionStatus,
                trialStartedAt: trialStartedAt,
                trialExpiresAt: trialExpiresAt,
                subscriptionExpiresAt: subscriptionExpiresAt,
                lastPaymentDate: lastPaymentDate,
                paymentProvider: paymentProvider,
                paymentProviderId: paymentProviderId,
                ocrUsageCount: ocrUsageCount,
                ocrUsageResetAt: ocrUsageResetAt,
                experienceMode: experienceMode,
                role: role,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                isDeleted: isDeleted,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$UsersTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                budgetsRefs = false,
                categoriesRefs = false,
                accountsRefs = false,
                subCategoriesRefs = false,
                expensesRefs = false,
                activityLogsRefs = false,
                auditLogsRefs = false,
                recurringExpensesRefs = false,
                subscriptionsRefs = false,
                savingsGoalsRefs = false,
                locationsRefs = false,
                locationAnalyticsRefs = false,
                geofencesRefs = false,
                familyGroupsRefs = false,
                familyContactsRefs = false,
                assetsRefs = false,
                liabilitiesRefs = false,
                ledgerEventsRefs = false,
                budgetHealthSnapshotsRefs = false,
                canonicalLedgerRefs = false,
                userConsentsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (budgetsRefs) db.budgets,
                    if (categoriesRefs) db.categories,
                    if (accountsRefs) db.accounts,
                    if (subCategoriesRefs) db.subCategories,
                    if (expensesRefs) db.expenses,
                    if (activityLogsRefs) db.activityLogs,
                    if (auditLogsRefs) db.auditLogs,
                    if (recurringExpensesRefs) db.recurringExpenses,
                    if (subscriptionsRefs) db.subscriptions,
                    if (savingsGoalsRefs) db.savingsGoals,
                    if (locationsRefs) db.locations,
                    if (locationAnalyticsRefs) db.locationAnalytics,
                    if (geofencesRefs) db.geofences,
                    if (familyGroupsRefs) db.familyGroups,
                    if (familyContactsRefs) db.familyContacts,
                    if (assetsRefs) db.assets,
                    if (liabilitiesRefs) db.liabilities,
                    if (ledgerEventsRefs) db.ledgerEvents,
                    if (budgetHealthSnapshotsRefs) db.budgetHealthSnapshots,
                    if (canonicalLedgerRefs) db.canonicalLedger,
                    if (userConsentsRefs) db.userConsents,
                  ],
                  addJoins: null,
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (budgetsRefs)
                        await $_getPrefetchedData<User, $UsersTable, Budget>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._budgetsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(db, table, p0).budgetsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.ownerId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (categoriesRefs)
                        await $_getPrefetchedData<User, $UsersTable, Category>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._categoriesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).categoriesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.ownerId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (accountsRefs)
                        await $_getPrefetchedData<User, $UsersTable, Account>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._accountsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).accountsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (subCategoriesRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          SubCategory
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._subCategoriesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).subCategoriesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.ownerId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (expensesRefs)
                        await $_getPrefetchedData<User, $UsersTable, Expense>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._expensesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).expensesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.enteredBy == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (activityLogsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          ActivityLog
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._activityLogsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).activityLogsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (auditLogsRefs)
                        await $_getPrefetchedData<User, $UsersTable, AuditLog>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._auditLogsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).auditLogsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (recurringExpensesRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          RecurringExpense
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._recurringExpensesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).recurringExpensesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (subscriptionsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          Subscription
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._subscriptionsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).subscriptionsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (savingsGoalsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          SavingsGoal
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._savingsGoalsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).savingsGoalsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (locationsRefs)
                        await $_getPrefetchedData<User, $UsersTable, Location>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._locationsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).locationsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (locationAnalyticsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          LocationAnalytic
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._locationAnalyticsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).locationAnalyticsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (geofencesRefs)
                        await $_getPrefetchedData<User, $UsersTable, Geofence>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._geofencesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).geofencesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (familyGroupsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          FamilyGroup
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._familyGroupsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).familyGroupsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.ownerId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (familyContactsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          FamilyContact
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._familyContactsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).familyContactsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.linkedUserId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (assetsRefs)
                        await $_getPrefetchedData<User, $UsersTable, Asset>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._assetsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(db, table, p0).assetsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (liabilitiesRefs)
                        await $_getPrefetchedData<User, $UsersTable, Liability>(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._liabilitiesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).liabilitiesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (ledgerEventsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          LedgerEvent
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._ledgerEventsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).ledgerEventsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (budgetHealthSnapshotsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          BudgetHealthSnapshot
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._budgetHealthSnapshotsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).budgetHealthSnapshotsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (canonicalLedgerRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          CanonicalLedgerData
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._canonicalLedgerRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).canonicalLedgerRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (userConsentsRefs)
                        await $_getPrefetchedData<
                          User,
                          $UsersTable,
                          UserConsent
                        >(
                          currentTable: table,
                          referencedTable: $$UsersTableReferences
                              ._userConsentsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$UsersTableReferences(
                                db,
                                table,
                                p0,
                              ).userConsentsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.userId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$UsersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UsersTable,
      User,
      $$UsersTableFilterComposer,
      $$UsersTableOrderingComposer,
      $$UsersTableAnnotationComposer,
      $$UsersTableCreateCompanionBuilder,
      $$UsersTableUpdateCompanionBuilder,
      (User, $$UsersTableReferences),
      User,
      PrefetchHooks Function({
        bool budgetsRefs,
        bool categoriesRefs,
        bool accountsRefs,
        bool subCategoriesRefs,
        bool expensesRefs,
        bool activityLogsRefs,
        bool auditLogsRefs,
        bool recurringExpensesRefs,
        bool subscriptionsRefs,
        bool savingsGoalsRefs,
        bool locationsRefs,
        bool locationAnalyticsRefs,
        bool geofencesRefs,
        bool familyGroupsRefs,
        bool familyContactsRefs,
        bool assetsRefs,
        bool liabilitiesRefs,
        bool ledgerEventsRefs,
        bool budgetHealthSnapshotsRefs,
        bool canonicalLedgerRefs,
        bool userConsentsRefs,
      })
    >;
typedef $$BudgetsTableCreateCompanionBuilder =
    BudgetsCompanion Function({
      required String id,
      required String ownerId,
      required String title,
      Value<String?> description,
      required String type,
      required DateTime startDate,
      required DateTime endDate,
      Value<String> currency,
      Value<int?> totalLimit,
      Value<bool> isShared,
      Value<bool> isTemplate,
      Value<String> status,
      Value<String?> iconName,
      Value<String?> colorHex,
      Value<String?> notes,
      Value<String?> tags,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<bool> isDeleted,
      Value<int?> globalSeq,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$BudgetsTableUpdateCompanionBuilder =
    BudgetsCompanion Function({
      Value<String> id,
      Value<String> ownerId,
      Value<String> title,
      Value<String?> description,
      Value<String> type,
      Value<DateTime> startDate,
      Value<DateTime> endDate,
      Value<String> currency,
      Value<int?> totalLimit,
      Value<bool> isShared,
      Value<bool> isTemplate,
      Value<String> status,
      Value<String?> iconName,
      Value<String?> colorHex,
      Value<String?> notes,
      Value<String?> tags,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<bool> isDeleted,
      Value<int?> globalSeq,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$BudgetsTableReferences
    extends BaseReferences<_$AppDatabase, $BudgetsTable, Budget> {
  $$BudgetsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _ownerIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.budgets.ownerId, db.users.id),
  );

  $$UsersTableProcessedTableManager get ownerId {
    final $_column = $_itemColumn<String>('owner_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$SemiBudgetsTable, List<SemiBudget>>
  _semiBudgetsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.semiBudgets,
    aliasName: $_aliasNameGenerator(db.budgets.id, db.semiBudgets.budgetId),
  );

  $$SemiBudgetsTableProcessedTableManager get semiBudgetsRefs {
    final manager = $$SemiBudgetsTableTableManager(
      $_db,
      $_db.semiBudgets,
    ).filter((f) => f.budgetId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_semiBudgetsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ExpensesTable, List<Expense>> _expensesRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.expenses,
    aliasName: $_aliasNameGenerator(db.budgets.id, db.expenses.budgetId),
  );

  $$ExpensesTableProcessedTableManager get expensesRefs {
    final manager = $$ExpensesTableTableManager(
      $_db,
      $_db.expenses,
    ).filter((f) => f.budgetId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_expensesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$BudgetMembersTable, List<BudgetMember>>
  _budgetMembersRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.budgetMembers,
    aliasName: $_aliasNameGenerator(db.budgets.id, db.budgetMembers.budgetId),
  );

  $$BudgetMembersTableProcessedTableManager get budgetMembersRefs {
    final manager = $$BudgetMembersTableTableManager(
      $_db,
      $_db.budgetMembers,
    ).filter((f) => f.budgetId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_budgetMembersRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ActivityLogsTable, List<ActivityLog>>
  _activityLogsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.activityLogs,
    aliasName: $_aliasNameGenerator(db.budgets.id, db.activityLogs.budgetId),
  );

  $$ActivityLogsTableProcessedTableManager get activityLogsRefs {
    final manager = $$ActivityLogsTableTableManager(
      $_db,
      $_db.activityLogs,
    ).filter((f) => f.budgetId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_activityLogsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$BudgetsTableFilterComposer
    extends Composer<_$AppDatabase, $BudgetsTable> {
  $$BudgetsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get startDate => $composableBuilder(
    column: $table.startDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get endDate => $composableBuilder(
    column: $table.endDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get totalLimit => $composableBuilder(
    column: $table.totalLimit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isShared => $composableBuilder(
    column: $table.isShared,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isTemplate => $composableBuilder(
    column: $table.isTemplate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get iconName => $composableBuilder(
    column: $table.iconName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tags => $composableBuilder(
    column: $table.tags,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get globalSeq => $composableBuilder(
    column: $table.globalSeq,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get ownerId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> semiBudgetsRefs(
    Expression<bool> Function($$SemiBudgetsTableFilterComposer f) f,
  ) {
    final $$SemiBudgetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.semiBudgets,
      getReferencedColumn: (t) => t.budgetId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SemiBudgetsTableFilterComposer(
            $db: $db,
            $table: $db.semiBudgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> expensesRefs(
    Expression<bool> Function($$ExpensesTableFilterComposer f) f,
  ) {
    final $$ExpensesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.budgetId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableFilterComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> budgetMembersRefs(
    Expression<bool> Function($$BudgetMembersTableFilterComposer f) f,
  ) {
    final $$BudgetMembersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.budgetMembers,
      getReferencedColumn: (t) => t.budgetId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetMembersTableFilterComposer(
            $db: $db,
            $table: $db.budgetMembers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> activityLogsRefs(
    Expression<bool> Function($$ActivityLogsTableFilterComposer f) f,
  ) {
    final $$ActivityLogsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.activityLogs,
      getReferencedColumn: (t) => t.budgetId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivityLogsTableFilterComposer(
            $db: $db,
            $table: $db.activityLogs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$BudgetsTableOrderingComposer
    extends Composer<_$AppDatabase, $BudgetsTable> {
  $$BudgetsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get startDate => $composableBuilder(
    column: $table.startDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get endDate => $composableBuilder(
    column: $table.endDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get totalLimit => $composableBuilder(
    column: $table.totalLimit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isShared => $composableBuilder(
    column: $table.isShared,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isTemplate => $composableBuilder(
    column: $table.isTemplate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get iconName => $composableBuilder(
    column: $table.iconName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tags => $composableBuilder(
    column: $table.tags,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get globalSeq => $composableBuilder(
    column: $table.globalSeq,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get ownerId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BudgetsTableAnnotationComposer
    extends Composer<_$AppDatabase, $BudgetsTable> {
  $$BudgetsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<DateTime> get startDate =>
      $composableBuilder(column: $table.startDate, builder: (column) => column);

  GeneratedColumn<DateTime> get endDate =>
      $composableBuilder(column: $table.endDate, builder: (column) => column);

  GeneratedColumn<String> get currency =>
      $composableBuilder(column: $table.currency, builder: (column) => column);

  GeneratedColumn<int> get totalLimit => $composableBuilder(
    column: $table.totalLimit,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isShared =>
      $composableBuilder(column: $table.isShared, builder: (column) => column);

  GeneratedColumn<bool> get isTemplate => $composableBuilder(
    column: $table.isTemplate,
    builder: (column) => column,
  );

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get iconName =>
      $composableBuilder(column: $table.iconName, builder: (column) => column);

  GeneratedColumn<String> get colorHex =>
      $composableBuilder(column: $table.colorHex, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get tags =>
      $composableBuilder(column: $table.tags, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => column,
  );

  GeneratedColumn<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<int> get globalSeq =>
      $composableBuilder(column: $table.globalSeq, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get ownerId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> semiBudgetsRefs<T extends Object>(
    Expression<T> Function($$SemiBudgetsTableAnnotationComposer a) f,
  ) {
    final $$SemiBudgetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.semiBudgets,
      getReferencedColumn: (t) => t.budgetId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SemiBudgetsTableAnnotationComposer(
            $db: $db,
            $table: $db.semiBudgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> expensesRefs<T extends Object>(
    Expression<T> Function($$ExpensesTableAnnotationComposer a) f,
  ) {
    final $$ExpensesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.budgetId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableAnnotationComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> budgetMembersRefs<T extends Object>(
    Expression<T> Function($$BudgetMembersTableAnnotationComposer a) f,
  ) {
    final $$BudgetMembersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.budgetMembers,
      getReferencedColumn: (t) => t.budgetId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetMembersTableAnnotationComposer(
            $db: $db,
            $table: $db.budgetMembers,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> activityLogsRefs<T extends Object>(
    Expression<T> Function($$ActivityLogsTableAnnotationComposer a) f,
  ) {
    final $$ActivityLogsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.activityLogs,
      getReferencedColumn: (t) => t.budgetId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ActivityLogsTableAnnotationComposer(
            $db: $db,
            $table: $db.activityLogs,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$BudgetsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BudgetsTable,
          Budget,
          $$BudgetsTableFilterComposer,
          $$BudgetsTableOrderingComposer,
          $$BudgetsTableAnnotationComposer,
          $$BudgetsTableCreateCompanionBuilder,
          $$BudgetsTableUpdateCompanionBuilder,
          (Budget, $$BudgetsTableReferences),
          Budget,
          PrefetchHooks Function({
            bool ownerId,
            bool semiBudgetsRefs,
            bool expensesRefs,
            bool budgetMembersRefs,
            bool activityLogsRefs,
          })
        > {
  $$BudgetsTableTableManager(_$AppDatabase db, $BudgetsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BudgetsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BudgetsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BudgetsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> ownerId = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<String> type = const Value.absent(),
                Value<DateTime> startDate = const Value.absent(),
                Value<DateTime> endDate = const Value.absent(),
                Value<String> currency = const Value.absent(),
                Value<int?> totalLimit = const Value.absent(),
                Value<bool> isShared = const Value.absent(),
                Value<bool> isTemplate = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> iconName = const Value.absent(),
                Value<String?> colorHex = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> tags = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int?> globalSeq = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BudgetsCompanion(
                id: id,
                ownerId: ownerId,
                title: title,
                description: description,
                type: type,
                startDate: startDate,
                endDate: endDate,
                currency: currency,
                totalLimit: totalLimit,
                isShared: isShared,
                isTemplate: isTemplate,
                status: status,
                iconName: iconName,
                colorHex: colorHex,
                notes: notes,
                tags: tags,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                isDeleted: isDeleted,
                globalSeq: globalSeq,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String ownerId,
                required String title,
                Value<String?> description = const Value.absent(),
                required String type,
                required DateTime startDate,
                required DateTime endDate,
                Value<String> currency = const Value.absent(),
                Value<int?> totalLimit = const Value.absent(),
                Value<bool> isShared = const Value.absent(),
                Value<bool> isTemplate = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> iconName = const Value.absent(),
                Value<String?> colorHex = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> tags = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int?> globalSeq = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BudgetsCompanion.insert(
                id: id,
                ownerId: ownerId,
                title: title,
                description: description,
                type: type,
                startDate: startDate,
                endDate: endDate,
                currency: currency,
                totalLimit: totalLimit,
                isShared: isShared,
                isTemplate: isTemplate,
                status: status,
                iconName: iconName,
                colorHex: colorHex,
                notes: notes,
                tags: tags,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                isDeleted: isDeleted,
                globalSeq: globalSeq,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$BudgetsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                ownerId = false,
                semiBudgetsRefs = false,
                expensesRefs = false,
                budgetMembersRefs = false,
                activityLogsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (semiBudgetsRefs) db.semiBudgets,
                    if (expensesRefs) db.expenses,
                    if (budgetMembersRefs) db.budgetMembers,
                    if (activityLogsRefs) db.activityLogs,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (ownerId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.ownerId,
                                    referencedTable: $$BudgetsTableReferences
                                        ._ownerIdTable(db),
                                    referencedColumn: $$BudgetsTableReferences
                                        ._ownerIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (semiBudgetsRefs)
                        await $_getPrefetchedData<
                          Budget,
                          $BudgetsTable,
                          SemiBudget
                        >(
                          currentTable: table,
                          referencedTable: $$BudgetsTableReferences
                              ._semiBudgetsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BudgetsTableReferences(
                                db,
                                table,
                                p0,
                              ).semiBudgetsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.budgetId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (expensesRefs)
                        await $_getPrefetchedData<
                          Budget,
                          $BudgetsTable,
                          Expense
                        >(
                          currentTable: table,
                          referencedTable: $$BudgetsTableReferences
                              ._expensesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BudgetsTableReferences(
                                db,
                                table,
                                p0,
                              ).expensesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.budgetId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (budgetMembersRefs)
                        await $_getPrefetchedData<
                          Budget,
                          $BudgetsTable,
                          BudgetMember
                        >(
                          currentTable: table,
                          referencedTable: $$BudgetsTableReferences
                              ._budgetMembersRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BudgetsTableReferences(
                                db,
                                table,
                                p0,
                              ).budgetMembersRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.budgetId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (activityLogsRefs)
                        await $_getPrefetchedData<
                          Budget,
                          $BudgetsTable,
                          ActivityLog
                        >(
                          currentTable: table,
                          referencedTable: $$BudgetsTableReferences
                              ._activityLogsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$BudgetsTableReferences(
                                db,
                                table,
                                p0,
                              ).activityLogsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.budgetId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$BudgetsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BudgetsTable,
      Budget,
      $$BudgetsTableFilterComposer,
      $$BudgetsTableOrderingComposer,
      $$BudgetsTableAnnotationComposer,
      $$BudgetsTableCreateCompanionBuilder,
      $$BudgetsTableUpdateCompanionBuilder,
      (Budget, $$BudgetsTableReferences),
      Budget,
      PrefetchHooks Function({
        bool ownerId,
        bool semiBudgetsRefs,
        bool expensesRefs,
        bool budgetMembersRefs,
        bool activityLogsRefs,
      })
    >;
typedef $$CategoriesTableCreateCompanionBuilder =
    CategoriesCompanion Function({
      required String id,
      Value<String?> ownerId,
      required String name,
      Value<Map<String, dynamic>?> nameTranslations,
      Value<String?> iconName,
      Value<String?> colorHex,
      Value<String> type,
      Value<bool> isSystem,
      Value<String?> parentId,
      Value<String?> tags,
      Value<bool> isDeleted,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$CategoriesTableUpdateCompanionBuilder =
    CategoriesCompanion Function({
      Value<String> id,
      Value<String?> ownerId,
      Value<String> name,
      Value<Map<String, dynamic>?> nameTranslations,
      Value<String?> iconName,
      Value<String?> colorHex,
      Value<String> type,
      Value<bool> isSystem,
      Value<String?> parentId,
      Value<String?> tags,
      Value<bool> isDeleted,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$CategoriesTableReferences
    extends BaseReferences<_$AppDatabase, $CategoriesTable, Category> {
  $$CategoriesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _ownerIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.categories.ownerId, db.users.id),
  );

  $$UsersTableProcessedTableManager? get ownerId {
    final $_column = $_itemColumn<String>('owner_id');
    if ($_column == null) return null;
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $CategoriesTable _parentIdTable(_$AppDatabase db) =>
      db.categories.createAlias(
        $_aliasNameGenerator(db.categories.parentId, db.categories.id),
      );

  $$CategoriesTableProcessedTableManager? get parentId {
    final $_column = $_itemColumn<String>('parent_id');
    if ($_column == null) return null;
    final manager = $$CategoriesTableTableManager(
      $_db,
      $_db.categories,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_parentIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$SemiBudgetsTable, List<SemiBudget>>
  _semiBudgetsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.semiBudgets,
    aliasName: $_aliasNameGenerator(
      db.categories.id,
      db.semiBudgets.masterCategoryId,
    ),
  );

  $$SemiBudgetsTableProcessedTableManager get semiBudgetsRefs {
    final manager = $$SemiBudgetsTableTableManager($_db, $_db.semiBudgets)
        .filter(
          (f) => f.masterCategoryId.id.sqlEquals($_itemColumn<String>('id')!),
        );

    final cache = $_typedResult.readTableOrNull(_semiBudgetsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SubCategoriesTable, List<SubCategory>>
  _subCategoriesRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.subCategories,
    aliasName: $_aliasNameGenerator(
      db.categories.id,
      db.subCategories.categoryId,
    ),
  );

  $$SubCategoriesTableProcessedTableManager get subCategoriesRefs {
    final manager = $$SubCategoriesTableTableManager(
      $_db,
      $_db.subCategories,
    ).filter((f) => f.categoryId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_subCategoriesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$ExpensesTable, List<Expense>> _expensesRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.expenses,
    aliasName: $_aliasNameGenerator(db.categories.id, db.expenses.categoryId),
  );

  $$ExpensesTableProcessedTableManager get expensesRefs {
    final manager = $$ExpensesTableTableManager(
      $_db,
      $_db.expenses,
    ).filter((f) => f.categoryId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_expensesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$CategoriesTableFilterComposer
    extends Composer<_$AppDatabase, $CategoriesTable> {
  $$CategoriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get nameTranslations => $composableBuilder(
    column: $table.nameTranslations,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<String> get iconName => $composableBuilder(
    column: $table.iconName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isSystem => $composableBuilder(
    column: $table.isSystem,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tags => $composableBuilder(
    column: $table.tags,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get ownerId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CategoriesTableFilterComposer get parentId {
    final $$CategoriesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.parentId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableFilterComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> semiBudgetsRefs(
    Expression<bool> Function($$SemiBudgetsTableFilterComposer f) f,
  ) {
    final $$SemiBudgetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.semiBudgets,
      getReferencedColumn: (t) => t.masterCategoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SemiBudgetsTableFilterComposer(
            $db: $db,
            $table: $db.semiBudgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> subCategoriesRefs(
    Expression<bool> Function($$SubCategoriesTableFilterComposer f) f,
  ) {
    final $$SubCategoriesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.subCategories,
      getReferencedColumn: (t) => t.categoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SubCategoriesTableFilterComposer(
            $db: $db,
            $table: $db.subCategories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> expensesRefs(
    Expression<bool> Function($$ExpensesTableFilterComposer f) f,
  ) {
    final $$ExpensesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.categoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableFilterComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CategoriesTableOrderingComposer
    extends Composer<_$AppDatabase, $CategoriesTable> {
  $$CategoriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get nameTranslations => $composableBuilder(
    column: $table.nameTranslations,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get iconName => $composableBuilder(
    column: $table.iconName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isSystem => $composableBuilder(
    column: $table.isSystem,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tags => $composableBuilder(
    column: $table.tags,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get ownerId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CategoriesTableOrderingComposer get parentId {
    final $$CategoriesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.parentId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableOrderingComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CategoriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $CategoriesTable> {
  $$CategoriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get nameTranslations => $composableBuilder(
    column: $table.nameTranslations,
    builder: (column) => column,
  );

  GeneratedColumn<String> get iconName =>
      $composableBuilder(column: $table.iconName, builder: (column) => column);

  GeneratedColumn<String> get colorHex =>
      $composableBuilder(column: $table.colorHex, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<bool> get isSystem =>
      $composableBuilder(column: $table.isSystem, builder: (column) => column);

  GeneratedColumn<String> get tags =>
      $composableBuilder(column: $table.tags, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get ownerId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CategoriesTableAnnotationComposer get parentId {
    final $$CategoriesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.parentId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableAnnotationComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> semiBudgetsRefs<T extends Object>(
    Expression<T> Function($$SemiBudgetsTableAnnotationComposer a) f,
  ) {
    final $$SemiBudgetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.semiBudgets,
      getReferencedColumn: (t) => t.masterCategoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SemiBudgetsTableAnnotationComposer(
            $db: $db,
            $table: $db.semiBudgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> subCategoriesRefs<T extends Object>(
    Expression<T> Function($$SubCategoriesTableAnnotationComposer a) f,
  ) {
    final $$SubCategoriesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.subCategories,
      getReferencedColumn: (t) => t.categoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SubCategoriesTableAnnotationComposer(
            $db: $db,
            $table: $db.subCategories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> expensesRefs<T extends Object>(
    Expression<T> Function($$ExpensesTableAnnotationComposer a) f,
  ) {
    final $$ExpensesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.categoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableAnnotationComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$CategoriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CategoriesTable,
          Category,
          $$CategoriesTableFilterComposer,
          $$CategoriesTableOrderingComposer,
          $$CategoriesTableAnnotationComposer,
          $$CategoriesTableCreateCompanionBuilder,
          $$CategoriesTableUpdateCompanionBuilder,
          (Category, $$CategoriesTableReferences),
          Category,
          PrefetchHooks Function({
            bool ownerId,
            bool parentId,
            bool semiBudgetsRefs,
            bool subCategoriesRefs,
            bool expensesRefs,
          })
        > {
  $$CategoriesTableTableManager(_$AppDatabase db, $CategoriesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CategoriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CategoriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CategoriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> ownerId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<Map<String, dynamic>?> nameTranslations =
                    const Value.absent(),
                Value<String?> iconName = const Value.absent(),
                Value<String?> colorHex = const Value.absent(),
                Value<String> type = const Value.absent(),
                Value<bool> isSystem = const Value.absent(),
                Value<String?> parentId = const Value.absent(),
                Value<String?> tags = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CategoriesCompanion(
                id: id,
                ownerId: ownerId,
                name: name,
                nameTranslations: nameTranslations,
                iconName: iconName,
                colorHex: colorHex,
                type: type,
                isSystem: isSystem,
                parentId: parentId,
                tags: tags,
                isDeleted: isDeleted,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> ownerId = const Value.absent(),
                required String name,
                Value<Map<String, dynamic>?> nameTranslations =
                    const Value.absent(),
                Value<String?> iconName = const Value.absent(),
                Value<String?> colorHex = const Value.absent(),
                Value<String> type = const Value.absent(),
                Value<bool> isSystem = const Value.absent(),
                Value<String?> parentId = const Value.absent(),
                Value<String?> tags = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CategoriesCompanion.insert(
                id: id,
                ownerId: ownerId,
                name: name,
                nameTranslations: nameTranslations,
                iconName: iconName,
                colorHex: colorHex,
                type: type,
                isSystem: isSystem,
                parentId: parentId,
                tags: tags,
                isDeleted: isDeleted,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CategoriesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                ownerId = false,
                parentId = false,
                semiBudgetsRefs = false,
                subCategoriesRefs = false,
                expensesRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (semiBudgetsRefs) db.semiBudgets,
                    if (subCategoriesRefs) db.subCategories,
                    if (expensesRefs) db.expenses,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (ownerId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.ownerId,
                                    referencedTable: $$CategoriesTableReferences
                                        ._ownerIdTable(db),
                                    referencedColumn:
                                        $$CategoriesTableReferences
                                            ._ownerIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (parentId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.parentId,
                                    referencedTable: $$CategoriesTableReferences
                                        ._parentIdTable(db),
                                    referencedColumn:
                                        $$CategoriesTableReferences
                                            ._parentIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (semiBudgetsRefs)
                        await $_getPrefetchedData<
                          Category,
                          $CategoriesTable,
                          SemiBudget
                        >(
                          currentTable: table,
                          referencedTable: $$CategoriesTableReferences
                              ._semiBudgetsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$CategoriesTableReferences(
                                db,
                                table,
                                p0,
                              ).semiBudgetsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.masterCategoryId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (subCategoriesRefs)
                        await $_getPrefetchedData<
                          Category,
                          $CategoriesTable,
                          SubCategory
                        >(
                          currentTable: table,
                          referencedTable: $$CategoriesTableReferences
                              ._subCategoriesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$CategoriesTableReferences(
                                db,
                                table,
                                p0,
                              ).subCategoriesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.categoryId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (expensesRefs)
                        await $_getPrefetchedData<
                          Category,
                          $CategoriesTable,
                          Expense
                        >(
                          currentTable: table,
                          referencedTable: $$CategoriesTableReferences
                              ._expensesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$CategoriesTableReferences(
                                db,
                                table,
                                p0,
                              ).expensesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.categoryId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$CategoriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CategoriesTable,
      Category,
      $$CategoriesTableFilterComposer,
      $$CategoriesTableOrderingComposer,
      $$CategoriesTableAnnotationComposer,
      $$CategoriesTableCreateCompanionBuilder,
      $$CategoriesTableUpdateCompanionBuilder,
      (Category, $$CategoriesTableReferences),
      Category,
      PrefetchHooks Function({
        bool ownerId,
        bool parentId,
        bool semiBudgetsRefs,
        bool subCategoriesRefs,
        bool expensesRefs,
      })
    >;
typedef $$SemiBudgetsTableCreateCompanionBuilder =
    SemiBudgetsCompanion Function({
      required String id,
      required String budgetId,
      required String name,
      required int limitAmount,
      Value<int> priority,
      Value<String?> iconName,
      Value<String?> colorHex,
      Value<Map<String, dynamic>?> metadata,
      Value<String?> parentCategoryId,
      Value<bool> isSubcategory,
      Value<double?> suggestedPercent,
      Value<int> displayOrder,
      Value<String?> masterCategoryId,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<bool> isDeleted,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$SemiBudgetsTableUpdateCompanionBuilder =
    SemiBudgetsCompanion Function({
      Value<String> id,
      Value<String> budgetId,
      Value<String> name,
      Value<int> limitAmount,
      Value<int> priority,
      Value<String?> iconName,
      Value<String?> colorHex,
      Value<Map<String, dynamic>?> metadata,
      Value<String?> parentCategoryId,
      Value<bool> isSubcategory,
      Value<double?> suggestedPercent,
      Value<int> displayOrder,
      Value<String?> masterCategoryId,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<bool> isDeleted,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$SemiBudgetsTableReferences
    extends BaseReferences<_$AppDatabase, $SemiBudgetsTable, SemiBudget> {
  $$SemiBudgetsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BudgetsTable _budgetIdTable(_$AppDatabase db) =>
      db.budgets.createAlias(
        $_aliasNameGenerator(db.semiBudgets.budgetId, db.budgets.id),
      );

  $$BudgetsTableProcessedTableManager get budgetId {
    final $_column = $_itemColumn<String>('budget_id')!;

    final manager = $$BudgetsTableTableManager(
      $_db,
      $_db.budgets,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_budgetIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $SemiBudgetsTable _parentCategoryIdTable(_$AppDatabase db) =>
      db.semiBudgets.createAlias(
        $_aliasNameGenerator(
          db.semiBudgets.parentCategoryId,
          db.semiBudgets.id,
        ),
      );

  $$SemiBudgetsTableProcessedTableManager? get parentCategoryId {
    final $_column = $_itemColumn<String>('parent_category_id');
    if ($_column == null) return null;
    final manager = $$SemiBudgetsTableTableManager(
      $_db,
      $_db.semiBudgets,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_parentCategoryIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $CategoriesTable _masterCategoryIdTable(_$AppDatabase db) =>
      db.categories.createAlias(
        $_aliasNameGenerator(db.semiBudgets.masterCategoryId, db.categories.id),
      );

  $$CategoriesTableProcessedTableManager? get masterCategoryId {
    final $_column = $_itemColumn<String>('master_category_id');
    if ($_column == null) return null;
    final manager = $$CategoriesTableTableManager(
      $_db,
      $_db.categories,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_masterCategoryIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$ExpensesTable, List<Expense>> _expensesRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.expenses,
    aliasName: $_aliasNameGenerator(
      db.semiBudgets.id,
      db.expenses.semiBudgetId,
    ),
  );

  $$ExpensesTableProcessedTableManager get expensesRefs {
    final manager = $$ExpensesTableTableManager(
      $_db,
      $_db.expenses,
    ).filter((f) => f.semiBudgetId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_expensesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SplitTransactionsTable, List<SplitTransaction>>
  _splitTransactionsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.splitTransactions,
        aliasName: $_aliasNameGenerator(
          db.semiBudgets.id,
          db.splitTransactions.semiBudgetId,
        ),
      );

  $$SplitTransactionsTableProcessedTableManager get splitTransactionsRefs {
    final manager = $$SplitTransactionsTableTableManager(
      $_db,
      $_db.splitTransactions,
    ).filter((f) => f.semiBudgetId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _splitTransactionsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$SemiBudgetsTableFilterComposer
    extends Composer<_$AppDatabase, $SemiBudgetsTable> {
  $$SemiBudgetsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get limitAmount => $composableBuilder(
    column: $table.limitAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get priority => $composableBuilder(
    column: $table.priority,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get iconName => $composableBuilder(
    column: $table.iconName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<bool> get isSubcategory => $composableBuilder(
    column: $table.isSubcategory,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get suggestedPercent => $composableBuilder(
    column: $table.suggestedPercent,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  $$BudgetsTableFilterComposer get budgetId {
    final $$BudgetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.budgetId,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableFilterComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SemiBudgetsTableFilterComposer get parentCategoryId {
    final $$SemiBudgetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.parentCategoryId,
      referencedTable: $db.semiBudgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SemiBudgetsTableFilterComposer(
            $db: $db,
            $table: $db.semiBudgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CategoriesTableFilterComposer get masterCategoryId {
    final $$CategoriesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.masterCategoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableFilterComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> expensesRefs(
    Expression<bool> Function($$ExpensesTableFilterComposer f) f,
  ) {
    final $$ExpensesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.semiBudgetId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableFilterComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> splitTransactionsRefs(
    Expression<bool> Function($$SplitTransactionsTableFilterComposer f) f,
  ) {
    final $$SplitTransactionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.splitTransactions,
      getReferencedColumn: (t) => t.semiBudgetId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SplitTransactionsTableFilterComposer(
            $db: $db,
            $table: $db.splitTransactions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SemiBudgetsTableOrderingComposer
    extends Composer<_$AppDatabase, $SemiBudgetsTable> {
  $$SemiBudgetsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get limitAmount => $composableBuilder(
    column: $table.limitAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get priority => $composableBuilder(
    column: $table.priority,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get iconName => $composableBuilder(
    column: $table.iconName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isSubcategory => $composableBuilder(
    column: $table.isSubcategory,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get suggestedPercent => $composableBuilder(
    column: $table.suggestedPercent,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  $$BudgetsTableOrderingComposer get budgetId {
    final $$BudgetsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.budgetId,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableOrderingComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SemiBudgetsTableOrderingComposer get parentCategoryId {
    final $$SemiBudgetsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.parentCategoryId,
      referencedTable: $db.semiBudgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SemiBudgetsTableOrderingComposer(
            $db: $db,
            $table: $db.semiBudgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CategoriesTableOrderingComposer get masterCategoryId {
    final $$CategoriesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.masterCategoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableOrderingComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SemiBudgetsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SemiBudgetsTable> {
  $$SemiBudgetsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get limitAmount => $composableBuilder(
    column: $table.limitAmount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get priority =>
      $composableBuilder(column: $table.priority, builder: (column) => column);

  GeneratedColumn<String> get iconName =>
      $composableBuilder(column: $table.iconName, builder: (column) => column);

  GeneratedColumn<String> get colorHex =>
      $composableBuilder(column: $table.colorHex, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<bool> get isSubcategory => $composableBuilder(
    column: $table.isSubcategory,
    builder: (column) => column,
  );

  GeneratedColumn<double> get suggestedPercent => $composableBuilder(
    column: $table.suggestedPercent,
    builder: (column) => column,
  );

  GeneratedColumn<int> get displayOrder => $composableBuilder(
    column: $table.displayOrder,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => column,
  );

  GeneratedColumn<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  $$BudgetsTableAnnotationComposer get budgetId {
    final $$BudgetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.budgetId,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableAnnotationComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SemiBudgetsTableAnnotationComposer get parentCategoryId {
    final $$SemiBudgetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.parentCategoryId,
      referencedTable: $db.semiBudgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SemiBudgetsTableAnnotationComposer(
            $db: $db,
            $table: $db.semiBudgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CategoriesTableAnnotationComposer get masterCategoryId {
    final $$CategoriesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.masterCategoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableAnnotationComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> expensesRefs<T extends Object>(
    Expression<T> Function($$ExpensesTableAnnotationComposer a) f,
  ) {
    final $$ExpensesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.semiBudgetId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableAnnotationComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> splitTransactionsRefs<T extends Object>(
    Expression<T> Function($$SplitTransactionsTableAnnotationComposer a) f,
  ) {
    final $$SplitTransactionsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.splitTransactions,
          getReferencedColumn: (t) => t.semiBudgetId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$SplitTransactionsTableAnnotationComposer(
                $db: $db,
                $table: $db.splitTransactions,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$SemiBudgetsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SemiBudgetsTable,
          SemiBudget,
          $$SemiBudgetsTableFilterComposer,
          $$SemiBudgetsTableOrderingComposer,
          $$SemiBudgetsTableAnnotationComposer,
          $$SemiBudgetsTableCreateCompanionBuilder,
          $$SemiBudgetsTableUpdateCompanionBuilder,
          (SemiBudget, $$SemiBudgetsTableReferences),
          SemiBudget,
          PrefetchHooks Function({
            bool budgetId,
            bool parentCategoryId,
            bool masterCategoryId,
            bool expensesRefs,
            bool splitTransactionsRefs,
          })
        > {
  $$SemiBudgetsTableTableManager(_$AppDatabase db, $SemiBudgetsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SemiBudgetsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SemiBudgetsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SemiBudgetsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> budgetId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> limitAmount = const Value.absent(),
                Value<int> priority = const Value.absent(),
                Value<String?> iconName = const Value.absent(),
                Value<String?> colorHex = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<String?> parentCategoryId = const Value.absent(),
                Value<bool> isSubcategory = const Value.absent(),
                Value<double?> suggestedPercent = const Value.absent(),
                Value<int> displayOrder = const Value.absent(),
                Value<String?> masterCategoryId = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SemiBudgetsCompanion(
                id: id,
                budgetId: budgetId,
                name: name,
                limitAmount: limitAmount,
                priority: priority,
                iconName: iconName,
                colorHex: colorHex,
                metadata: metadata,
                parentCategoryId: parentCategoryId,
                isSubcategory: isSubcategory,
                suggestedPercent: suggestedPercent,
                displayOrder: displayOrder,
                masterCategoryId: masterCategoryId,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                isDeleted: isDeleted,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String budgetId,
                required String name,
                required int limitAmount,
                Value<int> priority = const Value.absent(),
                Value<String?> iconName = const Value.absent(),
                Value<String?> colorHex = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<String?> parentCategoryId = const Value.absent(),
                Value<bool> isSubcategory = const Value.absent(),
                Value<double?> suggestedPercent = const Value.absent(),
                Value<int> displayOrder = const Value.absent(),
                Value<String?> masterCategoryId = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SemiBudgetsCompanion.insert(
                id: id,
                budgetId: budgetId,
                name: name,
                limitAmount: limitAmount,
                priority: priority,
                iconName: iconName,
                colorHex: colorHex,
                metadata: metadata,
                parentCategoryId: parentCategoryId,
                isSubcategory: isSubcategory,
                suggestedPercent: suggestedPercent,
                displayOrder: displayOrder,
                masterCategoryId: masterCategoryId,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                isDeleted: isDeleted,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SemiBudgetsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                budgetId = false,
                parentCategoryId = false,
                masterCategoryId = false,
                expensesRefs = false,
                splitTransactionsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (expensesRefs) db.expenses,
                    if (splitTransactionsRefs) db.splitTransactions,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (budgetId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.budgetId,
                                    referencedTable:
                                        $$SemiBudgetsTableReferences
                                            ._budgetIdTable(db),
                                    referencedColumn:
                                        $$SemiBudgetsTableReferences
                                            ._budgetIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (parentCategoryId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.parentCategoryId,
                                    referencedTable:
                                        $$SemiBudgetsTableReferences
                                            ._parentCategoryIdTable(db),
                                    referencedColumn:
                                        $$SemiBudgetsTableReferences
                                            ._parentCategoryIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (masterCategoryId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.masterCategoryId,
                                    referencedTable:
                                        $$SemiBudgetsTableReferences
                                            ._masterCategoryIdTable(db),
                                    referencedColumn:
                                        $$SemiBudgetsTableReferences
                                            ._masterCategoryIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (expensesRefs)
                        await $_getPrefetchedData<
                          SemiBudget,
                          $SemiBudgetsTable,
                          Expense
                        >(
                          currentTable: table,
                          referencedTable: $$SemiBudgetsTableReferences
                              ._expensesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SemiBudgetsTableReferences(
                                db,
                                table,
                                p0,
                              ).expensesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.semiBudgetId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (splitTransactionsRefs)
                        await $_getPrefetchedData<
                          SemiBudget,
                          $SemiBudgetsTable,
                          SplitTransaction
                        >(
                          currentTable: table,
                          referencedTable: $$SemiBudgetsTableReferences
                              ._splitTransactionsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SemiBudgetsTableReferences(
                                db,
                                table,
                                p0,
                              ).splitTransactionsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.semiBudgetId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$SemiBudgetsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SemiBudgetsTable,
      SemiBudget,
      $$SemiBudgetsTableFilterComposer,
      $$SemiBudgetsTableOrderingComposer,
      $$SemiBudgetsTableAnnotationComposer,
      $$SemiBudgetsTableCreateCompanionBuilder,
      $$SemiBudgetsTableUpdateCompanionBuilder,
      (SemiBudget, $$SemiBudgetsTableReferences),
      SemiBudget,
      PrefetchHooks Function({
        bool budgetId,
        bool parentCategoryId,
        bool masterCategoryId,
        bool expensesRefs,
        bool splitTransactionsRefs,
      })
    >;
typedef $$AccountsTableCreateCompanionBuilder =
    AccountsCompanion Function({
      required String id,
      required String userId,
      required String name,
      required String type,
      required int balance,
      Value<String> currency,
      Value<String?> iconName,
      Value<String?> colorHex,
      Value<bool> isDefault,
      Value<String?> institutionName,
      Value<String?> accountNumberLast4,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<bool> isDeleted,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$AccountsTableUpdateCompanionBuilder =
    AccountsCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String> name,
      Value<String> type,
      Value<int> balance,
      Value<String> currency,
      Value<String?> iconName,
      Value<String?> colorHex,
      Value<bool> isDefault,
      Value<String?> institutionName,
      Value<String?> accountNumberLast4,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<bool> isDeleted,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$AccountsTableReferences
    extends BaseReferences<_$AppDatabase, $AccountsTable, Account> {
  $$AccountsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.accounts.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$ExpensesTable, List<Expense>> _expensesRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.expenses,
    aliasName: $_aliasNameGenerator(db.accounts.id, db.expenses.accountId),
  );

  $$ExpensesTableProcessedTableManager get expensesRefs {
    final manager = $$ExpensesTableTableManager(
      $_db,
      $_db.expenses,
    ).filter((f) => f.accountId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_expensesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SavingsGoalsTable, List<SavingsGoal>>
  _savingsGoalsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.savingsGoals,
    aliasName: $_aliasNameGenerator(
      db.accounts.id,
      db.savingsGoals.linkedAccountId,
    ),
  );

  $$SavingsGoalsTableProcessedTableManager get savingsGoalsRefs {
    final manager = $$SavingsGoalsTableTableManager($_db, $_db.savingsGoals)
        .filter(
          (f) => f.linkedAccountId.id.sqlEquals($_itemColumn<String>('id')!),
        );

    final cache = $_typedResult.readTableOrNull(_savingsGoalsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$AccountsTableFilterComposer
    extends Composer<_$AppDatabase, $AccountsTable> {
  $$AccountsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get balance => $composableBuilder(
    column: $table.balance,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get iconName => $composableBuilder(
    column: $table.iconName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get institutionName => $composableBuilder(
    column: $table.institutionName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get accountNumberLast4 => $composableBuilder(
    column: $table.accountNumberLast4,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> expensesRefs(
    Expression<bool> Function($$ExpensesTableFilterComposer f) f,
  ) {
    final $$ExpensesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.accountId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableFilterComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> savingsGoalsRefs(
    Expression<bool> Function($$SavingsGoalsTableFilterComposer f) f,
  ) {
    final $$SavingsGoalsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.savingsGoals,
      getReferencedColumn: (t) => t.linkedAccountId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SavingsGoalsTableFilterComposer(
            $db: $db,
            $table: $db.savingsGoals,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$AccountsTableOrderingComposer
    extends Composer<_$AppDatabase, $AccountsTable> {
  $$AccountsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get balance => $composableBuilder(
    column: $table.balance,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get iconName => $composableBuilder(
    column: $table.iconName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDefault => $composableBuilder(
    column: $table.isDefault,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get institutionName => $composableBuilder(
    column: $table.institutionName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get accountNumberLast4 => $composableBuilder(
    column: $table.accountNumberLast4,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AccountsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AccountsTable> {
  $$AccountsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<int> get balance =>
      $composableBuilder(column: $table.balance, builder: (column) => column);

  GeneratedColumn<String> get currency =>
      $composableBuilder(column: $table.currency, builder: (column) => column);

  GeneratedColumn<String> get iconName =>
      $composableBuilder(column: $table.iconName, builder: (column) => column);

  GeneratedColumn<String> get colorHex =>
      $composableBuilder(column: $table.colorHex, builder: (column) => column);

  GeneratedColumn<bool> get isDefault =>
      $composableBuilder(column: $table.isDefault, builder: (column) => column);

  GeneratedColumn<String> get institutionName => $composableBuilder(
    column: $table.institutionName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get accountNumberLast4 => $composableBuilder(
    column: $table.accountNumberLast4,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => column,
  );

  GeneratedColumn<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> expensesRefs<T extends Object>(
    Expression<T> Function($$ExpensesTableAnnotationComposer a) f,
  ) {
    final $$ExpensesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.accountId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableAnnotationComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> savingsGoalsRefs<T extends Object>(
    Expression<T> Function($$SavingsGoalsTableAnnotationComposer a) f,
  ) {
    final $$SavingsGoalsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.savingsGoals,
      getReferencedColumn: (t) => t.linkedAccountId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SavingsGoalsTableAnnotationComposer(
            $db: $db,
            $table: $db.savingsGoals,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$AccountsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AccountsTable,
          Account,
          $$AccountsTableFilterComposer,
          $$AccountsTableOrderingComposer,
          $$AccountsTableAnnotationComposer,
          $$AccountsTableCreateCompanionBuilder,
          $$AccountsTableUpdateCompanionBuilder,
          (Account, $$AccountsTableReferences),
          Account,
          PrefetchHooks Function({
            bool userId,
            bool expensesRefs,
            bool savingsGoalsRefs,
          })
        > {
  $$AccountsTableTableManager(_$AppDatabase db, $AccountsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AccountsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AccountsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AccountsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> type = const Value.absent(),
                Value<int> balance = const Value.absent(),
                Value<String> currency = const Value.absent(),
                Value<String?> iconName = const Value.absent(),
                Value<String?> colorHex = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<String?> institutionName = const Value.absent(),
                Value<String?> accountNumberLast4 = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AccountsCompanion(
                id: id,
                userId: userId,
                name: name,
                type: type,
                balance: balance,
                currency: currency,
                iconName: iconName,
                colorHex: colorHex,
                isDefault: isDefault,
                institutionName: institutionName,
                accountNumberLast4: accountNumberLast4,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                isDeleted: isDeleted,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required String name,
                required String type,
                required int balance,
                Value<String> currency = const Value.absent(),
                Value<String?> iconName = const Value.absent(),
                Value<String?> colorHex = const Value.absent(),
                Value<bool> isDefault = const Value.absent(),
                Value<String?> institutionName = const Value.absent(),
                Value<String?> accountNumberLast4 = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AccountsCompanion.insert(
                id: id,
                userId: userId,
                name: name,
                type: type,
                balance: balance,
                currency: currency,
                iconName: iconName,
                colorHex: colorHex,
                isDefault: isDefault,
                institutionName: institutionName,
                accountNumberLast4: accountNumberLast4,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                isDeleted: isDeleted,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$AccountsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                userId = false,
                expensesRefs = false,
                savingsGoalsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (expensesRefs) db.expenses,
                    if (savingsGoalsRefs) db.savingsGoals,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (userId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.userId,
                                    referencedTable: $$AccountsTableReferences
                                        ._userIdTable(db),
                                    referencedColumn: $$AccountsTableReferences
                                        ._userIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (expensesRefs)
                        await $_getPrefetchedData<
                          Account,
                          $AccountsTable,
                          Expense
                        >(
                          currentTable: table,
                          referencedTable: $$AccountsTableReferences
                              ._expensesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$AccountsTableReferences(
                                db,
                                table,
                                p0,
                              ).expensesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.accountId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (savingsGoalsRefs)
                        await $_getPrefetchedData<
                          Account,
                          $AccountsTable,
                          SavingsGoal
                        >(
                          currentTable: table,
                          referencedTable: $$AccountsTableReferences
                              ._savingsGoalsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$AccountsTableReferences(
                                db,
                                table,
                                p0,
                              ).savingsGoalsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.linkedAccountId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$AccountsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AccountsTable,
      Account,
      $$AccountsTableFilterComposer,
      $$AccountsTableOrderingComposer,
      $$AccountsTableAnnotationComposer,
      $$AccountsTableCreateCompanionBuilder,
      $$AccountsTableUpdateCompanionBuilder,
      (Account, $$AccountsTableReferences),
      Account,
      PrefetchHooks Function({
        bool userId,
        bool expensesRefs,
        bool savingsGoalsRefs,
      })
    >;
typedef $$SubCategoriesTableCreateCompanionBuilder =
    SubCategoriesCompanion Function({
      required String id,
      required String categoryId,
      required String name,
      Value<String?> ownerId,
      Value<bool> isSystem,
      Value<bool> isDefaultOther,
      Value<int> usageCount,
      Value<DateTime> lastUsedAt,
      Value<double> confidence,
      Value<bool> isDeleted,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$SubCategoriesTableUpdateCompanionBuilder =
    SubCategoriesCompanion Function({
      Value<String> id,
      Value<String> categoryId,
      Value<String> name,
      Value<String?> ownerId,
      Value<bool> isSystem,
      Value<bool> isDefaultOther,
      Value<int> usageCount,
      Value<DateTime> lastUsedAt,
      Value<double> confidence,
      Value<bool> isDeleted,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$SubCategoriesTableReferences
    extends BaseReferences<_$AppDatabase, $SubCategoriesTable, SubCategory> {
  $$SubCategoriesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $CategoriesTable _categoryIdTable(_$AppDatabase db) =>
      db.categories.createAlias(
        $_aliasNameGenerator(db.subCategories.categoryId, db.categories.id),
      );

  $$CategoriesTableProcessedTableManager get categoryId {
    final $_column = $_itemColumn<String>('category_id')!;

    final manager = $$CategoriesTableTableManager(
      $_db,
      $_db.categories,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_categoryIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _ownerIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.subCategories.ownerId, db.users.id),
  );

  $$UsersTableProcessedTableManager? get ownerId {
    final $_column = $_itemColumn<String>('owner_id');
    if ($_column == null) return null;
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$ExpensesTable, List<Expense>> _expensesRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.expenses,
    aliasName: $_aliasNameGenerator(
      db.subCategories.id,
      db.expenses.subCategoryId,
    ),
  );

  $$ExpensesTableProcessedTableManager get expensesRefs {
    final manager = $$ExpensesTableTableManager(
      $_db,
      $_db.expenses,
    ).filter((f) => f.subCategoryId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_expensesRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$CategoryLearningTable, List<CategoryLearningData>>
  _categoryLearningRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.categoryLearning,
    aliasName: $_aliasNameGenerator(
      db.subCategories.id,
      db.categoryLearning.subCategoryId,
    ),
  );

  $$CategoryLearningTableProcessedTableManager get categoryLearningRefs {
    final manager = $$CategoryLearningTableTableManager(
      $_db,
      $_db.categoryLearning,
    ).filter((f) => f.subCategoryId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _categoryLearningRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$SubCategoriesTableFilterComposer
    extends Composer<_$AppDatabase, $SubCategoriesTable> {
  $$SubCategoriesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isSystem => $composableBuilder(
    column: $table.isSystem,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDefaultOther => $composableBuilder(
    column: $table.isDefaultOther,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get usageCount => $composableBuilder(
    column: $table.usageCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastUsedAt => $composableBuilder(
    column: $table.lastUsedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get confidence => $composableBuilder(
    column: $table.confidence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  $$CategoriesTableFilterComposer get categoryId {
    final $$CategoriesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableFilterComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get ownerId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> expensesRefs(
    Expression<bool> Function($$ExpensesTableFilterComposer f) f,
  ) {
    final $$ExpensesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.subCategoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableFilterComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> categoryLearningRefs(
    Expression<bool> Function($$CategoryLearningTableFilterComposer f) f,
  ) {
    final $$CategoryLearningTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.categoryLearning,
      getReferencedColumn: (t) => t.subCategoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoryLearningTableFilterComposer(
            $db: $db,
            $table: $db.categoryLearning,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SubCategoriesTableOrderingComposer
    extends Composer<_$AppDatabase, $SubCategoriesTable> {
  $$SubCategoriesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isSystem => $composableBuilder(
    column: $table.isSystem,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDefaultOther => $composableBuilder(
    column: $table.isDefaultOther,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get usageCount => $composableBuilder(
    column: $table.usageCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastUsedAt => $composableBuilder(
    column: $table.lastUsedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get confidence => $composableBuilder(
    column: $table.confidence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  $$CategoriesTableOrderingComposer get categoryId {
    final $$CategoriesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableOrderingComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get ownerId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SubCategoriesTableAnnotationComposer
    extends Composer<_$AppDatabase, $SubCategoriesTable> {
  $$SubCategoriesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<bool> get isSystem =>
      $composableBuilder(column: $table.isSystem, builder: (column) => column);

  GeneratedColumn<bool> get isDefaultOther => $composableBuilder(
    column: $table.isDefaultOther,
    builder: (column) => column,
  );

  GeneratedColumn<int> get usageCount => $composableBuilder(
    column: $table.usageCount,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastUsedAt => $composableBuilder(
    column: $table.lastUsedAt,
    builder: (column) => column,
  );

  GeneratedColumn<double> get confidence => $composableBuilder(
    column: $table.confidence,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  $$CategoriesTableAnnotationComposer get categoryId {
    final $$CategoriesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableAnnotationComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get ownerId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> expensesRefs<T extends Object>(
    Expression<T> Function($$ExpensesTableAnnotationComposer a) f,
  ) {
    final $$ExpensesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.subCategoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableAnnotationComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> categoryLearningRefs<T extends Object>(
    Expression<T> Function($$CategoryLearningTableAnnotationComposer a) f,
  ) {
    final $$CategoryLearningTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.categoryLearning,
      getReferencedColumn: (t) => t.subCategoryId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoryLearningTableAnnotationComposer(
            $db: $db,
            $table: $db.categoryLearning,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SubCategoriesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SubCategoriesTable,
          SubCategory,
          $$SubCategoriesTableFilterComposer,
          $$SubCategoriesTableOrderingComposer,
          $$SubCategoriesTableAnnotationComposer,
          $$SubCategoriesTableCreateCompanionBuilder,
          $$SubCategoriesTableUpdateCompanionBuilder,
          (SubCategory, $$SubCategoriesTableReferences),
          SubCategory,
          PrefetchHooks Function({
            bool categoryId,
            bool ownerId,
            bool expensesRefs,
            bool categoryLearningRefs,
          })
        > {
  $$SubCategoriesTableTableManager(_$AppDatabase db, $SubCategoriesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SubCategoriesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SubCategoriesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SubCategoriesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> categoryId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> ownerId = const Value.absent(),
                Value<bool> isSystem = const Value.absent(),
                Value<bool> isDefaultOther = const Value.absent(),
                Value<int> usageCount = const Value.absent(),
                Value<DateTime> lastUsedAt = const Value.absent(),
                Value<double> confidence = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SubCategoriesCompanion(
                id: id,
                categoryId: categoryId,
                name: name,
                ownerId: ownerId,
                isSystem: isSystem,
                isDefaultOther: isDefaultOther,
                usageCount: usageCount,
                lastUsedAt: lastUsedAt,
                confidence: confidence,
                isDeleted: isDeleted,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String categoryId,
                required String name,
                Value<String?> ownerId = const Value.absent(),
                Value<bool> isSystem = const Value.absent(),
                Value<bool> isDefaultOther = const Value.absent(),
                Value<int> usageCount = const Value.absent(),
                Value<DateTime> lastUsedAt = const Value.absent(),
                Value<double> confidence = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SubCategoriesCompanion.insert(
                id: id,
                categoryId: categoryId,
                name: name,
                ownerId: ownerId,
                isSystem: isSystem,
                isDefaultOther: isDefaultOther,
                usageCount: usageCount,
                lastUsedAt: lastUsedAt,
                confidence: confidence,
                isDeleted: isDeleted,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SubCategoriesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                categoryId = false,
                ownerId = false,
                expensesRefs = false,
                categoryLearningRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (expensesRefs) db.expenses,
                    if (categoryLearningRefs) db.categoryLearning,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (categoryId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.categoryId,
                                    referencedTable:
                                        $$SubCategoriesTableReferences
                                            ._categoryIdTable(db),
                                    referencedColumn:
                                        $$SubCategoriesTableReferences
                                            ._categoryIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (ownerId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.ownerId,
                                    referencedTable:
                                        $$SubCategoriesTableReferences
                                            ._ownerIdTable(db),
                                    referencedColumn:
                                        $$SubCategoriesTableReferences
                                            ._ownerIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (expensesRefs)
                        await $_getPrefetchedData<
                          SubCategory,
                          $SubCategoriesTable,
                          Expense
                        >(
                          currentTable: table,
                          referencedTable: $$SubCategoriesTableReferences
                              ._expensesRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SubCategoriesTableReferences(
                                db,
                                table,
                                p0,
                              ).expensesRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.subCategoryId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (categoryLearningRefs)
                        await $_getPrefetchedData<
                          SubCategory,
                          $SubCategoriesTable,
                          CategoryLearningData
                        >(
                          currentTable: table,
                          referencedTable: $$SubCategoriesTableReferences
                              ._categoryLearningRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$SubCategoriesTableReferences(
                                db,
                                table,
                                p0,
                              ).categoryLearningRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.subCategoryId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$SubCategoriesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SubCategoriesTable,
      SubCategory,
      $$SubCategoriesTableFilterComposer,
      $$SubCategoriesTableOrderingComposer,
      $$SubCategoriesTableAnnotationComposer,
      $$SubCategoriesTableCreateCompanionBuilder,
      $$SubCategoriesTableUpdateCompanionBuilder,
      (SubCategory, $$SubCategoriesTableReferences),
      SubCategory,
      PrefetchHooks Function({
        bool categoryId,
        bool ownerId,
        bool expensesRefs,
        bool categoryLearningRefs,
      })
    >;
typedef $$ExpensesTableCreateCompanionBuilder =
    ExpensesCompanion Function({
      required String id,
      required String budgetId,
      Value<String?> categoryId,
      Value<String?> subCategoryId,
      Value<String?> semiBudgetId,
      required String enteredBy,
      required String title,
      required int amount,
      Value<String> currency,
      required DateTime date,
      Value<String?> accountId,
      Value<String?> merchantName,
      Value<String> paymentMethod,
      Value<String?> receiptUrl,
      Value<String?> barcodeValue,
      Value<String?> ocrText,
      Value<String?> attachments,
      Value<String?> notes,
      Value<String?> locationName,
      Value<String?> tags,
      Value<bool> isRecurring,
      Value<String?> recurringId,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<bool> isDeleted,
      Value<int?> globalSeq,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<String?> subCategoryRaw,
      Value<String?> semanticTokens,
      Value<double> confidence,
      Value<String> source,
      Value<bool> isAiAssigned,
      Value<bool> isVerified,
      Value<String?> mood,
      Value<String?> socialContext,
      Value<String?> bankTransactionId,
      Value<bool> isTransfer,
      Value<bool> isReconciled,
      Value<bool> isRefund,
      Value<int> rowid,
    });
typedef $$ExpensesTableUpdateCompanionBuilder =
    ExpensesCompanion Function({
      Value<String> id,
      Value<String> budgetId,
      Value<String?> categoryId,
      Value<String?> subCategoryId,
      Value<String?> semiBudgetId,
      Value<String> enteredBy,
      Value<String> title,
      Value<int> amount,
      Value<String> currency,
      Value<DateTime> date,
      Value<String?> accountId,
      Value<String?> merchantName,
      Value<String> paymentMethod,
      Value<String?> receiptUrl,
      Value<String?> barcodeValue,
      Value<String?> ocrText,
      Value<String?> attachments,
      Value<String?> notes,
      Value<String?> locationName,
      Value<String?> tags,
      Value<bool> isRecurring,
      Value<String?> recurringId,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<bool> isDeleted,
      Value<int?> globalSeq,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<String?> subCategoryRaw,
      Value<String?> semanticTokens,
      Value<double> confidence,
      Value<String> source,
      Value<bool> isAiAssigned,
      Value<bool> isVerified,
      Value<String?> mood,
      Value<String?> socialContext,
      Value<String?> bankTransactionId,
      Value<bool> isTransfer,
      Value<bool> isReconciled,
      Value<bool> isRefund,
      Value<int> rowid,
    });

final class $$ExpensesTableReferences
    extends BaseReferences<_$AppDatabase, $ExpensesTable, Expense> {
  $$ExpensesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BudgetsTable _budgetIdTable(_$AppDatabase db) => db.budgets
      .createAlias($_aliasNameGenerator(db.expenses.budgetId, db.budgets.id));

  $$BudgetsTableProcessedTableManager get budgetId {
    final $_column = $_itemColumn<String>('budget_id')!;

    final manager = $$BudgetsTableTableManager(
      $_db,
      $_db.budgets,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_budgetIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $CategoriesTable _categoryIdTable(_$AppDatabase db) =>
      db.categories.createAlias(
        $_aliasNameGenerator(db.expenses.categoryId, db.categories.id),
      );

  $$CategoriesTableProcessedTableManager? get categoryId {
    final $_column = $_itemColumn<String>('category_id');
    if ($_column == null) return null;
    final manager = $$CategoriesTableTableManager(
      $_db,
      $_db.categories,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_categoryIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $SubCategoriesTable _subCategoryIdTable(_$AppDatabase db) =>
      db.subCategories.createAlias(
        $_aliasNameGenerator(db.expenses.subCategoryId, db.subCategories.id),
      );

  $$SubCategoriesTableProcessedTableManager? get subCategoryId {
    final $_column = $_itemColumn<String>('sub_category_id');
    if ($_column == null) return null;
    final manager = $$SubCategoriesTableTableManager(
      $_db,
      $_db.subCategories,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_subCategoryIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $SemiBudgetsTable _semiBudgetIdTable(_$AppDatabase db) =>
      db.semiBudgets.createAlias(
        $_aliasNameGenerator(db.expenses.semiBudgetId, db.semiBudgets.id),
      );

  $$SemiBudgetsTableProcessedTableManager? get semiBudgetId {
    final $_column = $_itemColumn<String>('semi_budget_id');
    if ($_column == null) return null;
    final manager = $$SemiBudgetsTableTableManager(
      $_db,
      $_db.semiBudgets,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_semiBudgetIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _enteredByTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.expenses.enteredBy, db.users.id),
  );

  $$UsersTableProcessedTableManager get enteredBy {
    final $_column = $_itemColumn<String>('entered_by')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_enteredByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $AccountsTable _accountIdTable(_$AppDatabase db) => db.accounts
      .createAlias($_aliasNameGenerator(db.expenses.accountId, db.accounts.id));

  $$AccountsTableProcessedTableManager? get accountId {
    final $_column = $_itemColumn<String>('account_id');
    if ($_column == null) return null;
    final manager = $$AccountsTableTableManager(
      $_db,
      $_db.accounts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_accountIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$ExpenseLocationsTable, List<ExpenseLocation>>
  _expenseLocationsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.expenseLocations,
    aliasName: $_aliasNameGenerator(
      db.expenses.id,
      db.expenseLocations.expenseId,
    ),
  );

  $$ExpenseLocationsTableProcessedTableManager get expenseLocationsRefs {
    final manager = $$ExpenseLocationsTableTableManager(
      $_db,
      $_db.expenseLocations,
    ).filter((f) => f.expenseId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _expenseLocationsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$CanonicalLedgerTable, List<CanonicalLedgerData>>
  _canonicalLedgerRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.canonicalLedger,
    aliasName: $_aliasNameGenerator(
      db.expenses.id,
      db.canonicalLedger.derivedExpenseId,
    ),
  );

  $$CanonicalLedgerTableProcessedTableManager get canonicalLedgerRefs {
    final manager =
        $$CanonicalLedgerTableTableManager($_db, $_db.canonicalLedger).filter(
          (f) => f.derivedExpenseId.id.sqlEquals($_itemColumn<String>('id')!),
        );

    final cache = $_typedResult.readTableOrNull(
      _canonicalLedgerRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$SplitTransactionsTable, List<SplitTransaction>>
  _splitTransactionsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.splitTransactions,
        aliasName: $_aliasNameGenerator(
          db.expenses.id,
          db.splitTransactions.expenseId,
        ),
      );

  $$SplitTransactionsTableProcessedTableManager get splitTransactionsRefs {
    final manager = $$SplitTransactionsTableTableManager(
      $_db,
      $_db.splitTransactions,
    ).filter((f) => f.expenseId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _splitTransactionsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$ExpensesTableFilterComposer
    extends Composer<_$AppDatabase, $ExpensesTable> {
  $$ExpensesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get merchantName => $composableBuilder(
    column: $table.merchantName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get paymentMethod => $composableBuilder(
    column: $table.paymentMethod,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get receiptUrl => $composableBuilder(
    column: $table.receiptUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get barcodeValue => $composableBuilder(
    column: $table.barcodeValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get ocrText => $composableBuilder(
    column: $table.ocrText,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get attachments => $composableBuilder(
    column: $table.attachments,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get locationName => $composableBuilder(
    column: $table.locationName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tags => $composableBuilder(
    column: $table.tags,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isRecurring => $composableBuilder(
    column: $table.isRecurring,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get recurringId => $composableBuilder(
    column: $table.recurringId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get globalSeq => $composableBuilder(
    column: $table.globalSeq,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get subCategoryRaw => $composableBuilder(
    column: $table.subCategoryRaw,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get semanticTokens => $composableBuilder(
    column: $table.semanticTokens,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get confidence => $composableBuilder(
    column: $table.confidence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isAiAssigned => $composableBuilder(
    column: $table.isAiAssigned,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isVerified => $composableBuilder(
    column: $table.isVerified,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get mood => $composableBuilder(
    column: $table.mood,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get socialContext => $composableBuilder(
    column: $table.socialContext,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get bankTransactionId => $composableBuilder(
    column: $table.bankTransactionId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isTransfer => $composableBuilder(
    column: $table.isTransfer,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isReconciled => $composableBuilder(
    column: $table.isReconciled,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isRefund => $composableBuilder(
    column: $table.isRefund,
    builder: (column) => ColumnFilters(column),
  );

  $$BudgetsTableFilterComposer get budgetId {
    final $$BudgetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.budgetId,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableFilterComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CategoriesTableFilterComposer get categoryId {
    final $$CategoriesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableFilterComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SubCategoriesTableFilterComposer get subCategoryId {
    final $$SubCategoriesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.subCategoryId,
      referencedTable: $db.subCategories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SubCategoriesTableFilterComposer(
            $db: $db,
            $table: $db.subCategories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SemiBudgetsTableFilterComposer get semiBudgetId {
    final $$SemiBudgetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.semiBudgetId,
      referencedTable: $db.semiBudgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SemiBudgetsTableFilterComposer(
            $db: $db,
            $table: $db.semiBudgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get enteredBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.enteredBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AccountsTableFilterComposer get accountId {
    final $$AccountsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.accountId,
      referencedTable: $db.accounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AccountsTableFilterComposer(
            $db: $db,
            $table: $db.accounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> expenseLocationsRefs(
    Expression<bool> Function($$ExpenseLocationsTableFilterComposer f) f,
  ) {
    final $$ExpenseLocationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenseLocations,
      getReferencedColumn: (t) => t.expenseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpenseLocationsTableFilterComposer(
            $db: $db,
            $table: $db.expenseLocations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> canonicalLedgerRefs(
    Expression<bool> Function($$CanonicalLedgerTableFilterComposer f) f,
  ) {
    final $$CanonicalLedgerTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.canonicalLedger,
      getReferencedColumn: (t) => t.derivedExpenseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CanonicalLedgerTableFilterComposer(
            $db: $db,
            $table: $db.canonicalLedger,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> splitTransactionsRefs(
    Expression<bool> Function($$SplitTransactionsTableFilterComposer f) f,
  ) {
    final $$SplitTransactionsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.splitTransactions,
      getReferencedColumn: (t) => t.expenseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SplitTransactionsTableFilterComposer(
            $db: $db,
            $table: $db.splitTransactions,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$ExpensesTableOrderingComposer
    extends Composer<_$AppDatabase, $ExpensesTable> {
  $$ExpensesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get merchantName => $composableBuilder(
    column: $table.merchantName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get paymentMethod => $composableBuilder(
    column: $table.paymentMethod,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get receiptUrl => $composableBuilder(
    column: $table.receiptUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get barcodeValue => $composableBuilder(
    column: $table.barcodeValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get ocrText => $composableBuilder(
    column: $table.ocrText,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get attachments => $composableBuilder(
    column: $table.attachments,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get locationName => $composableBuilder(
    column: $table.locationName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tags => $composableBuilder(
    column: $table.tags,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isRecurring => $composableBuilder(
    column: $table.isRecurring,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get recurringId => $composableBuilder(
    column: $table.recurringId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get globalSeq => $composableBuilder(
    column: $table.globalSeq,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get subCategoryRaw => $composableBuilder(
    column: $table.subCategoryRaw,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get semanticTokens => $composableBuilder(
    column: $table.semanticTokens,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get confidence => $composableBuilder(
    column: $table.confidence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isAiAssigned => $composableBuilder(
    column: $table.isAiAssigned,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isVerified => $composableBuilder(
    column: $table.isVerified,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get mood => $composableBuilder(
    column: $table.mood,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get socialContext => $composableBuilder(
    column: $table.socialContext,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get bankTransactionId => $composableBuilder(
    column: $table.bankTransactionId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isTransfer => $composableBuilder(
    column: $table.isTransfer,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isReconciled => $composableBuilder(
    column: $table.isReconciled,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isRefund => $composableBuilder(
    column: $table.isRefund,
    builder: (column) => ColumnOrderings(column),
  );

  $$BudgetsTableOrderingComposer get budgetId {
    final $$BudgetsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.budgetId,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableOrderingComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CategoriesTableOrderingComposer get categoryId {
    final $$CategoriesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableOrderingComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SubCategoriesTableOrderingComposer get subCategoryId {
    final $$SubCategoriesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.subCategoryId,
      referencedTable: $db.subCategories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SubCategoriesTableOrderingComposer(
            $db: $db,
            $table: $db.subCategories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SemiBudgetsTableOrderingComposer get semiBudgetId {
    final $$SemiBudgetsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.semiBudgetId,
      referencedTable: $db.semiBudgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SemiBudgetsTableOrderingComposer(
            $db: $db,
            $table: $db.semiBudgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get enteredBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.enteredBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AccountsTableOrderingComposer get accountId {
    final $$AccountsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.accountId,
      referencedTable: $db.accounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AccountsTableOrderingComposer(
            $db: $db,
            $table: $db.accounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ExpensesTableAnnotationComposer
    extends Composer<_$AppDatabase, $ExpensesTable> {
  $$ExpensesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<int> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<String> get currency =>
      $composableBuilder(column: $table.currency, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<String> get merchantName => $composableBuilder(
    column: $table.merchantName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get paymentMethod => $composableBuilder(
    column: $table.paymentMethod,
    builder: (column) => column,
  );

  GeneratedColumn<String> get receiptUrl => $composableBuilder(
    column: $table.receiptUrl,
    builder: (column) => column,
  );

  GeneratedColumn<String> get barcodeValue => $composableBuilder(
    column: $table.barcodeValue,
    builder: (column) => column,
  );

  GeneratedColumn<String> get ocrText =>
      $composableBuilder(column: $table.ocrText, builder: (column) => column);

  GeneratedColumn<String> get attachments => $composableBuilder(
    column: $table.attachments,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<String> get locationName => $composableBuilder(
    column: $table.locationName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get tags =>
      $composableBuilder(column: $table.tags, builder: (column) => column);

  GeneratedColumn<bool> get isRecurring => $composableBuilder(
    column: $table.isRecurring,
    builder: (column) => column,
  );

  GeneratedColumn<String> get recurringId => $composableBuilder(
    column: $table.recurringId,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => column,
  );

  GeneratedColumn<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<int> get globalSeq =>
      $composableBuilder(column: $table.globalSeq, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  GeneratedColumn<String> get subCategoryRaw => $composableBuilder(
    column: $table.subCategoryRaw,
    builder: (column) => column,
  );

  GeneratedColumn<String> get semanticTokens => $composableBuilder(
    column: $table.semanticTokens,
    builder: (column) => column,
  );

  GeneratedColumn<double> get confidence => $composableBuilder(
    column: $table.confidence,
    builder: (column) => column,
  );

  GeneratedColumn<String> get source =>
      $composableBuilder(column: $table.source, builder: (column) => column);

  GeneratedColumn<bool> get isAiAssigned => $composableBuilder(
    column: $table.isAiAssigned,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isVerified => $composableBuilder(
    column: $table.isVerified,
    builder: (column) => column,
  );

  GeneratedColumn<String> get mood =>
      $composableBuilder(column: $table.mood, builder: (column) => column);

  GeneratedColumn<String> get socialContext => $composableBuilder(
    column: $table.socialContext,
    builder: (column) => column,
  );

  GeneratedColumn<String> get bankTransactionId => $composableBuilder(
    column: $table.bankTransactionId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isTransfer => $composableBuilder(
    column: $table.isTransfer,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isReconciled => $composableBuilder(
    column: $table.isReconciled,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isRefund =>
      $composableBuilder(column: $table.isRefund, builder: (column) => column);

  $$BudgetsTableAnnotationComposer get budgetId {
    final $$BudgetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.budgetId,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableAnnotationComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$CategoriesTableAnnotationComposer get categoryId {
    final $$CategoriesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.categoryId,
      referencedTable: $db.categories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CategoriesTableAnnotationComposer(
            $db: $db,
            $table: $db.categories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SubCategoriesTableAnnotationComposer get subCategoryId {
    final $$SubCategoriesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.subCategoryId,
      referencedTable: $db.subCategories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SubCategoriesTableAnnotationComposer(
            $db: $db,
            $table: $db.subCategories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SemiBudgetsTableAnnotationComposer get semiBudgetId {
    final $$SemiBudgetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.semiBudgetId,
      referencedTable: $db.semiBudgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SemiBudgetsTableAnnotationComposer(
            $db: $db,
            $table: $db.semiBudgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get enteredBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.enteredBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AccountsTableAnnotationComposer get accountId {
    final $$AccountsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.accountId,
      referencedTable: $db.accounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AccountsTableAnnotationComposer(
            $db: $db,
            $table: $db.accounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> expenseLocationsRefs<T extends Object>(
    Expression<T> Function($$ExpenseLocationsTableAnnotationComposer a) f,
  ) {
    final $$ExpenseLocationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenseLocations,
      getReferencedColumn: (t) => t.expenseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpenseLocationsTableAnnotationComposer(
            $db: $db,
            $table: $db.expenseLocations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> canonicalLedgerRefs<T extends Object>(
    Expression<T> Function($$CanonicalLedgerTableAnnotationComposer a) f,
  ) {
    final $$CanonicalLedgerTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.canonicalLedger,
      getReferencedColumn: (t) => t.derivedExpenseId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CanonicalLedgerTableAnnotationComposer(
            $db: $db,
            $table: $db.canonicalLedger,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> splitTransactionsRefs<T extends Object>(
    Expression<T> Function($$SplitTransactionsTableAnnotationComposer a) f,
  ) {
    final $$SplitTransactionsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.splitTransactions,
          getReferencedColumn: (t) => t.expenseId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$SplitTransactionsTableAnnotationComposer(
                $db: $db,
                $table: $db.splitTransactions,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$ExpensesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ExpensesTable,
          Expense,
          $$ExpensesTableFilterComposer,
          $$ExpensesTableOrderingComposer,
          $$ExpensesTableAnnotationComposer,
          $$ExpensesTableCreateCompanionBuilder,
          $$ExpensesTableUpdateCompanionBuilder,
          (Expense, $$ExpensesTableReferences),
          Expense,
          PrefetchHooks Function({
            bool budgetId,
            bool categoryId,
            bool subCategoryId,
            bool semiBudgetId,
            bool enteredBy,
            bool accountId,
            bool expenseLocationsRefs,
            bool canonicalLedgerRefs,
            bool splitTransactionsRefs,
          })
        > {
  $$ExpensesTableTableManager(_$AppDatabase db, $ExpensesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ExpensesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ExpensesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ExpensesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> budgetId = const Value.absent(),
                Value<String?> categoryId = const Value.absent(),
                Value<String?> subCategoryId = const Value.absent(),
                Value<String?> semiBudgetId = const Value.absent(),
                Value<String> enteredBy = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<int> amount = const Value.absent(),
                Value<String> currency = const Value.absent(),
                Value<DateTime> date = const Value.absent(),
                Value<String?> accountId = const Value.absent(),
                Value<String?> merchantName = const Value.absent(),
                Value<String> paymentMethod = const Value.absent(),
                Value<String?> receiptUrl = const Value.absent(),
                Value<String?> barcodeValue = const Value.absent(),
                Value<String?> ocrText = const Value.absent(),
                Value<String?> attachments = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> locationName = const Value.absent(),
                Value<String?> tags = const Value.absent(),
                Value<bool> isRecurring = const Value.absent(),
                Value<String?> recurringId = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int?> globalSeq = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<String?> subCategoryRaw = const Value.absent(),
                Value<String?> semanticTokens = const Value.absent(),
                Value<double> confidence = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<bool> isAiAssigned = const Value.absent(),
                Value<bool> isVerified = const Value.absent(),
                Value<String?> mood = const Value.absent(),
                Value<String?> socialContext = const Value.absent(),
                Value<String?> bankTransactionId = const Value.absent(),
                Value<bool> isTransfer = const Value.absent(),
                Value<bool> isReconciled = const Value.absent(),
                Value<bool> isRefund = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ExpensesCompanion(
                id: id,
                budgetId: budgetId,
                categoryId: categoryId,
                subCategoryId: subCategoryId,
                semiBudgetId: semiBudgetId,
                enteredBy: enteredBy,
                title: title,
                amount: amount,
                currency: currency,
                date: date,
                accountId: accountId,
                merchantName: merchantName,
                paymentMethod: paymentMethod,
                receiptUrl: receiptUrl,
                barcodeValue: barcodeValue,
                ocrText: ocrText,
                attachments: attachments,
                notes: notes,
                locationName: locationName,
                tags: tags,
                isRecurring: isRecurring,
                recurringId: recurringId,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                isDeleted: isDeleted,
                globalSeq: globalSeq,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                subCategoryRaw: subCategoryRaw,
                semanticTokens: semanticTokens,
                confidence: confidence,
                source: source,
                isAiAssigned: isAiAssigned,
                isVerified: isVerified,
                mood: mood,
                socialContext: socialContext,
                bankTransactionId: bankTransactionId,
                isTransfer: isTransfer,
                isReconciled: isReconciled,
                isRefund: isRefund,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String budgetId,
                Value<String?> categoryId = const Value.absent(),
                Value<String?> subCategoryId = const Value.absent(),
                Value<String?> semiBudgetId = const Value.absent(),
                required String enteredBy,
                required String title,
                required int amount,
                Value<String> currency = const Value.absent(),
                required DateTime date,
                Value<String?> accountId = const Value.absent(),
                Value<String?> merchantName = const Value.absent(),
                Value<String> paymentMethod = const Value.absent(),
                Value<String?> receiptUrl = const Value.absent(),
                Value<String?> barcodeValue = const Value.absent(),
                Value<String?> ocrText = const Value.absent(),
                Value<String?> attachments = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<String?> locationName = const Value.absent(),
                Value<String?> tags = const Value.absent(),
                Value<bool> isRecurring = const Value.absent(),
                Value<String?> recurringId = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int?> globalSeq = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<String?> subCategoryRaw = const Value.absent(),
                Value<String?> semanticTokens = const Value.absent(),
                Value<double> confidence = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<bool> isAiAssigned = const Value.absent(),
                Value<bool> isVerified = const Value.absent(),
                Value<String?> mood = const Value.absent(),
                Value<String?> socialContext = const Value.absent(),
                Value<String?> bankTransactionId = const Value.absent(),
                Value<bool> isTransfer = const Value.absent(),
                Value<bool> isReconciled = const Value.absent(),
                Value<bool> isRefund = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ExpensesCompanion.insert(
                id: id,
                budgetId: budgetId,
                categoryId: categoryId,
                subCategoryId: subCategoryId,
                semiBudgetId: semiBudgetId,
                enteredBy: enteredBy,
                title: title,
                amount: amount,
                currency: currency,
                date: date,
                accountId: accountId,
                merchantName: merchantName,
                paymentMethod: paymentMethod,
                receiptUrl: receiptUrl,
                barcodeValue: barcodeValue,
                ocrText: ocrText,
                attachments: attachments,
                notes: notes,
                locationName: locationName,
                tags: tags,
                isRecurring: isRecurring,
                recurringId: recurringId,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                isDeleted: isDeleted,
                globalSeq: globalSeq,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                subCategoryRaw: subCategoryRaw,
                semanticTokens: semanticTokens,
                confidence: confidence,
                source: source,
                isAiAssigned: isAiAssigned,
                isVerified: isVerified,
                mood: mood,
                socialContext: socialContext,
                bankTransactionId: bankTransactionId,
                isTransfer: isTransfer,
                isReconciled: isReconciled,
                isRefund: isRefund,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ExpensesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                budgetId = false,
                categoryId = false,
                subCategoryId = false,
                semiBudgetId = false,
                enteredBy = false,
                accountId = false,
                expenseLocationsRefs = false,
                canonicalLedgerRefs = false,
                splitTransactionsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (expenseLocationsRefs) db.expenseLocations,
                    if (canonicalLedgerRefs) db.canonicalLedger,
                    if (splitTransactionsRefs) db.splitTransactions,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (budgetId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.budgetId,
                                    referencedTable: $$ExpensesTableReferences
                                        ._budgetIdTable(db),
                                    referencedColumn: $$ExpensesTableReferences
                                        ._budgetIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (categoryId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.categoryId,
                                    referencedTable: $$ExpensesTableReferences
                                        ._categoryIdTable(db),
                                    referencedColumn: $$ExpensesTableReferences
                                        ._categoryIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (subCategoryId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.subCategoryId,
                                    referencedTable: $$ExpensesTableReferences
                                        ._subCategoryIdTable(db),
                                    referencedColumn: $$ExpensesTableReferences
                                        ._subCategoryIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (semiBudgetId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.semiBudgetId,
                                    referencedTable: $$ExpensesTableReferences
                                        ._semiBudgetIdTable(db),
                                    referencedColumn: $$ExpensesTableReferences
                                        ._semiBudgetIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (enteredBy) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.enteredBy,
                                    referencedTable: $$ExpensesTableReferences
                                        ._enteredByTable(db),
                                    referencedColumn: $$ExpensesTableReferences
                                        ._enteredByTable(db)
                                        .id,
                                  )
                                  as T;
                        }
                        if (accountId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.accountId,
                                    referencedTable: $$ExpensesTableReferences
                                        ._accountIdTable(db),
                                    referencedColumn: $$ExpensesTableReferences
                                        ._accountIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (expenseLocationsRefs)
                        await $_getPrefetchedData<
                          Expense,
                          $ExpensesTable,
                          ExpenseLocation
                        >(
                          currentTable: table,
                          referencedTable: $$ExpensesTableReferences
                              ._expenseLocationsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ExpensesTableReferences(
                                db,
                                table,
                                p0,
                              ).expenseLocationsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.expenseId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (canonicalLedgerRefs)
                        await $_getPrefetchedData<
                          Expense,
                          $ExpensesTable,
                          CanonicalLedgerData
                        >(
                          currentTable: table,
                          referencedTable: $$ExpensesTableReferences
                              ._canonicalLedgerRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ExpensesTableReferences(
                                db,
                                table,
                                p0,
                              ).canonicalLedgerRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.derivedExpenseId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (splitTransactionsRefs)
                        await $_getPrefetchedData<
                          Expense,
                          $ExpensesTable,
                          SplitTransaction
                        >(
                          currentTable: table,
                          referencedTable: $$ExpensesTableReferences
                              ._splitTransactionsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$ExpensesTableReferences(
                                db,
                                table,
                                p0,
                              ).splitTransactionsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.expenseId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$ExpensesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ExpensesTable,
      Expense,
      $$ExpensesTableFilterComposer,
      $$ExpensesTableOrderingComposer,
      $$ExpensesTableAnnotationComposer,
      $$ExpensesTableCreateCompanionBuilder,
      $$ExpensesTableUpdateCompanionBuilder,
      (Expense, $$ExpensesTableReferences),
      Expense,
      PrefetchHooks Function({
        bool budgetId,
        bool categoryId,
        bool subCategoryId,
        bool semiBudgetId,
        bool enteredBy,
        bool accountId,
        bool expenseLocationsRefs,
        bool canonicalLedgerRefs,
        bool splitTransactionsRefs,
      })
    >;
typedef $$BudgetMembersTableCreateCompanionBuilder =
    BudgetMembersCompanion Function({
      required String id,
      required String budgetId,
      Value<String?> userId,
      required String memberEmail,
      Value<String?> memberName,
      required String role,
      Value<String> status,
      Value<String?> invitedBy,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> invitedAt,
      Value<DateTime?> acceptedAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<bool> isDeleted,
      Value<String?> lastModifiedByDeviceId,
      Value<int> revision,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int?> spendingLimit,
      Value<int> rowid,
    });
typedef $$BudgetMembersTableUpdateCompanionBuilder =
    BudgetMembersCompanion Function({
      Value<String> id,
      Value<String> budgetId,
      Value<String?> userId,
      Value<String> memberEmail,
      Value<String?> memberName,
      Value<String> role,
      Value<String> status,
      Value<String?> invitedBy,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> invitedAt,
      Value<DateTime?> acceptedAt,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<bool> isDeleted,
      Value<String?> lastModifiedByDeviceId,
      Value<int> revision,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int?> spendingLimit,
      Value<int> rowid,
    });

final class $$BudgetMembersTableReferences
    extends BaseReferences<_$AppDatabase, $BudgetMembersTable, BudgetMember> {
  $$BudgetMembersTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $BudgetsTable _budgetIdTable(_$AppDatabase db) =>
      db.budgets.createAlias(
        $_aliasNameGenerator(db.budgetMembers.budgetId, db.budgets.id),
      );

  $$BudgetsTableProcessedTableManager get budgetId {
    final $_column = $_itemColumn<String>('budget_id')!;

    final manager = $$BudgetsTableTableManager(
      $_db,
      $_db.budgets,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_budgetIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.budgetMembers.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager? get userId {
    final $_column = $_itemColumn<String>('user_id');
    if ($_column == null) return null;
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _invitedByTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.budgetMembers.invitedBy, db.users.id),
  );

  $$UsersTableProcessedTableManager? get invitedBy {
    final $_column = $_itemColumn<String>('invited_by');
    if ($_column == null) return null;
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_invitedByTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$BudgetMembersTableFilterComposer
    extends Composer<_$AppDatabase, $BudgetMembersTable> {
  $$BudgetMembersTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get memberEmail => $composableBuilder(
    column: $table.memberEmail,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get memberName => $composableBuilder(
    column: $table.memberName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get role => $composableBuilder(
    column: $table.role,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get invitedAt => $composableBuilder(
    column: $table.invitedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get acceptedAt => $composableBuilder(
    column: $table.acceptedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get spendingLimit => $composableBuilder(
    column: $table.spendingLimit,
    builder: (column) => ColumnFilters(column),
  );

  $$BudgetsTableFilterComposer get budgetId {
    final $$BudgetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.budgetId,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableFilterComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get invitedBy {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.invitedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BudgetMembersTableOrderingComposer
    extends Composer<_$AppDatabase, $BudgetMembersTable> {
  $$BudgetMembersTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get memberEmail => $composableBuilder(
    column: $table.memberEmail,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get memberName => $composableBuilder(
    column: $table.memberName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get role => $composableBuilder(
    column: $table.role,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get invitedAt => $composableBuilder(
    column: $table.invitedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get acceptedAt => $composableBuilder(
    column: $table.acceptedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get spendingLimit => $composableBuilder(
    column: $table.spendingLimit,
    builder: (column) => ColumnOrderings(column),
  );

  $$BudgetsTableOrderingComposer get budgetId {
    final $$BudgetsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.budgetId,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableOrderingComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get invitedBy {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.invitedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BudgetMembersTableAnnotationComposer
    extends Composer<_$AppDatabase, $BudgetMembersTable> {
  $$BudgetMembersTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get memberEmail => $composableBuilder(
    column: $table.memberEmail,
    builder: (column) => column,
  );

  GeneratedColumn<String> get memberName => $composableBuilder(
    column: $table.memberName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get role =>
      $composableBuilder(column: $table.role, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<DateTime> get invitedAt =>
      $composableBuilder(column: $table.invitedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get acceptedAt => $composableBuilder(
    column: $table.acceptedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  GeneratedColumn<int> get spendingLimit => $composableBuilder(
    column: $table.spendingLimit,
    builder: (column) => column,
  );

  $$BudgetsTableAnnotationComposer get budgetId {
    final $$BudgetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.budgetId,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableAnnotationComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get invitedBy {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.invitedBy,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BudgetMembersTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BudgetMembersTable,
          BudgetMember,
          $$BudgetMembersTableFilterComposer,
          $$BudgetMembersTableOrderingComposer,
          $$BudgetMembersTableAnnotationComposer,
          $$BudgetMembersTableCreateCompanionBuilder,
          $$BudgetMembersTableUpdateCompanionBuilder,
          (BudgetMember, $$BudgetMembersTableReferences),
          BudgetMember,
          PrefetchHooks Function({bool budgetId, bool userId, bool invitedBy})
        > {
  $$BudgetMembersTableTableManager(_$AppDatabase db, $BudgetMembersTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BudgetMembersTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$BudgetMembersTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$BudgetMembersTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> budgetId = const Value.absent(),
                Value<String?> userId = const Value.absent(),
                Value<String> memberEmail = const Value.absent(),
                Value<String?> memberName = const Value.absent(),
                Value<String> role = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> invitedBy = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> invitedAt = const Value.absent(),
                Value<DateTime?> acceptedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int?> spendingLimit = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BudgetMembersCompanion(
                id: id,
                budgetId: budgetId,
                userId: userId,
                memberEmail: memberEmail,
                memberName: memberName,
                role: role,
                status: status,
                invitedBy: invitedBy,
                metadata: metadata,
                invitedAt: invitedAt,
                acceptedAt: acceptedAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                isDeleted: isDeleted,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                revision: revision,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                spendingLimit: spendingLimit,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String budgetId,
                Value<String?> userId = const Value.absent(),
                required String memberEmail,
                Value<String?> memberName = const Value.absent(),
                required String role,
                Value<String> status = const Value.absent(),
                Value<String?> invitedBy = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> invitedAt = const Value.absent(),
                Value<DateTime?> acceptedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int?> spendingLimit = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BudgetMembersCompanion.insert(
                id: id,
                budgetId: budgetId,
                userId: userId,
                memberEmail: memberEmail,
                memberName: memberName,
                role: role,
                status: status,
                invitedBy: invitedBy,
                metadata: metadata,
                invitedAt: invitedAt,
                acceptedAt: acceptedAt,
                createdAt: createdAt,
                updatedAt: updatedAt,
                isDeleted: isDeleted,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                revision: revision,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                spendingLimit: spendingLimit,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$BudgetMembersTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({budgetId = false, userId = false, invitedBy = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (budgetId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.budgetId,
                                    referencedTable:
                                        $$BudgetMembersTableReferences
                                            ._budgetIdTable(db),
                                    referencedColumn:
                                        $$BudgetMembersTableReferences
                                            ._budgetIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (userId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.userId,
                                    referencedTable:
                                        $$BudgetMembersTableReferences
                                            ._userIdTable(db),
                                    referencedColumn:
                                        $$BudgetMembersTableReferences
                                            ._userIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (invitedBy) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.invitedBy,
                                    referencedTable:
                                        $$BudgetMembersTableReferences
                                            ._invitedByTable(db),
                                    referencedColumn:
                                        $$BudgetMembersTableReferences
                                            ._invitedByTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$BudgetMembersTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BudgetMembersTable,
      BudgetMember,
      $$BudgetMembersTableFilterComposer,
      $$BudgetMembersTableOrderingComposer,
      $$BudgetMembersTableAnnotationComposer,
      $$BudgetMembersTableCreateCompanionBuilder,
      $$BudgetMembersTableUpdateCompanionBuilder,
      (BudgetMember, $$BudgetMembersTableReferences),
      BudgetMember,
      PrefetchHooks Function({bool budgetId, bool userId, bool invitedBy})
    >;
typedef $$ActivityLogsTableCreateCompanionBuilder =
    ActivityLogsCompanion Function({
      required String id,
      required String budgetId,
      required String userId,
      required String action,
      required String entityType,
      Value<String?> entityId,
      Value<Map<String, dynamic>?> details,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$ActivityLogsTableUpdateCompanionBuilder =
    ActivityLogsCompanion Function({
      Value<String> id,
      Value<String> budgetId,
      Value<String> userId,
      Value<String> action,
      Value<String> entityType,
      Value<String?> entityId,
      Value<Map<String, dynamic>?> details,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$ActivityLogsTableReferences
    extends BaseReferences<_$AppDatabase, $ActivityLogsTable, ActivityLog> {
  $$ActivityLogsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $BudgetsTable _budgetIdTable(_$AppDatabase db) =>
      db.budgets.createAlias(
        $_aliasNameGenerator(db.activityLogs.budgetId, db.budgets.id),
      );

  $$BudgetsTableProcessedTableManager get budgetId {
    final $_column = $_itemColumn<String>('budget_id')!;

    final manager = $$BudgetsTableTableManager(
      $_db,
      $_db.budgets,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_budgetIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.activityLogs.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ActivityLogsTableFilterComposer
    extends Composer<_$AppDatabase, $ActivityLogsTable> {
  $$ActivityLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get details => $composableBuilder(
    column: $table.details,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$BudgetsTableFilterComposer get budgetId {
    final $$BudgetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.budgetId,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableFilterComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ActivityLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $ActivityLogsTable> {
  $$ActivityLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get details => $composableBuilder(
    column: $table.details,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$BudgetsTableOrderingComposer get budgetId {
    final $$BudgetsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.budgetId,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableOrderingComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ActivityLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ActivityLogsTable> {
  $$ActivityLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityId =>
      $composableBuilder(column: $table.entityId, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String> get details =>
      $composableBuilder(column: $table.details, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$BudgetsTableAnnotationComposer get budgetId {
    final $$BudgetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.budgetId,
      referencedTable: $db.budgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$BudgetsTableAnnotationComposer(
            $db: $db,
            $table: $db.budgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ActivityLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ActivityLogsTable,
          ActivityLog,
          $$ActivityLogsTableFilterComposer,
          $$ActivityLogsTableOrderingComposer,
          $$ActivityLogsTableAnnotationComposer,
          $$ActivityLogsTableCreateCompanionBuilder,
          $$ActivityLogsTableUpdateCompanionBuilder,
          (ActivityLog, $$ActivityLogsTableReferences),
          ActivityLog,
          PrefetchHooks Function({bool budgetId, bool userId})
        > {
  $$ActivityLogsTableTableManager(_$AppDatabase db, $ActivityLogsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ActivityLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ActivityLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ActivityLogsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> budgetId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> action = const Value.absent(),
                Value<String> entityType = const Value.absent(),
                Value<String?> entityId = const Value.absent(),
                Value<Map<String, dynamic>?> details = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivityLogsCompanion(
                id: id,
                budgetId: budgetId,
                userId: userId,
                action: action,
                entityType: entityType,
                entityId: entityId,
                details: details,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String budgetId,
                required String userId,
                required String action,
                required String entityType,
                Value<String?> entityId = const Value.absent(),
                Value<Map<String, dynamic>?> details = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ActivityLogsCompanion.insert(
                id: id,
                budgetId: budgetId,
                userId: userId,
                action: action,
                entityType: entityType,
                entityId: entityId,
                details: details,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ActivityLogsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({budgetId = false, userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (budgetId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.budgetId,
                                referencedTable: $$ActivityLogsTableReferences
                                    ._budgetIdTable(db),
                                referencedColumn: $$ActivityLogsTableReferences
                                    ._budgetIdTable(db)
                                    .id,
                              )
                              as T;
                    }
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable: $$ActivityLogsTableReferences
                                    ._userIdTable(db),
                                referencedColumn: $$ActivityLogsTableReferences
                                    ._userIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$ActivityLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ActivityLogsTable,
      ActivityLog,
      $$ActivityLogsTableFilterComposer,
      $$ActivityLogsTableOrderingComposer,
      $$ActivityLogsTableAnnotationComposer,
      $$ActivityLogsTableCreateCompanionBuilder,
      $$ActivityLogsTableUpdateCompanionBuilder,
      (ActivityLog, $$ActivityLogsTableReferences),
      ActivityLog,
      PrefetchHooks Function({bool budgetId, bool userId})
    >;
typedef $$AuditLogsTableCreateCompanionBuilder =
    AuditLogsCompanion Function({
      required String id,
      required String entityType,
      required String entityId,
      required String action,
      required String userId,
      Value<String?> oldValue,
      Value<String?> newValue,
      Value<String?> correlationId,
      Value<String?> deviceId,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<String> syncState,
      Value<int> revision,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$AuditLogsTableUpdateCompanionBuilder =
    AuditLogsCompanion Function({
      Value<String> id,
      Value<String> entityType,
      Value<String> entityId,
      Value<String> action,
      Value<String> userId,
      Value<String?> oldValue,
      Value<String?> newValue,
      Value<String?> correlationId,
      Value<String?> deviceId,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<String> syncState,
      Value<int> revision,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$AuditLogsTableReferences
    extends BaseReferences<_$AppDatabase, $AuditLogsTable, AuditLog> {
  $$AuditLogsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.auditLogs.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$AuditLogsTableFilterComposer
    extends Composer<_$AppDatabase, $AuditLogsTable> {
  $$AuditLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get oldValue => $composableBuilder(
    column: $table.oldValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get newValue => $composableBuilder(
    column: $table.newValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get correlationId => $composableBuilder(
    column: $table.correlationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get deviceId => $composableBuilder(
    column: $table.deviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AuditLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $AuditLogsTable> {
  $$AuditLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get oldValue => $composableBuilder(
    column: $table.oldValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get newValue => $composableBuilder(
    column: $table.newValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get correlationId => $composableBuilder(
    column: $table.correlationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get deviceId => $composableBuilder(
    column: $table.deviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AuditLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AuditLogsTable> {
  $$AuditLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityId =>
      $composableBuilder(column: $table.entityId, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get oldValue =>
      $composableBuilder(column: $table.oldValue, builder: (column) => column);

  GeneratedColumn<String> get newValue =>
      $composableBuilder(column: $table.newValue, builder: (column) => column);

  GeneratedColumn<String> get correlationId => $composableBuilder(
    column: $table.correlationId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get deviceId =>
      $composableBuilder(column: $table.deviceId, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AuditLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AuditLogsTable,
          AuditLog,
          $$AuditLogsTableFilterComposer,
          $$AuditLogsTableOrderingComposer,
          $$AuditLogsTableAnnotationComposer,
          $$AuditLogsTableCreateCompanionBuilder,
          $$AuditLogsTableUpdateCompanionBuilder,
          (AuditLog, $$AuditLogsTableReferences),
          AuditLog,
          PrefetchHooks Function({bool userId})
        > {
  $$AuditLogsTableTableManager(_$AppDatabase db, $AuditLogsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AuditLogsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AuditLogsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AuditLogsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> entityType = const Value.absent(),
                Value<String> entityId = const Value.absent(),
                Value<String> action = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String?> oldValue = const Value.absent(),
                Value<String?> newValue = const Value.absent(),
                Value<String?> correlationId = const Value.absent(),
                Value<String?> deviceId = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AuditLogsCompanion(
                id: id,
                entityType: entityType,
                entityId: entityId,
                action: action,
                userId: userId,
                oldValue: oldValue,
                newValue: newValue,
                correlationId: correlationId,
                deviceId: deviceId,
                metadata: metadata,
                createdAt: createdAt,
                syncState: syncState,
                revision: revision,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String entityType,
                required String entityId,
                required String action,
                required String userId,
                Value<String?> oldValue = const Value.absent(),
                Value<String?> newValue = const Value.absent(),
                Value<String?> correlationId = const Value.absent(),
                Value<String?> deviceId = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AuditLogsCompanion.insert(
                id: id,
                entityType: entityType,
                entityId: entityId,
                action: action,
                userId: userId,
                oldValue: oldValue,
                newValue: newValue,
                correlationId: correlationId,
                deviceId: deviceId,
                metadata: metadata,
                createdAt: createdAt,
                syncState: syncState,
                revision: revision,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$AuditLogsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable: $$AuditLogsTableReferences
                                    ._userIdTable(db),
                                referencedColumn: $$AuditLogsTableReferences
                                    ._userIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$AuditLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AuditLogsTable,
      AuditLog,
      $$AuditLogsTableFilterComposer,
      $$AuditLogsTableOrderingComposer,
      $$AuditLogsTableAnnotationComposer,
      $$AuditLogsTableCreateCompanionBuilder,
      $$AuditLogsTableUpdateCompanionBuilder,
      (AuditLog, $$AuditLogsTableReferences),
      AuditLog,
      PrefetchHooks Function({bool userId})
    >;
typedef $$SyncQueueTableCreateCompanionBuilder =
    SyncQueueCompanion Function({
      Value<int> id,
      required String syncTableName,
      required String recordId,
      required String operation,
      required String payload,
      Value<DateTime> timestamp,
      Value<int> retryCount,
      Value<bool> isSynced,
    });
typedef $$SyncQueueTableUpdateCompanionBuilder =
    SyncQueueCompanion Function({
      Value<int> id,
      Value<String> syncTableName,
      Value<String> recordId,
      Value<String> operation,
      Value<String> payload,
      Value<DateTime> timestamp,
      Value<int> retryCount,
      Value<bool> isSynced,
    });

class $$SyncQueueTableFilterComposer
    extends Composer<_$AppDatabase, $SyncQueueTable> {
  $$SyncQueueTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncTableName => $composableBuilder(
    column: $table.syncTableName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get recordId => $composableBuilder(
    column: $table.recordId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operation => $composableBuilder(
    column: $table.operation,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get payload => $composableBuilder(
    column: $table.payload,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SyncQueueTableOrderingComposer
    extends Composer<_$AppDatabase, $SyncQueueTable> {
  $$SyncQueueTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncTableName => $composableBuilder(
    column: $table.syncTableName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get recordId => $composableBuilder(
    column: $table.recordId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operation => $composableBuilder(
    column: $table.operation,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get payload => $composableBuilder(
    column: $table.payload,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isSynced => $composableBuilder(
    column: $table.isSynced,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SyncQueueTableAnnotationComposer
    extends Composer<_$AppDatabase, $SyncQueueTable> {
  $$SyncQueueTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get syncTableName => $composableBuilder(
    column: $table.syncTableName,
    builder: (column) => column,
  );

  GeneratedColumn<String> get recordId =>
      $composableBuilder(column: $table.recordId, builder: (column) => column);

  GeneratedColumn<String> get operation =>
      $composableBuilder(column: $table.operation, builder: (column) => column);

  GeneratedColumn<String> get payload =>
      $composableBuilder(column: $table.payload, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isSynced =>
      $composableBuilder(column: $table.isSynced, builder: (column) => column);
}

class $$SyncQueueTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SyncQueueTable,
          SyncQueueData,
          $$SyncQueueTableFilterComposer,
          $$SyncQueueTableOrderingComposer,
          $$SyncQueueTableAnnotationComposer,
          $$SyncQueueTableCreateCompanionBuilder,
          $$SyncQueueTableUpdateCompanionBuilder,
          (
            SyncQueueData,
            BaseReferences<_$AppDatabase, $SyncQueueTable, SyncQueueData>,
          ),
          SyncQueueData,
          PrefetchHooks Function()
        > {
  $$SyncQueueTableTableManager(_$AppDatabase db, $SyncQueueTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SyncQueueTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SyncQueueTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SyncQueueTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> syncTableName = const Value.absent(),
                Value<String> recordId = const Value.absent(),
                Value<String> operation = const Value.absent(),
                Value<String> payload = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
                Value<int> retryCount = const Value.absent(),
                Value<bool> isSynced = const Value.absent(),
              }) => SyncQueueCompanion(
                id: id,
                syncTableName: syncTableName,
                recordId: recordId,
                operation: operation,
                payload: payload,
                timestamp: timestamp,
                retryCount: retryCount,
                isSynced: isSynced,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String syncTableName,
                required String recordId,
                required String operation,
                required String payload,
                Value<DateTime> timestamp = const Value.absent(),
                Value<int> retryCount = const Value.absent(),
                Value<bool> isSynced = const Value.absent(),
              }) => SyncQueueCompanion.insert(
                id: id,
                syncTableName: syncTableName,
                recordId: recordId,
                operation: operation,
                payload: payload,
                timestamp: timestamp,
                retryCount: retryCount,
                isSynced: isSynced,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SyncQueueTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SyncQueueTable,
      SyncQueueData,
      $$SyncQueueTableFilterComposer,
      $$SyncQueueTableOrderingComposer,
      $$SyncQueueTableAnnotationComposer,
      $$SyncQueueTableCreateCompanionBuilder,
      $$SyncQueueTableUpdateCompanionBuilder,
      (
        SyncQueueData,
        BaseReferences<_$AppDatabase, $SyncQueueTable, SyncQueueData>,
      ),
      SyncQueueData,
      PrefetchHooks Function()
    >;
typedef $$RecurringExpensesTableCreateCompanionBuilder =
    RecurringExpensesCompanion Function({
      required String id,
      required String userId,
      required String title,
      required int amount,
      required String frequency,
      Value<int?> dayOfMonth,
      Value<int?> dayOfWeek,
      Value<String?> category,
      Value<String> paymentMethod,
      required DateTime nextDueDate,
      Value<bool> isActive,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$RecurringExpensesTableUpdateCompanionBuilder =
    RecurringExpensesCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String> title,
      Value<int> amount,
      Value<String> frequency,
      Value<int?> dayOfMonth,
      Value<int?> dayOfWeek,
      Value<String?> category,
      Value<String> paymentMethod,
      Value<DateTime> nextDueDate,
      Value<bool> isActive,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$RecurringExpensesTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $RecurringExpensesTable,
          RecurringExpense
        > {
  $$RecurringExpensesTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.recurringExpenses.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<
    $RecurringExpenseLocationsTable,
    List<RecurringExpenseLocation>
  >
  _recurringExpenseLocationsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.recurringExpenseLocations,
        aliasName: $_aliasNameGenerator(
          db.recurringExpenses.id,
          db.recurringExpenseLocations.recurringExpenseId,
        ),
      );

  $$RecurringExpenseLocationsTableProcessedTableManager
  get recurringExpenseLocationsRefs {
    final manager =
        $$RecurringExpenseLocationsTableTableManager(
          $_db,
          $_db.recurringExpenseLocations,
        ).filter(
          (f) => f.recurringExpenseId.id.sqlEquals($_itemColumn<String>('id')!),
        );

    final cache = $_typedResult.readTableOrNull(
      _recurringExpenseLocationsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$RecurringExpensesTableFilterComposer
    extends Composer<_$AppDatabase, $RecurringExpensesTable> {
  $$RecurringExpensesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get frequency => $composableBuilder(
    column: $table.frequency,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dayOfMonth => $composableBuilder(
    column: $table.dayOfMonth,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get dayOfWeek => $composableBuilder(
    column: $table.dayOfWeek,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get paymentMethod => $composableBuilder(
    column: $table.paymentMethod,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get nextDueDate => $composableBuilder(
    column: $table.nextDueDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> recurringExpenseLocationsRefs(
    Expression<bool> Function($$RecurringExpenseLocationsTableFilterComposer f)
    f,
  ) {
    final $$RecurringExpenseLocationsTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.recurringExpenseLocations,
          getReferencedColumn: (t) => t.recurringExpenseId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$RecurringExpenseLocationsTableFilterComposer(
                $db: $db,
                $table: $db.recurringExpenseLocations,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$RecurringExpensesTableOrderingComposer
    extends Composer<_$AppDatabase, $RecurringExpensesTable> {
  $$RecurringExpensesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get frequency => $composableBuilder(
    column: $table.frequency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dayOfMonth => $composableBuilder(
    column: $table.dayOfMonth,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get dayOfWeek => $composableBuilder(
    column: $table.dayOfWeek,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get paymentMethod => $composableBuilder(
    column: $table.paymentMethod,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get nextDueDate => $composableBuilder(
    column: $table.nextDueDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$RecurringExpensesTableAnnotationComposer
    extends Composer<_$AppDatabase, $RecurringExpensesTable> {
  $$RecurringExpensesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<int> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<String> get frequency =>
      $composableBuilder(column: $table.frequency, builder: (column) => column);

  GeneratedColumn<int> get dayOfMonth => $composableBuilder(
    column: $table.dayOfMonth,
    builder: (column) => column,
  );

  GeneratedColumn<int> get dayOfWeek =>
      $composableBuilder(column: $table.dayOfWeek, builder: (column) => column);

  GeneratedColumn<String> get category =>
      $composableBuilder(column: $table.category, builder: (column) => column);

  GeneratedColumn<String> get paymentMethod => $composableBuilder(
    column: $table.paymentMethod,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get nextDueDate => $composableBuilder(
    column: $table.nextDueDate,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => column,
  );

  GeneratedColumn<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> recurringExpenseLocationsRefs<T extends Object>(
    Expression<T> Function($$RecurringExpenseLocationsTableAnnotationComposer a)
    f,
  ) {
    final $$RecurringExpenseLocationsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.recurringExpenseLocations,
          getReferencedColumn: (t) => t.recurringExpenseId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$RecurringExpenseLocationsTableAnnotationComposer(
                $db: $db,
                $table: $db.recurringExpenseLocations,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$RecurringExpensesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RecurringExpensesTable,
          RecurringExpense,
          $$RecurringExpensesTableFilterComposer,
          $$RecurringExpensesTableOrderingComposer,
          $$RecurringExpensesTableAnnotationComposer,
          $$RecurringExpensesTableCreateCompanionBuilder,
          $$RecurringExpensesTableUpdateCompanionBuilder,
          (RecurringExpense, $$RecurringExpensesTableReferences),
          RecurringExpense,
          PrefetchHooks Function({
            bool userId,
            bool recurringExpenseLocationsRefs,
          })
        > {
  $$RecurringExpensesTableTableManager(
    _$AppDatabase db,
    $RecurringExpensesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RecurringExpensesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$RecurringExpensesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$RecurringExpensesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<int> amount = const Value.absent(),
                Value<String> frequency = const Value.absent(),
                Value<int?> dayOfMonth = const Value.absent(),
                Value<int?> dayOfWeek = const Value.absent(),
                Value<String?> category = const Value.absent(),
                Value<String> paymentMethod = const Value.absent(),
                Value<DateTime> nextDueDate = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RecurringExpensesCompanion(
                id: id,
                userId: userId,
                title: title,
                amount: amount,
                frequency: frequency,
                dayOfMonth: dayOfMonth,
                dayOfWeek: dayOfWeek,
                category: category,
                paymentMethod: paymentMethod,
                nextDueDate: nextDueDate,
                isActive: isActive,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required String title,
                required int amount,
                required String frequency,
                Value<int?> dayOfMonth = const Value.absent(),
                Value<int?> dayOfWeek = const Value.absent(),
                Value<String?> category = const Value.absent(),
                Value<String> paymentMethod = const Value.absent(),
                required DateTime nextDueDate,
                Value<bool> isActive = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RecurringExpensesCompanion.insert(
                id: id,
                userId: userId,
                title: title,
                amount: amount,
                frequency: frequency,
                dayOfMonth: dayOfMonth,
                dayOfWeek: dayOfWeek,
                category: category,
                paymentMethod: paymentMethod,
                nextDueDate: nextDueDate,
                isActive: isActive,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$RecurringExpensesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({userId = false, recurringExpenseLocationsRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (recurringExpenseLocationsRefs)
                      db.recurringExpenseLocations,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (userId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.userId,
                                    referencedTable:
                                        $$RecurringExpensesTableReferences
                                            ._userIdTable(db),
                                    referencedColumn:
                                        $$RecurringExpensesTableReferences
                                            ._userIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (recurringExpenseLocationsRefs)
                        await $_getPrefetchedData<
                          RecurringExpense,
                          $RecurringExpensesTable,
                          RecurringExpenseLocation
                        >(
                          currentTable: table,
                          referencedTable: $$RecurringExpensesTableReferences
                              ._recurringExpenseLocationsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$RecurringExpensesTableReferences(
                                db,
                                table,
                                p0,
                              ).recurringExpenseLocationsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.recurringExpenseId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$RecurringExpensesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RecurringExpensesTable,
      RecurringExpense,
      $$RecurringExpensesTableFilterComposer,
      $$RecurringExpensesTableOrderingComposer,
      $$RecurringExpensesTableAnnotationComposer,
      $$RecurringExpensesTableCreateCompanionBuilder,
      $$RecurringExpensesTableUpdateCompanionBuilder,
      (RecurringExpense, $$RecurringExpensesTableReferences),
      RecurringExpense,
      PrefetchHooks Function({bool userId, bool recurringExpenseLocationsRefs})
    >;
typedef $$SubscriptionsTableCreateCompanionBuilder =
    SubscriptionsCompanion Function({
      required String id,
      required String userId,
      Value<String?> stripeCustomerId,
      required String priceId,
      required String status,
      required String tier,
      Value<DateTime?> currentPeriodStart,
      Value<DateTime?> currentPeriodEnd,
      Value<Map<String, dynamic>?> metadata,
      Value<bool> cancelAtPeriodEnd,
      Value<DateTime> createdAt,
      Value<String?> lastModifiedByDeviceId,
      Value<int> rowid,
    });
typedef $$SubscriptionsTableUpdateCompanionBuilder =
    SubscriptionsCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String?> stripeCustomerId,
      Value<String> priceId,
      Value<String> status,
      Value<String> tier,
      Value<DateTime?> currentPeriodStart,
      Value<DateTime?> currentPeriodEnd,
      Value<Map<String, dynamic>?> metadata,
      Value<bool> cancelAtPeriodEnd,
      Value<DateTime> createdAt,
      Value<String?> lastModifiedByDeviceId,
      Value<int> rowid,
    });

final class $$SubscriptionsTableReferences
    extends BaseReferences<_$AppDatabase, $SubscriptionsTable, Subscription> {
  $$SubscriptionsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.subscriptions.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$SubscriptionsTableFilterComposer
    extends Composer<_$AppDatabase, $SubscriptionsTable> {
  $$SubscriptionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get stripeCustomerId => $composableBuilder(
    column: $table.stripeCustomerId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get priceId => $composableBuilder(
    column: $table.priceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tier => $composableBuilder(
    column: $table.tier,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get currentPeriodStart => $composableBuilder(
    column: $table.currentPeriodStart,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get currentPeriodEnd => $composableBuilder(
    column: $table.currentPeriodEnd,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<bool> get cancelAtPeriodEnd => $composableBuilder(
    column: $table.cancelAtPeriodEnd,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SubscriptionsTableOrderingComposer
    extends Composer<_$AppDatabase, $SubscriptionsTable> {
  $$SubscriptionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get stripeCustomerId => $composableBuilder(
    column: $table.stripeCustomerId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get priceId => $composableBuilder(
    column: $table.priceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tier => $composableBuilder(
    column: $table.tier,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get currentPeriodStart => $composableBuilder(
    column: $table.currentPeriodStart,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get currentPeriodEnd => $composableBuilder(
    column: $table.currentPeriodEnd,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get cancelAtPeriodEnd => $composableBuilder(
    column: $table.cancelAtPeriodEnd,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SubscriptionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SubscriptionsTable> {
  $$SubscriptionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get stripeCustomerId => $composableBuilder(
    column: $table.stripeCustomerId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get priceId =>
      $composableBuilder(column: $table.priceId, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get tier =>
      $composableBuilder(column: $table.tier, builder: (column) => column);

  GeneratedColumn<DateTime> get currentPeriodStart => $composableBuilder(
    column: $table.currentPeriodStart,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get currentPeriodEnd => $composableBuilder(
    column: $table.currentPeriodEnd,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<bool> get cancelAtPeriodEnd => $composableBuilder(
    column: $table.cancelAtPeriodEnd,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SubscriptionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SubscriptionsTable,
          Subscription,
          $$SubscriptionsTableFilterComposer,
          $$SubscriptionsTableOrderingComposer,
          $$SubscriptionsTableAnnotationComposer,
          $$SubscriptionsTableCreateCompanionBuilder,
          $$SubscriptionsTableUpdateCompanionBuilder,
          (Subscription, $$SubscriptionsTableReferences),
          Subscription,
          PrefetchHooks Function({bool userId})
        > {
  $$SubscriptionsTableTableManager(_$AppDatabase db, $SubscriptionsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SubscriptionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SubscriptionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SubscriptionsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String?> stripeCustomerId = const Value.absent(),
                Value<String> priceId = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String> tier = const Value.absent(),
                Value<DateTime?> currentPeriodStart = const Value.absent(),
                Value<DateTime?> currentPeriodEnd = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<bool> cancelAtPeriodEnd = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SubscriptionsCompanion(
                id: id,
                userId: userId,
                stripeCustomerId: stripeCustomerId,
                priceId: priceId,
                status: status,
                tier: tier,
                currentPeriodStart: currentPeriodStart,
                currentPeriodEnd: currentPeriodEnd,
                metadata: metadata,
                cancelAtPeriodEnd: cancelAtPeriodEnd,
                createdAt: createdAt,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                Value<String?> stripeCustomerId = const Value.absent(),
                required String priceId,
                required String status,
                required String tier,
                Value<DateTime?> currentPeriodStart = const Value.absent(),
                Value<DateTime?> currentPeriodEnd = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<bool> cancelAtPeriodEnd = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SubscriptionsCompanion.insert(
                id: id,
                userId: userId,
                stripeCustomerId: stripeCustomerId,
                priceId: priceId,
                status: status,
                tier: tier,
                currentPeriodStart: currentPeriodStart,
                currentPeriodEnd: currentPeriodEnd,
                metadata: metadata,
                cancelAtPeriodEnd: cancelAtPeriodEnd,
                createdAt: createdAt,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SubscriptionsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable: $$SubscriptionsTableReferences
                                    ._userIdTable(db),
                                referencedColumn: $$SubscriptionsTableReferences
                                    ._userIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$SubscriptionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SubscriptionsTable,
      Subscription,
      $$SubscriptionsTableFilterComposer,
      $$SubscriptionsTableOrderingComposer,
      $$SubscriptionsTableAnnotationComposer,
      $$SubscriptionsTableCreateCompanionBuilder,
      $$SubscriptionsTableUpdateCompanionBuilder,
      (Subscription, $$SubscriptionsTableReferences),
      Subscription,
      PrefetchHooks Function({bool userId})
    >;
typedef $$SavingsGoalsTableCreateCompanionBuilder =
    SavingsGoalsCompanion Function({
      required String id,
      required String userId,
      Value<String?> linkedAccountId,
      required String title,
      Value<int> currentAmount,
      required int targetAmount,
      Value<String> currency,
      Value<String?> iconName,
      Value<String?> colorHex,
      Value<DateTime?> deadline,
      Value<bool> isArchived,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<bool> isDeleted,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$SavingsGoalsTableUpdateCompanionBuilder =
    SavingsGoalsCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String?> linkedAccountId,
      Value<String> title,
      Value<int> currentAmount,
      Value<int> targetAmount,
      Value<String> currency,
      Value<String?> iconName,
      Value<String?> colorHex,
      Value<DateTime?> deadline,
      Value<bool> isArchived,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<bool> isDeleted,
      Value<String> syncState,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$SavingsGoalsTableReferences
    extends BaseReferences<_$AppDatabase, $SavingsGoalsTable, SavingsGoal> {
  $$SavingsGoalsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.savingsGoals.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $AccountsTable _linkedAccountIdTable(_$AppDatabase db) =>
      db.accounts.createAlias(
        $_aliasNameGenerator(db.savingsGoals.linkedAccountId, db.accounts.id),
      );

  $$AccountsTableProcessedTableManager? get linkedAccountId {
    final $_column = $_itemColumn<String>('linked_account_id');
    if ($_column == null) return null;
    final manager = $$AccountsTableTableManager(
      $_db,
      $_db.accounts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_linkedAccountIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$SavingsGoalsTableFilterComposer
    extends Composer<_$AppDatabase, $SavingsGoalsTable> {
  $$SavingsGoalsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get currentAmount => $composableBuilder(
    column: $table.currentAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get targetAmount => $composableBuilder(
    column: $table.targetAmount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get iconName => $composableBuilder(
    column: $table.iconName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get deadline => $composableBuilder(
    column: $table.deadline,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AccountsTableFilterComposer get linkedAccountId {
    final $$AccountsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.linkedAccountId,
      referencedTable: $db.accounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AccountsTableFilterComposer(
            $db: $db,
            $table: $db.accounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SavingsGoalsTableOrderingComposer
    extends Composer<_$AppDatabase, $SavingsGoalsTable> {
  $$SavingsGoalsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get currentAmount => $composableBuilder(
    column: $table.currentAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get targetAmount => $composableBuilder(
    column: $table.targetAmount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get iconName => $composableBuilder(
    column: $table.iconName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get colorHex => $composableBuilder(
    column: $table.colorHex,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get deadline => $composableBuilder(
    column: $table.deadline,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AccountsTableOrderingComposer get linkedAccountId {
    final $$AccountsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.linkedAccountId,
      referencedTable: $db.accounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AccountsTableOrderingComposer(
            $db: $db,
            $table: $db.accounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SavingsGoalsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SavingsGoalsTable> {
  $$SavingsGoalsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<int> get currentAmount => $composableBuilder(
    column: $table.currentAmount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get targetAmount => $composableBuilder(
    column: $table.targetAmount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get currency =>
      $composableBuilder(column: $table.currency, builder: (column) => column);

  GeneratedColumn<String> get iconName =>
      $composableBuilder(column: $table.iconName, builder: (column) => column);

  GeneratedColumn<String> get colorHex =>
      $composableBuilder(column: $table.colorHex, builder: (column) => column);

  GeneratedColumn<DateTime> get deadline =>
      $composableBuilder(column: $table.deadline, builder: (column) => column);

  GeneratedColumn<bool> get isArchived => $composableBuilder(
    column: $table.isArchived,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => column,
  );

  GeneratedColumn<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$AccountsTableAnnotationComposer get linkedAccountId {
    final $$AccountsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.linkedAccountId,
      referencedTable: $db.accounts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$AccountsTableAnnotationComposer(
            $db: $db,
            $table: $db.accounts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SavingsGoalsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SavingsGoalsTable,
          SavingsGoal,
          $$SavingsGoalsTableFilterComposer,
          $$SavingsGoalsTableOrderingComposer,
          $$SavingsGoalsTableAnnotationComposer,
          $$SavingsGoalsTableCreateCompanionBuilder,
          $$SavingsGoalsTableUpdateCompanionBuilder,
          (SavingsGoal, $$SavingsGoalsTableReferences),
          SavingsGoal,
          PrefetchHooks Function({bool userId, bool linkedAccountId})
        > {
  $$SavingsGoalsTableTableManager(_$AppDatabase db, $SavingsGoalsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SavingsGoalsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SavingsGoalsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SavingsGoalsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String?> linkedAccountId = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<int> currentAmount = const Value.absent(),
                Value<int> targetAmount = const Value.absent(),
                Value<String> currency = const Value.absent(),
                Value<String?> iconName = const Value.absent(),
                Value<String?> colorHex = const Value.absent(),
                Value<DateTime?> deadline = const Value.absent(),
                Value<bool> isArchived = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SavingsGoalsCompanion(
                id: id,
                userId: userId,
                linkedAccountId: linkedAccountId,
                title: title,
                currentAmount: currentAmount,
                targetAmount: targetAmount,
                currency: currency,
                iconName: iconName,
                colorHex: colorHex,
                deadline: deadline,
                isArchived: isArchived,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                isDeleted: isDeleted,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                Value<String?> linkedAccountId = const Value.absent(),
                required String title,
                Value<int> currentAmount = const Value.absent(),
                required int targetAmount,
                Value<String> currency = const Value.absent(),
                Value<String?> iconName = const Value.absent(),
                Value<String?> colorHex = const Value.absent(),
                Value<DateTime?> deadline = const Value.absent(),
                Value<bool> isArchived = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SavingsGoalsCompanion.insert(
                id: id,
                userId: userId,
                linkedAccountId: linkedAccountId,
                title: title,
                currentAmount: currentAmount,
                targetAmount: targetAmount,
                currency: currency,
                iconName: iconName,
                colorHex: colorHex,
                deadline: deadline,
                isArchived: isArchived,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                isDeleted: isDeleted,
                syncState: syncState,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SavingsGoalsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({userId = false, linkedAccountId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable: $$SavingsGoalsTableReferences
                                    ._userIdTable(db),
                                referencedColumn: $$SavingsGoalsTableReferences
                                    ._userIdTable(db)
                                    .id,
                              )
                              as T;
                    }
                    if (linkedAccountId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.linkedAccountId,
                                referencedTable: $$SavingsGoalsTableReferences
                                    ._linkedAccountIdTable(db),
                                referencedColumn: $$SavingsGoalsTableReferences
                                    ._linkedAccountIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$SavingsGoalsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SavingsGoalsTable,
      SavingsGoal,
      $$SavingsGoalsTableFilterComposer,
      $$SavingsGoalsTableOrderingComposer,
      $$SavingsGoalsTableAnnotationComposer,
      $$SavingsGoalsTableCreateCompanionBuilder,
      $$SavingsGoalsTableUpdateCompanionBuilder,
      (SavingsGoal, $$SavingsGoalsTableReferences),
      SavingsGoal,
      PrefetchHooks Function({bool userId, bool linkedAccountId})
    >;
typedef $$LocationsTableCreateCompanionBuilder =
    LocationsCompanion Function({
      required String id,
      required String userId,
      required double latitude,
      required double longitude,
      Value<double?> accuracy,
      Value<double?> altitude,
      Value<double?> speed,
      Value<double?> heading,
      required DateTime timestamp,
      Value<String?> context,
      Value<String> source,
      Value<Map<String, dynamic>> deviceInfo,
      Value<DateTime> createdAt,
      Value<int> revision,
      Value<bool> isDeleted,
      Value<int> rowid,
    });
typedef $$LocationsTableUpdateCompanionBuilder =
    LocationsCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<double> latitude,
      Value<double> longitude,
      Value<double?> accuracy,
      Value<double?> altitude,
      Value<double?> speed,
      Value<double?> heading,
      Value<DateTime> timestamp,
      Value<String?> context,
      Value<String> source,
      Value<Map<String, dynamic>> deviceInfo,
      Value<DateTime> createdAt,
      Value<int> revision,
      Value<bool> isDeleted,
      Value<int> rowid,
    });

final class $$LocationsTableReferences
    extends BaseReferences<_$AppDatabase, $LocationsTable, Location> {
  $$LocationsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.locations.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$ExpenseLocationsTable, List<ExpenseLocation>>
  _expenseLocationsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.expenseLocations,
    aliasName: $_aliasNameGenerator(
      db.locations.id,
      db.expenseLocations.locationId,
    ),
  );

  $$ExpenseLocationsTableProcessedTableManager get expenseLocationsRefs {
    final manager = $$ExpenseLocationsTableTableManager(
      $_db,
      $_db.expenseLocations,
    ).filter((f) => f.locationId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _expenseLocationsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<
    $RecurringExpenseLocationsTable,
    List<RecurringExpenseLocation>
  >
  _recurringExpenseLocationsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.recurringExpenseLocations,
        aliasName: $_aliasNameGenerator(
          db.locations.id,
          db.recurringExpenseLocations.locationId,
        ),
      );

  $$RecurringExpenseLocationsTableProcessedTableManager
  get recurringExpenseLocationsRefs {
    final manager = $$RecurringExpenseLocationsTableTableManager(
      $_db,
      $_db.recurringExpenseLocations,
    ).filter((f) => f.locationId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _recurringExpenseLocationsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }

  static MultiTypedResultKey<$LocationAnalyticsTable, List<LocationAnalytic>>
  _locationAnalyticsRefsTable(_$AppDatabase db) =>
      MultiTypedResultKey.fromTable(
        db.locationAnalytics,
        aliasName: $_aliasNameGenerator(
          db.locations.id,
          db.locationAnalytics.locationId,
        ),
      );

  $$LocationAnalyticsTableProcessedTableManager get locationAnalyticsRefs {
    final manager = $$LocationAnalyticsTableTableManager(
      $_db,
      $_db.locationAnalytics,
    ).filter((f) => f.locationId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(
      _locationAnalyticsRefsTable($_db),
    );
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$LocationsTableFilterComposer
    extends Composer<_$AppDatabase, $LocationsTable> {
  $$LocationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get accuracy => $composableBuilder(
    column: $table.accuracy,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get altitude => $composableBuilder(
    column: $table.altitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get speed => $composableBuilder(
    column: $table.speed,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get heading => $composableBuilder(
    column: $table.heading,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get context => $composableBuilder(
    column: $table.context,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>,
    Map<String, dynamic>,
    String
  >
  get deviceInfo => $composableBuilder(
    column: $table.deviceInfo,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> expenseLocationsRefs(
    Expression<bool> Function($$ExpenseLocationsTableFilterComposer f) f,
  ) {
    final $$ExpenseLocationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenseLocations,
      getReferencedColumn: (t) => t.locationId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpenseLocationsTableFilterComposer(
            $db: $db,
            $table: $db.expenseLocations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<bool> recurringExpenseLocationsRefs(
    Expression<bool> Function($$RecurringExpenseLocationsTableFilterComposer f)
    f,
  ) {
    final $$RecurringExpenseLocationsTableFilterComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.recurringExpenseLocations,
          getReferencedColumn: (t) => t.locationId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$RecurringExpenseLocationsTableFilterComposer(
                $db: $db,
                $table: $db.recurringExpenseLocations,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<bool> locationAnalyticsRefs(
    Expression<bool> Function($$LocationAnalyticsTableFilterComposer f) f,
  ) {
    final $$LocationAnalyticsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.locationAnalytics,
      getReferencedColumn: (t) => t.locationId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LocationAnalyticsTableFilterComposer(
            $db: $db,
            $table: $db.locationAnalytics,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$LocationsTableOrderingComposer
    extends Composer<_$AppDatabase, $LocationsTable> {
  $$LocationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get accuracy => $composableBuilder(
    column: $table.accuracy,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get altitude => $composableBuilder(
    column: $table.altitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get speed => $composableBuilder(
    column: $table.speed,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get heading => $composableBuilder(
    column: $table.heading,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get context => $composableBuilder(
    column: $table.context,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get deviceInfo => $composableBuilder(
    column: $table.deviceInfo,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LocationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $LocationsTable> {
  $$LocationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<double> get accuracy =>
      $composableBuilder(column: $table.accuracy, builder: (column) => column);

  GeneratedColumn<double> get altitude =>
      $composableBuilder(column: $table.altitude, builder: (column) => column);

  GeneratedColumn<double> get speed =>
      $composableBuilder(column: $table.speed, builder: (column) => column);

  GeneratedColumn<double> get heading =>
      $composableBuilder(column: $table.heading, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<String> get context =>
      $composableBuilder(column: $table.context, builder: (column) => column);

  GeneratedColumn<String> get source =>
      $composableBuilder(column: $table.source, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>, String>
  get deviceInfo => $composableBuilder(
    column: $table.deviceInfo,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> expenseLocationsRefs<T extends Object>(
    Expression<T> Function($$ExpenseLocationsTableAnnotationComposer a) f,
  ) {
    final $$ExpenseLocationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.expenseLocations,
      getReferencedColumn: (t) => t.locationId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpenseLocationsTableAnnotationComposer(
            $db: $db,
            $table: $db.expenseLocations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }

  Expression<T> recurringExpenseLocationsRefs<T extends Object>(
    Expression<T> Function($$RecurringExpenseLocationsTableAnnotationComposer a)
    f,
  ) {
    final $$RecurringExpenseLocationsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.recurringExpenseLocations,
          getReferencedColumn: (t) => t.locationId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$RecurringExpenseLocationsTableAnnotationComposer(
                $db: $db,
                $table: $db.recurringExpenseLocations,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }

  Expression<T> locationAnalyticsRefs<T extends Object>(
    Expression<T> Function($$LocationAnalyticsTableAnnotationComposer a) f,
  ) {
    final $$LocationAnalyticsTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.id,
          referencedTable: $db.locationAnalytics,
          getReferencedColumn: (t) => t.locationId,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$LocationAnalyticsTableAnnotationComposer(
                $db: $db,
                $table: $db.locationAnalytics,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return f(composer);
  }
}

class $$LocationsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $LocationsTable,
          Location,
          $$LocationsTableFilterComposer,
          $$LocationsTableOrderingComposer,
          $$LocationsTableAnnotationComposer,
          $$LocationsTableCreateCompanionBuilder,
          $$LocationsTableUpdateCompanionBuilder,
          (Location, $$LocationsTableReferences),
          Location,
          PrefetchHooks Function({
            bool userId,
            bool expenseLocationsRefs,
            bool recurringExpenseLocationsRefs,
            bool locationAnalyticsRefs,
          })
        > {
  $$LocationsTableTableManager(_$AppDatabase db, $LocationsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LocationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LocationsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LocationsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<double> latitude = const Value.absent(),
                Value<double> longitude = const Value.absent(),
                Value<double?> accuracy = const Value.absent(),
                Value<double?> altitude = const Value.absent(),
                Value<double?> speed = const Value.absent(),
                Value<double?> heading = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
                Value<String?> context = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<Map<String, dynamic>> deviceInfo = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LocationsCompanion(
                id: id,
                userId: userId,
                latitude: latitude,
                longitude: longitude,
                accuracy: accuracy,
                altitude: altitude,
                speed: speed,
                heading: heading,
                timestamp: timestamp,
                context: context,
                source: source,
                deviceInfo: deviceInfo,
                createdAt: createdAt,
                revision: revision,
                isDeleted: isDeleted,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required double latitude,
                required double longitude,
                Value<double?> accuracy = const Value.absent(),
                Value<double?> altitude = const Value.absent(),
                Value<double?> speed = const Value.absent(),
                Value<double?> heading = const Value.absent(),
                required DateTime timestamp,
                Value<String?> context = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<Map<String, dynamic>> deviceInfo = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LocationsCompanion.insert(
                id: id,
                userId: userId,
                latitude: latitude,
                longitude: longitude,
                accuracy: accuracy,
                altitude: altitude,
                speed: speed,
                heading: heading,
                timestamp: timestamp,
                context: context,
                source: source,
                deviceInfo: deviceInfo,
                createdAt: createdAt,
                revision: revision,
                isDeleted: isDeleted,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$LocationsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({
                userId = false,
                expenseLocationsRefs = false,
                recurringExpenseLocationsRefs = false,
                locationAnalyticsRefs = false,
              }) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (expenseLocationsRefs) db.expenseLocations,
                    if (recurringExpenseLocationsRefs)
                      db.recurringExpenseLocations,
                    if (locationAnalyticsRefs) db.locationAnalytics,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (userId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.userId,
                                    referencedTable: $$LocationsTableReferences
                                        ._userIdTable(db),
                                    referencedColumn: $$LocationsTableReferences
                                        ._userIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (expenseLocationsRefs)
                        await $_getPrefetchedData<
                          Location,
                          $LocationsTable,
                          ExpenseLocation
                        >(
                          currentTable: table,
                          referencedTable: $$LocationsTableReferences
                              ._expenseLocationsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$LocationsTableReferences(
                                db,
                                table,
                                p0,
                              ).expenseLocationsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.locationId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (recurringExpenseLocationsRefs)
                        await $_getPrefetchedData<
                          Location,
                          $LocationsTable,
                          RecurringExpenseLocation
                        >(
                          currentTable: table,
                          referencedTable: $$LocationsTableReferences
                              ._recurringExpenseLocationsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$LocationsTableReferences(
                                db,
                                table,
                                p0,
                              ).recurringExpenseLocationsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.locationId == item.id,
                              ),
                          typedResults: items,
                        ),
                      if (locationAnalyticsRefs)
                        await $_getPrefetchedData<
                          Location,
                          $LocationsTable,
                          LocationAnalytic
                        >(
                          currentTable: table,
                          referencedTable: $$LocationsTableReferences
                              ._locationAnalyticsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$LocationsTableReferences(
                                db,
                                table,
                                p0,
                              ).locationAnalyticsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.locationId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$LocationsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $LocationsTable,
      Location,
      $$LocationsTableFilterComposer,
      $$LocationsTableOrderingComposer,
      $$LocationsTableAnnotationComposer,
      $$LocationsTableCreateCompanionBuilder,
      $$LocationsTableUpdateCompanionBuilder,
      (Location, $$LocationsTableReferences),
      Location,
      PrefetchHooks Function({
        bool userId,
        bool expenseLocationsRefs,
        bool recurringExpenseLocationsRefs,
        bool locationAnalyticsRefs,
      })
    >;
typedef $$GeocodingCacheTableCreateCompanionBuilder =
    GeocodingCacheCompanion Function({
      required double latitude,
      required double longitude,
      required String format,
      Value<String> languageCode,
      required String address,
      Value<String?> fullAddress,
      required DateTime expiresAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$GeocodingCacheTableUpdateCompanionBuilder =
    GeocodingCacheCompanion Function({
      Value<double> latitude,
      Value<double> longitude,
      Value<String> format,
      Value<String> languageCode,
      Value<String> address,
      Value<String?> fullAddress,
      Value<DateTime> expiresAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

class $$GeocodingCacheTableFilterComposer
    extends Composer<_$AppDatabase, $GeocodingCacheTable> {
  $$GeocodingCacheTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get format => $composableBuilder(
    column: $table.format,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get languageCode => $composableBuilder(
    column: $table.languageCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fullAddress => $composableBuilder(
    column: $table.fullAddress,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$GeocodingCacheTableOrderingComposer
    extends Composer<_$AppDatabase, $GeocodingCacheTable> {
  $$GeocodingCacheTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get format => $composableBuilder(
    column: $table.format,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get languageCode => $composableBuilder(
    column: $table.languageCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get address => $composableBuilder(
    column: $table.address,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fullAddress => $composableBuilder(
    column: $table.fullAddress,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$GeocodingCacheTableAnnotationComposer
    extends Composer<_$AppDatabase, $GeocodingCacheTable> {
  $$GeocodingCacheTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<String> get format =>
      $composableBuilder(column: $table.format, builder: (column) => column);

  GeneratedColumn<String> get languageCode => $composableBuilder(
    column: $table.languageCode,
    builder: (column) => column,
  );

  GeneratedColumn<String> get address =>
      $composableBuilder(column: $table.address, builder: (column) => column);

  GeneratedColumn<String> get fullAddress => $composableBuilder(
    column: $table.fullAddress,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);
}

class $$GeocodingCacheTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $GeocodingCacheTable,
          GeocodingCacheData,
          $$GeocodingCacheTableFilterComposer,
          $$GeocodingCacheTableOrderingComposer,
          $$GeocodingCacheTableAnnotationComposer,
          $$GeocodingCacheTableCreateCompanionBuilder,
          $$GeocodingCacheTableUpdateCompanionBuilder,
          (
            GeocodingCacheData,
            BaseReferences<
              _$AppDatabase,
              $GeocodingCacheTable,
              GeocodingCacheData
            >,
          ),
          GeocodingCacheData,
          PrefetchHooks Function()
        > {
  $$GeocodingCacheTableTableManager(
    _$AppDatabase db,
    $GeocodingCacheTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GeocodingCacheTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GeocodingCacheTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GeocodingCacheTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<double> latitude = const Value.absent(),
                Value<double> longitude = const Value.absent(),
                Value<String> format = const Value.absent(),
                Value<String> languageCode = const Value.absent(),
                Value<String> address = const Value.absent(),
                Value<String?> fullAddress = const Value.absent(),
                Value<DateTime> expiresAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => GeocodingCacheCompanion(
                latitude: latitude,
                longitude: longitude,
                format: format,
                languageCode: languageCode,
                address: address,
                fullAddress: fullAddress,
                expiresAt: expiresAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required double latitude,
                required double longitude,
                required String format,
                Value<String> languageCode = const Value.absent(),
                required String address,
                Value<String?> fullAddress = const Value.absent(),
                required DateTime expiresAt,
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => GeocodingCacheCompanion.insert(
                latitude: latitude,
                longitude: longitude,
                format: format,
                languageCode: languageCode,
                address: address,
                fullAddress: fullAddress,
                expiresAt: expiresAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$GeocodingCacheTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $GeocodingCacheTable,
      GeocodingCacheData,
      $$GeocodingCacheTableFilterComposer,
      $$GeocodingCacheTableOrderingComposer,
      $$GeocodingCacheTableAnnotationComposer,
      $$GeocodingCacheTableCreateCompanionBuilder,
      $$GeocodingCacheTableUpdateCompanionBuilder,
      (
        GeocodingCacheData,
        BaseReferences<_$AppDatabase, $GeocodingCacheTable, GeocodingCacheData>,
      ),
      GeocodingCacheData,
      PrefetchHooks Function()
    >;
typedef $$ExpenseLocationsTableCreateCompanionBuilder =
    ExpenseLocationsCompanion Function({
      required String expenseId,
      required String locationId,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$ExpenseLocationsTableUpdateCompanionBuilder =
    ExpenseLocationsCompanion Function({
      Value<String> expenseId,
      Value<String> locationId,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$ExpenseLocationsTableReferences
    extends
        BaseReferences<_$AppDatabase, $ExpenseLocationsTable, ExpenseLocation> {
  $$ExpenseLocationsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ExpensesTable _expenseIdTable(_$AppDatabase db) =>
      db.expenses.createAlias(
        $_aliasNameGenerator(db.expenseLocations.expenseId, db.expenses.id),
      );

  $$ExpensesTableProcessedTableManager get expenseId {
    final $_column = $_itemColumn<String>('expense_id')!;

    final manager = $$ExpensesTableTableManager(
      $_db,
      $_db.expenses,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_expenseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $LocationsTable _locationIdTable(_$AppDatabase db) =>
      db.locations.createAlias(
        $_aliasNameGenerator(db.expenseLocations.locationId, db.locations.id),
      );

  $$LocationsTableProcessedTableManager get locationId {
    final $_column = $_itemColumn<String>('location_id')!;

    final manager = $$LocationsTableTableManager(
      $_db,
      $_db.locations,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_locationIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$ExpenseLocationsTableFilterComposer
    extends Composer<_$AppDatabase, $ExpenseLocationsTable> {
  $$ExpenseLocationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$ExpensesTableFilterComposer get expenseId {
    final $$ExpensesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.expenseId,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableFilterComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$LocationsTableFilterComposer get locationId {
    final $$LocationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.locationId,
      referencedTable: $db.locations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LocationsTableFilterComposer(
            $db: $db,
            $table: $db.locations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ExpenseLocationsTableOrderingComposer
    extends Composer<_$AppDatabase, $ExpenseLocationsTable> {
  $$ExpenseLocationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$ExpensesTableOrderingComposer get expenseId {
    final $$ExpensesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.expenseId,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableOrderingComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$LocationsTableOrderingComposer get locationId {
    final $$LocationsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.locationId,
      referencedTable: $db.locations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LocationsTableOrderingComposer(
            $db: $db,
            $table: $db.locations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ExpenseLocationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ExpenseLocationsTable> {
  $$ExpenseLocationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$ExpensesTableAnnotationComposer get expenseId {
    final $$ExpensesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.expenseId,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableAnnotationComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$LocationsTableAnnotationComposer get locationId {
    final $$LocationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.locationId,
      referencedTable: $db.locations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LocationsTableAnnotationComposer(
            $db: $db,
            $table: $db.locations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$ExpenseLocationsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ExpenseLocationsTable,
          ExpenseLocation,
          $$ExpenseLocationsTableFilterComposer,
          $$ExpenseLocationsTableOrderingComposer,
          $$ExpenseLocationsTableAnnotationComposer,
          $$ExpenseLocationsTableCreateCompanionBuilder,
          $$ExpenseLocationsTableUpdateCompanionBuilder,
          (ExpenseLocation, $$ExpenseLocationsTableReferences),
          ExpenseLocation,
          PrefetchHooks Function({bool expenseId, bool locationId})
        > {
  $$ExpenseLocationsTableTableManager(
    _$AppDatabase db,
    $ExpenseLocationsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ExpenseLocationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ExpenseLocationsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ExpenseLocationsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> expenseId = const Value.absent(),
                Value<String> locationId = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ExpenseLocationsCompanion(
                expenseId: expenseId,
                locationId: locationId,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String expenseId,
                required String locationId,
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ExpenseLocationsCompanion.insert(
                expenseId: expenseId,
                locationId: locationId,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$ExpenseLocationsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({expenseId = false, locationId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (expenseId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.expenseId,
                                referencedTable:
                                    $$ExpenseLocationsTableReferences
                                        ._expenseIdTable(db),
                                referencedColumn:
                                    $$ExpenseLocationsTableReferences
                                        ._expenseIdTable(db)
                                        .id,
                              )
                              as T;
                    }
                    if (locationId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.locationId,
                                referencedTable:
                                    $$ExpenseLocationsTableReferences
                                        ._locationIdTable(db),
                                referencedColumn:
                                    $$ExpenseLocationsTableReferences
                                        ._locationIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$ExpenseLocationsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ExpenseLocationsTable,
      ExpenseLocation,
      $$ExpenseLocationsTableFilterComposer,
      $$ExpenseLocationsTableOrderingComposer,
      $$ExpenseLocationsTableAnnotationComposer,
      $$ExpenseLocationsTableCreateCompanionBuilder,
      $$ExpenseLocationsTableUpdateCompanionBuilder,
      (ExpenseLocation, $$ExpenseLocationsTableReferences),
      ExpenseLocation,
      PrefetchHooks Function({bool expenseId, bool locationId})
    >;
typedef $$RecurringExpenseLocationsTableCreateCompanionBuilder =
    RecurringExpenseLocationsCompanion Function({
      required String recurringExpenseId,
      required String locationId,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$RecurringExpenseLocationsTableUpdateCompanionBuilder =
    RecurringExpenseLocationsCompanion Function({
      Value<String> recurringExpenseId,
      Value<String> locationId,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$RecurringExpenseLocationsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $RecurringExpenseLocationsTable,
          RecurringExpenseLocation
        > {
  $$RecurringExpenseLocationsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $RecurringExpensesTable _recurringExpenseIdTable(_$AppDatabase db) =>
      db.recurringExpenses.createAlias(
        $_aliasNameGenerator(
          db.recurringExpenseLocations.recurringExpenseId,
          db.recurringExpenses.id,
        ),
      );

  $$RecurringExpensesTableProcessedTableManager get recurringExpenseId {
    final $_column = $_itemColumn<String>('recurring_expense_id')!;

    final manager = $$RecurringExpensesTableTableManager(
      $_db,
      $_db.recurringExpenses,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_recurringExpenseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $LocationsTable _locationIdTable(_$AppDatabase db) =>
      db.locations.createAlias(
        $_aliasNameGenerator(
          db.recurringExpenseLocations.locationId,
          db.locations.id,
        ),
      );

  $$LocationsTableProcessedTableManager get locationId {
    final $_column = $_itemColumn<String>('location_id')!;

    final manager = $$LocationsTableTableManager(
      $_db,
      $_db.locations,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_locationIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$RecurringExpenseLocationsTableFilterComposer
    extends Composer<_$AppDatabase, $RecurringExpenseLocationsTable> {
  $$RecurringExpenseLocationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$RecurringExpensesTableFilterComposer get recurringExpenseId {
    final $$RecurringExpensesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.recurringExpenseId,
      referencedTable: $db.recurringExpenses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RecurringExpensesTableFilterComposer(
            $db: $db,
            $table: $db.recurringExpenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$LocationsTableFilterComposer get locationId {
    final $$LocationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.locationId,
      referencedTable: $db.locations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LocationsTableFilterComposer(
            $db: $db,
            $table: $db.locations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$RecurringExpenseLocationsTableOrderingComposer
    extends Composer<_$AppDatabase, $RecurringExpenseLocationsTable> {
  $$RecurringExpenseLocationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$RecurringExpensesTableOrderingComposer get recurringExpenseId {
    final $$RecurringExpensesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.recurringExpenseId,
      referencedTable: $db.recurringExpenses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$RecurringExpensesTableOrderingComposer(
            $db: $db,
            $table: $db.recurringExpenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$LocationsTableOrderingComposer get locationId {
    final $$LocationsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.locationId,
      referencedTable: $db.locations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LocationsTableOrderingComposer(
            $db: $db,
            $table: $db.locations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$RecurringExpenseLocationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $RecurringExpenseLocationsTable> {
  $$RecurringExpenseLocationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$RecurringExpensesTableAnnotationComposer get recurringExpenseId {
    final $$RecurringExpensesTableAnnotationComposer composer =
        $composerBuilder(
          composer: this,
          getCurrentColumn: (t) => t.recurringExpenseId,
          referencedTable: $db.recurringExpenses,
          getReferencedColumn: (t) => t.id,
          builder:
              (
                joinBuilder, {
                $addJoinBuilderToRootComposer,
                $removeJoinBuilderFromRootComposer,
              }) => $$RecurringExpensesTableAnnotationComposer(
                $db: $db,
                $table: $db.recurringExpenses,
                $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
                joinBuilder: joinBuilder,
                $removeJoinBuilderFromRootComposer:
                    $removeJoinBuilderFromRootComposer,
              ),
        );
    return composer;
  }

  $$LocationsTableAnnotationComposer get locationId {
    final $$LocationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.locationId,
      referencedTable: $db.locations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LocationsTableAnnotationComposer(
            $db: $db,
            $table: $db.locations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$RecurringExpenseLocationsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $RecurringExpenseLocationsTable,
          RecurringExpenseLocation,
          $$RecurringExpenseLocationsTableFilterComposer,
          $$RecurringExpenseLocationsTableOrderingComposer,
          $$RecurringExpenseLocationsTableAnnotationComposer,
          $$RecurringExpenseLocationsTableCreateCompanionBuilder,
          $$RecurringExpenseLocationsTableUpdateCompanionBuilder,
          (
            RecurringExpenseLocation,
            $$RecurringExpenseLocationsTableReferences,
          ),
          RecurringExpenseLocation,
          PrefetchHooks Function({bool recurringExpenseId, bool locationId})
        > {
  $$RecurringExpenseLocationsTableTableManager(
    _$AppDatabase db,
    $RecurringExpenseLocationsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$RecurringExpenseLocationsTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$RecurringExpenseLocationsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$RecurringExpenseLocationsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> recurringExpenseId = const Value.absent(),
                Value<String> locationId = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RecurringExpenseLocationsCompanion(
                recurringExpenseId: recurringExpenseId,
                locationId: locationId,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String recurringExpenseId,
                required String locationId,
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => RecurringExpenseLocationsCompanion.insert(
                recurringExpenseId: recurringExpenseId,
                locationId: locationId,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$RecurringExpenseLocationsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({recurringExpenseId = false, locationId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (recurringExpenseId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.recurringExpenseId,
                                referencedTable:
                                    $$RecurringExpenseLocationsTableReferences
                                        ._recurringExpenseIdTable(db),
                                referencedColumn:
                                    $$RecurringExpenseLocationsTableReferences
                                        ._recurringExpenseIdTable(db)
                                        .id,
                              )
                              as T;
                    }
                    if (locationId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.locationId,
                                referencedTable:
                                    $$RecurringExpenseLocationsTableReferences
                                        ._locationIdTable(db),
                                referencedColumn:
                                    $$RecurringExpenseLocationsTableReferences
                                        ._locationIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$RecurringExpenseLocationsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $RecurringExpenseLocationsTable,
      RecurringExpenseLocation,
      $$RecurringExpenseLocationsTableFilterComposer,
      $$RecurringExpenseLocationsTableOrderingComposer,
      $$RecurringExpenseLocationsTableAnnotationComposer,
      $$RecurringExpenseLocationsTableCreateCompanionBuilder,
      $$RecurringExpenseLocationsTableUpdateCompanionBuilder,
      (RecurringExpenseLocation, $$RecurringExpenseLocationsTableReferences),
      RecurringExpenseLocation,
      PrefetchHooks Function({bool recurringExpenseId, bool locationId})
    >;
typedef $$LocationAnalyticsTableCreateCompanionBuilder =
    LocationAnalyticsCompanion Function({
      required String id,
      Value<String?> userId,
      Value<String?> locationId,
      Value<double?> accuracy,
      Value<double?> speed,
      Value<String?> batteryImpact,
      Value<String?> networkType,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$LocationAnalyticsTableUpdateCompanionBuilder =
    LocationAnalyticsCompanion Function({
      Value<String> id,
      Value<String?> userId,
      Value<String?> locationId,
      Value<double?> accuracy,
      Value<double?> speed,
      Value<String?> batteryImpact,
      Value<String?> networkType,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$LocationAnalyticsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $LocationAnalyticsTable,
          LocationAnalytic
        > {
  $$LocationAnalyticsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.locationAnalytics.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager? get userId {
    final $_column = $_itemColumn<String>('user_id');
    if ($_column == null) return null;
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $LocationsTable _locationIdTable(_$AppDatabase db) =>
      db.locations.createAlias(
        $_aliasNameGenerator(db.locationAnalytics.locationId, db.locations.id),
      );

  $$LocationsTableProcessedTableManager? get locationId {
    final $_column = $_itemColumn<String>('location_id');
    if ($_column == null) return null;
    final manager = $$LocationsTableTableManager(
      $_db,
      $_db.locations,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_locationIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$LocationAnalyticsTableFilterComposer
    extends Composer<_$AppDatabase, $LocationAnalyticsTable> {
  $$LocationAnalyticsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get accuracy => $composableBuilder(
    column: $table.accuracy,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get speed => $composableBuilder(
    column: $table.speed,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get batteryImpact => $composableBuilder(
    column: $table.batteryImpact,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get networkType => $composableBuilder(
    column: $table.networkType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$LocationsTableFilterComposer get locationId {
    final $$LocationsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.locationId,
      referencedTable: $db.locations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LocationsTableFilterComposer(
            $db: $db,
            $table: $db.locations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LocationAnalyticsTableOrderingComposer
    extends Composer<_$AppDatabase, $LocationAnalyticsTable> {
  $$LocationAnalyticsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get accuracy => $composableBuilder(
    column: $table.accuracy,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get speed => $composableBuilder(
    column: $table.speed,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get batteryImpact => $composableBuilder(
    column: $table.batteryImpact,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get networkType => $composableBuilder(
    column: $table.networkType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$LocationsTableOrderingComposer get locationId {
    final $$LocationsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.locationId,
      referencedTable: $db.locations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LocationsTableOrderingComposer(
            $db: $db,
            $table: $db.locations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LocationAnalyticsTableAnnotationComposer
    extends Composer<_$AppDatabase, $LocationAnalyticsTable> {
  $$LocationAnalyticsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get accuracy =>
      $composableBuilder(column: $table.accuracy, builder: (column) => column);

  GeneratedColumn<double> get speed =>
      $composableBuilder(column: $table.speed, builder: (column) => column);

  GeneratedColumn<String> get batteryImpact => $composableBuilder(
    column: $table.batteryImpact,
    builder: (column) => column,
  );

  GeneratedColumn<String> get networkType => $composableBuilder(
    column: $table.networkType,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$LocationsTableAnnotationComposer get locationId {
    final $$LocationsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.locationId,
      referencedTable: $db.locations,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$LocationsTableAnnotationComposer(
            $db: $db,
            $table: $db.locations,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LocationAnalyticsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $LocationAnalyticsTable,
          LocationAnalytic,
          $$LocationAnalyticsTableFilterComposer,
          $$LocationAnalyticsTableOrderingComposer,
          $$LocationAnalyticsTableAnnotationComposer,
          $$LocationAnalyticsTableCreateCompanionBuilder,
          $$LocationAnalyticsTableUpdateCompanionBuilder,
          (LocationAnalytic, $$LocationAnalyticsTableReferences),
          LocationAnalytic,
          PrefetchHooks Function({bool userId, bool locationId})
        > {
  $$LocationAnalyticsTableTableManager(
    _$AppDatabase db,
    $LocationAnalyticsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LocationAnalyticsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LocationAnalyticsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LocationAnalyticsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> userId = const Value.absent(),
                Value<String?> locationId = const Value.absent(),
                Value<double?> accuracy = const Value.absent(),
                Value<double?> speed = const Value.absent(),
                Value<String?> batteryImpact = const Value.absent(),
                Value<String?> networkType = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LocationAnalyticsCompanion(
                id: id,
                userId: userId,
                locationId: locationId,
                accuracy: accuracy,
                speed: speed,
                batteryImpact: batteryImpact,
                networkType: networkType,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> userId = const Value.absent(),
                Value<String?> locationId = const Value.absent(),
                Value<double?> accuracy = const Value.absent(),
                Value<double?> speed = const Value.absent(),
                Value<String?> batteryImpact = const Value.absent(),
                Value<String?> networkType = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LocationAnalyticsCompanion.insert(
                id: id,
                userId: userId,
                locationId: locationId,
                accuracy: accuracy,
                speed: speed,
                batteryImpact: batteryImpact,
                networkType: networkType,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$LocationAnalyticsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({userId = false, locationId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable:
                                    $$LocationAnalyticsTableReferences
                                        ._userIdTable(db),
                                referencedColumn:
                                    $$LocationAnalyticsTableReferences
                                        ._userIdTable(db)
                                        .id,
                              )
                              as T;
                    }
                    if (locationId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.locationId,
                                referencedTable:
                                    $$LocationAnalyticsTableReferences
                                        ._locationIdTable(db),
                                referencedColumn:
                                    $$LocationAnalyticsTableReferences
                                        ._locationIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$LocationAnalyticsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $LocationAnalyticsTable,
      LocationAnalytic,
      $$LocationAnalyticsTableFilterComposer,
      $$LocationAnalyticsTableOrderingComposer,
      $$LocationAnalyticsTableAnnotationComposer,
      $$LocationAnalyticsTableCreateCompanionBuilder,
      $$LocationAnalyticsTableUpdateCompanionBuilder,
      (LocationAnalytic, $$LocationAnalyticsTableReferences),
      LocationAnalytic,
      PrefetchHooks Function({bool userId, bool locationId})
    >;
typedef $$GeofencesTableCreateCompanionBuilder =
    GeofencesCompanion Function({
      required String id,
      required String userId,
      required String name,
      required double latitude,
      required double longitude,
      required double radius,
      Value<String?> context,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$GeofencesTableUpdateCompanionBuilder =
    GeofencesCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String> name,
      Value<double> latitude,
      Value<double> longitude,
      Value<double> radius,
      Value<String?> context,
      Value<bool> isActive,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$GeofencesTableReferences
    extends BaseReferences<_$AppDatabase, $GeofencesTable, Geofence> {
  $$GeofencesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.geofences.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static MultiTypedResultKey<$GeofenceEventsTable, List<GeofenceEvent>>
  _geofenceEventsRefsTable(_$AppDatabase db) => MultiTypedResultKey.fromTable(
    db.geofenceEvents,
    aliasName: $_aliasNameGenerator(
      db.geofences.id,
      db.geofenceEvents.geofenceId,
    ),
  );

  $$GeofenceEventsTableProcessedTableManager get geofenceEventsRefs {
    final manager = $$GeofenceEventsTableTableManager(
      $_db,
      $_db.geofenceEvents,
    ).filter((f) => f.geofenceId.id.sqlEquals($_itemColumn<String>('id')!));

    final cache = $_typedResult.readTableOrNull(_geofenceEventsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$GeofencesTableFilterComposer
    extends Composer<_$AppDatabase, $GeofencesTable> {
  $$GeofencesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get radius => $composableBuilder(
    column: $table.radius,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get context => $composableBuilder(
    column: $table.context,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<bool> geofenceEventsRefs(
    Expression<bool> Function($$GeofenceEventsTableFilterComposer f) f,
  ) {
    final $$GeofenceEventsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.geofenceEvents,
      getReferencedColumn: (t) => t.geofenceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GeofenceEventsTableFilterComposer(
            $db: $db,
            $table: $db.geofenceEvents,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$GeofencesTableOrderingComposer
    extends Composer<_$AppDatabase, $GeofencesTable> {
  $$GeofencesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get radius => $composableBuilder(
    column: $table.radius,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get context => $composableBuilder(
    column: $table.context,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isActive => $composableBuilder(
    column: $table.isActive,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$GeofencesTableAnnotationComposer
    extends Composer<_$AppDatabase, $GeofencesTable> {
  $$GeofencesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<double> get radius =>
      $composableBuilder(column: $table.radius, builder: (column) => column);

  GeneratedColumn<String> get context =>
      $composableBuilder(column: $table.context, builder: (column) => column);

  GeneratedColumn<bool> get isActive =>
      $composableBuilder(column: $table.isActive, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  Expression<T> geofenceEventsRefs<T extends Object>(
    Expression<T> Function($$GeofenceEventsTableAnnotationComposer a) f,
  ) {
    final $$GeofenceEventsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.geofenceEvents,
      getReferencedColumn: (t) => t.geofenceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GeofenceEventsTableAnnotationComposer(
            $db: $db,
            $table: $db.geofenceEvents,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$GeofencesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $GeofencesTable,
          Geofence,
          $$GeofencesTableFilterComposer,
          $$GeofencesTableOrderingComposer,
          $$GeofencesTableAnnotationComposer,
          $$GeofencesTableCreateCompanionBuilder,
          $$GeofencesTableUpdateCompanionBuilder,
          (Geofence, $$GeofencesTableReferences),
          Geofence,
          PrefetchHooks Function({bool userId, bool geofenceEventsRefs})
        > {
  $$GeofencesTableTableManager(_$AppDatabase db, $GeofencesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GeofencesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GeofencesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GeofencesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<double> latitude = const Value.absent(),
                Value<double> longitude = const Value.absent(),
                Value<double> radius = const Value.absent(),
                Value<String?> context = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => GeofencesCompanion(
                id: id,
                userId: userId,
                name: name,
                latitude: latitude,
                longitude: longitude,
                radius: radius,
                context: context,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required String name,
                required double latitude,
                required double longitude,
                required double radius,
                Value<String?> context = const Value.absent(),
                Value<bool> isActive = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => GeofencesCompanion.insert(
                id: id,
                userId: userId,
                name: name,
                latitude: latitude,
                longitude: longitude,
                radius: radius,
                context: context,
                isActive: isActive,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$GeofencesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({userId = false, geofenceEventsRefs = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [
                    if (geofenceEventsRefs) db.geofenceEvents,
                  ],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (userId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.userId,
                                    referencedTable: $$GeofencesTableReferences
                                        ._userIdTable(db),
                                    referencedColumn: $$GeofencesTableReferences
                                        ._userIdTable(db)
                                        .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [
                      if (geofenceEventsRefs)
                        await $_getPrefetchedData<
                          Geofence,
                          $GeofencesTable,
                          GeofenceEvent
                        >(
                          currentTable: table,
                          referencedTable: $$GeofencesTableReferences
                              ._geofenceEventsRefsTable(db),
                          managerFromTypedResult: (p0) =>
                              $$GeofencesTableReferences(
                                db,
                                table,
                                p0,
                              ).geofenceEventsRefs,
                          referencedItemsForCurrentItem:
                              (item, referencedItems) => referencedItems.where(
                                (e) => e.geofenceId == item.id,
                              ),
                          typedResults: items,
                        ),
                    ];
                  },
                );
              },
        ),
      );
}

typedef $$GeofencesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $GeofencesTable,
      Geofence,
      $$GeofencesTableFilterComposer,
      $$GeofencesTableOrderingComposer,
      $$GeofencesTableAnnotationComposer,
      $$GeofencesTableCreateCompanionBuilder,
      $$GeofencesTableUpdateCompanionBuilder,
      (Geofence, $$GeofencesTableReferences),
      Geofence,
      PrefetchHooks Function({bool userId, bool geofenceEventsRefs})
    >;
typedef $$GeofenceEventsTableCreateCompanionBuilder =
    GeofenceEventsCompanion Function({
      required String id,
      required String geofenceId,
      required String eventType,
      required double latitude,
      required double longitude,
      Value<int?> durationSeconds,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$GeofenceEventsTableUpdateCompanionBuilder =
    GeofenceEventsCompanion Function({
      Value<String> id,
      Value<String> geofenceId,
      Value<String> eventType,
      Value<double> latitude,
      Value<double> longitude,
      Value<int?> durationSeconds,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$GeofenceEventsTableReferences
    extends BaseReferences<_$AppDatabase, $GeofenceEventsTable, GeofenceEvent> {
  $$GeofenceEventsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $GeofencesTable _geofenceIdTable(_$AppDatabase db) =>
      db.geofences.createAlias(
        $_aliasNameGenerator(db.geofenceEvents.geofenceId, db.geofences.id),
      );

  $$GeofencesTableProcessedTableManager get geofenceId {
    final $_column = $_itemColumn<String>('geofence_id')!;

    final manager = $$GeofencesTableTableManager(
      $_db,
      $_db.geofences,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_geofenceIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$GeofenceEventsTableFilterComposer
    extends Composer<_$AppDatabase, $GeofenceEventsTable> {
  $$GeofenceEventsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get eventType => $composableBuilder(
    column: $table.eventType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get durationSeconds => $composableBuilder(
    column: $table.durationSeconds,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$GeofencesTableFilterComposer get geofenceId {
    final $$GeofencesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.geofenceId,
      referencedTable: $db.geofences,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GeofencesTableFilterComposer(
            $db: $db,
            $table: $db.geofences,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$GeofenceEventsTableOrderingComposer
    extends Composer<_$AppDatabase, $GeofenceEventsTable> {
  $$GeofenceEventsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get eventType => $composableBuilder(
    column: $table.eventType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get latitude => $composableBuilder(
    column: $table.latitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get longitude => $composableBuilder(
    column: $table.longitude,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get durationSeconds => $composableBuilder(
    column: $table.durationSeconds,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$GeofencesTableOrderingComposer get geofenceId {
    final $$GeofencesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.geofenceId,
      referencedTable: $db.geofences,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GeofencesTableOrderingComposer(
            $db: $db,
            $table: $db.geofences,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$GeofenceEventsTableAnnotationComposer
    extends Composer<_$AppDatabase, $GeofenceEventsTable> {
  $$GeofenceEventsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get eventType =>
      $composableBuilder(column: $table.eventType, builder: (column) => column);

  GeneratedColumn<double> get latitude =>
      $composableBuilder(column: $table.latitude, builder: (column) => column);

  GeneratedColumn<double> get longitude =>
      $composableBuilder(column: $table.longitude, builder: (column) => column);

  GeneratedColumn<int> get durationSeconds => $composableBuilder(
    column: $table.durationSeconds,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$GeofencesTableAnnotationComposer get geofenceId {
    final $$GeofencesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.geofenceId,
      referencedTable: $db.geofences,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$GeofencesTableAnnotationComposer(
            $db: $db,
            $table: $db.geofences,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$GeofenceEventsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $GeofenceEventsTable,
          GeofenceEvent,
          $$GeofenceEventsTableFilterComposer,
          $$GeofenceEventsTableOrderingComposer,
          $$GeofenceEventsTableAnnotationComposer,
          $$GeofenceEventsTableCreateCompanionBuilder,
          $$GeofenceEventsTableUpdateCompanionBuilder,
          (GeofenceEvent, $$GeofenceEventsTableReferences),
          GeofenceEvent,
          PrefetchHooks Function({bool geofenceId})
        > {
  $$GeofenceEventsTableTableManager(
    _$AppDatabase db,
    $GeofenceEventsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$GeofenceEventsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$GeofenceEventsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$GeofenceEventsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> geofenceId = const Value.absent(),
                Value<String> eventType = const Value.absent(),
                Value<double> latitude = const Value.absent(),
                Value<double> longitude = const Value.absent(),
                Value<int?> durationSeconds = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => GeofenceEventsCompanion(
                id: id,
                geofenceId: geofenceId,
                eventType: eventType,
                latitude: latitude,
                longitude: longitude,
                durationSeconds: durationSeconds,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String geofenceId,
                required String eventType,
                required double latitude,
                required double longitude,
                Value<int?> durationSeconds = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => GeofenceEventsCompanion.insert(
                id: id,
                geofenceId: geofenceId,
                eventType: eventType,
                latitude: latitude,
                longitude: longitude,
                durationSeconds: durationSeconds,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$GeofenceEventsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({geofenceId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (geofenceId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.geofenceId,
                                referencedTable: $$GeofenceEventsTableReferences
                                    ._geofenceIdTable(db),
                                referencedColumn:
                                    $$GeofenceEventsTableReferences
                                        ._geofenceIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$GeofenceEventsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $GeofenceEventsTable,
      GeofenceEvent,
      $$GeofenceEventsTableFilterComposer,
      $$GeofenceEventsTableOrderingComposer,
      $$GeofenceEventsTableAnnotationComposer,
      $$GeofenceEventsTableCreateCompanionBuilder,
      $$GeofenceEventsTableUpdateCompanionBuilder,
      (GeofenceEvent, $$GeofenceEventsTableReferences),
      GeofenceEvent,
      PrefetchHooks Function({bool geofenceId})
    >;
typedef $$ConflictsTableCreateCompanionBuilder =
    ConflictsCompanion Function({
      required String id,
      required String entityType,
      required String entityId,
      Value<DateTime> createdAt,
      Value<String> status,
      required String localJson,
      required String remoteJson,
      Value<String?> diffJson,
      Value<String> resolutionType,
      Value<DateTime?> resolvedAt,
      Value<String?> detectedByDeviceId,
      Value<int> rowid,
    });
typedef $$ConflictsTableUpdateCompanionBuilder =
    ConflictsCompanion Function({
      Value<String> id,
      Value<String> entityType,
      Value<String> entityId,
      Value<DateTime> createdAt,
      Value<String> status,
      Value<String> localJson,
      Value<String> remoteJson,
      Value<String?> diffJson,
      Value<String> resolutionType,
      Value<DateTime?> resolvedAt,
      Value<String?> detectedByDeviceId,
      Value<int> rowid,
    });

class $$ConflictsTableFilterComposer
    extends Composer<_$AppDatabase, $ConflictsTable> {
  $$ConflictsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get localJson => $composableBuilder(
    column: $table.localJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get remoteJson => $composableBuilder(
    column: $table.remoteJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get diffJson => $composableBuilder(
    column: $table.diffJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get resolutionType => $composableBuilder(
    column: $table.resolutionType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get resolvedAt => $composableBuilder(
    column: $table.resolvedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get detectedByDeviceId => $composableBuilder(
    column: $table.detectedByDeviceId,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ConflictsTableOrderingComposer
    extends Composer<_$AppDatabase, $ConflictsTable> {
  $$ConflictsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get localJson => $composableBuilder(
    column: $table.localJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get remoteJson => $composableBuilder(
    column: $table.remoteJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get diffJson => $composableBuilder(
    column: $table.diffJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get resolutionType => $composableBuilder(
    column: $table.resolutionType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get resolvedAt => $composableBuilder(
    column: $table.resolvedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get detectedByDeviceId => $composableBuilder(
    column: $table.detectedByDeviceId,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ConflictsTableAnnotationComposer
    extends Composer<_$AppDatabase, $ConflictsTable> {
  $$ConflictsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityId =>
      $composableBuilder(column: $table.entityId, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get localJson =>
      $composableBuilder(column: $table.localJson, builder: (column) => column);

  GeneratedColumn<String> get remoteJson => $composableBuilder(
    column: $table.remoteJson,
    builder: (column) => column,
  );

  GeneratedColumn<String> get diffJson =>
      $composableBuilder(column: $table.diffJson, builder: (column) => column);

  GeneratedColumn<String> get resolutionType => $composableBuilder(
    column: $table.resolutionType,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get resolvedAt => $composableBuilder(
    column: $table.resolvedAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get detectedByDeviceId => $composableBuilder(
    column: $table.detectedByDeviceId,
    builder: (column) => column,
  );
}

class $$ConflictsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ConflictsTable,
          ConflictData,
          $$ConflictsTableFilterComposer,
          $$ConflictsTableOrderingComposer,
          $$ConflictsTableAnnotationComposer,
          $$ConflictsTableCreateCompanionBuilder,
          $$ConflictsTableUpdateCompanionBuilder,
          (
            ConflictData,
            BaseReferences<_$AppDatabase, $ConflictsTable, ConflictData>,
          ),
          ConflictData,
          PrefetchHooks Function()
        > {
  $$ConflictsTableTableManager(_$AppDatabase db, $ConflictsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ConflictsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ConflictsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ConflictsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> entityType = const Value.absent(),
                Value<String> entityId = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String> localJson = const Value.absent(),
                Value<String> remoteJson = const Value.absent(),
                Value<String?> diffJson = const Value.absent(),
                Value<String> resolutionType = const Value.absent(),
                Value<DateTime?> resolvedAt = const Value.absent(),
                Value<String?> detectedByDeviceId = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ConflictsCompanion(
                id: id,
                entityType: entityType,
                entityId: entityId,
                createdAt: createdAt,
                status: status,
                localJson: localJson,
                remoteJson: remoteJson,
                diffJson: diffJson,
                resolutionType: resolutionType,
                resolvedAt: resolvedAt,
                detectedByDeviceId: detectedByDeviceId,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String entityType,
                required String entityId,
                Value<DateTime> createdAt = const Value.absent(),
                Value<String> status = const Value.absent(),
                required String localJson,
                required String remoteJson,
                Value<String?> diffJson = const Value.absent(),
                Value<String> resolutionType = const Value.absent(),
                Value<DateTime?> resolvedAt = const Value.absent(),
                Value<String?> detectedByDeviceId = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ConflictsCompanion.insert(
                id: id,
                entityType: entityType,
                entityId: entityId,
                createdAt: createdAt,
                status: status,
                localJson: localJson,
                remoteJson: remoteJson,
                diffJson: diffJson,
                resolutionType: resolutionType,
                resolvedAt: resolvedAt,
                detectedByDeviceId: detectedByDeviceId,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ConflictsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ConflictsTable,
      ConflictData,
      $$ConflictsTableFilterComposer,
      $$ConflictsTableOrderingComposer,
      $$ConflictsTableAnnotationComposer,
      $$ConflictsTableCreateCompanionBuilder,
      $$ConflictsTableUpdateCompanionBuilder,
      (
        ConflictData,
        BaseReferences<_$AppDatabase, $ConflictsTable, ConflictData>,
      ),
      ConflictData,
      PrefetchHooks Function()
    >;
typedef $$AuditEventsTableCreateCompanionBuilder =
    AuditEventsCompanion Function({
      required String id,
      required String eventType,
      Value<DateTime> createdAt,
      Value<String?> actorDeviceId,
      required String summary,
      Value<String?> detailsJson,
      Value<String?> correlationId,
      Value<String> severity,
      Value<int> rowid,
    });
typedef $$AuditEventsTableUpdateCompanionBuilder =
    AuditEventsCompanion Function({
      Value<String> id,
      Value<String> eventType,
      Value<DateTime> createdAt,
      Value<String?> actorDeviceId,
      Value<String> summary,
      Value<String?> detailsJson,
      Value<String?> correlationId,
      Value<String> severity,
      Value<int> rowid,
    });

class $$AuditEventsTableFilterComposer
    extends Composer<_$AppDatabase, $AuditEventsTable> {
  $$AuditEventsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get eventType => $composableBuilder(
    column: $table.eventType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get actorDeviceId => $composableBuilder(
    column: $table.actorDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get summary => $composableBuilder(
    column: $table.summary,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get detailsJson => $composableBuilder(
    column: $table.detailsJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get correlationId => $composableBuilder(
    column: $table.correlationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get severity => $composableBuilder(
    column: $table.severity,
    builder: (column) => ColumnFilters(column),
  );
}

class $$AuditEventsTableOrderingComposer
    extends Composer<_$AppDatabase, $AuditEventsTable> {
  $$AuditEventsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get eventType => $composableBuilder(
    column: $table.eventType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get actorDeviceId => $composableBuilder(
    column: $table.actorDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get summary => $composableBuilder(
    column: $table.summary,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get detailsJson => $composableBuilder(
    column: $table.detailsJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get correlationId => $composableBuilder(
    column: $table.correlationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get severity => $composableBuilder(
    column: $table.severity,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$AuditEventsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AuditEventsTable> {
  $$AuditEventsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get eventType =>
      $composableBuilder(column: $table.eventType, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<String> get actorDeviceId => $composableBuilder(
    column: $table.actorDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get summary =>
      $composableBuilder(column: $table.summary, builder: (column) => column);

  GeneratedColumn<String> get detailsJson => $composableBuilder(
    column: $table.detailsJson,
    builder: (column) => column,
  );

  GeneratedColumn<String> get correlationId => $composableBuilder(
    column: $table.correlationId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get severity =>
      $composableBuilder(column: $table.severity, builder: (column) => column);
}

class $$AuditEventsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AuditEventsTable,
          AuditEvent,
          $$AuditEventsTableFilterComposer,
          $$AuditEventsTableOrderingComposer,
          $$AuditEventsTableAnnotationComposer,
          $$AuditEventsTableCreateCompanionBuilder,
          $$AuditEventsTableUpdateCompanionBuilder,
          (
            AuditEvent,
            BaseReferences<_$AppDatabase, $AuditEventsTable, AuditEvent>,
          ),
          AuditEvent,
          PrefetchHooks Function()
        > {
  $$AuditEventsTableTableManager(_$AppDatabase db, $AuditEventsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AuditEventsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AuditEventsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AuditEventsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> eventType = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<String?> actorDeviceId = const Value.absent(),
                Value<String> summary = const Value.absent(),
                Value<String?> detailsJson = const Value.absent(),
                Value<String?> correlationId = const Value.absent(),
                Value<String> severity = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AuditEventsCompanion(
                id: id,
                eventType: eventType,
                createdAt: createdAt,
                actorDeviceId: actorDeviceId,
                summary: summary,
                detailsJson: detailsJson,
                correlationId: correlationId,
                severity: severity,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String eventType,
                Value<DateTime> createdAt = const Value.absent(),
                Value<String?> actorDeviceId = const Value.absent(),
                required String summary,
                Value<String?> detailsJson = const Value.absent(),
                Value<String?> correlationId = const Value.absent(),
                Value<String> severity = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AuditEventsCompanion.insert(
                id: id,
                eventType: eventType,
                createdAt: createdAt,
                actorDeviceId: actorDeviceId,
                summary: summary,
                detailsJson: detailsJson,
                correlationId: correlationId,
                severity: severity,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$AuditEventsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AuditEventsTable,
      AuditEvent,
      $$AuditEventsTableFilterComposer,
      $$AuditEventsTableOrderingComposer,
      $$AuditEventsTableAnnotationComposer,
      $$AuditEventsTableCreateCompanionBuilder,
      $$AuditEventsTableUpdateCompanionBuilder,
      (
        AuditEvent,
        BaseReferences<_$AppDatabase, $AuditEventsTable, AuditEvent>,
      ),
      AuditEvent,
      PrefetchHooks Function()
    >;
typedef $$OutboxEventsTableCreateCompanionBuilder =
    OutboxEventsCompanion Function({
      required String id,
      required String entityType,
      required String entityId,
      required String operation,
      required String payload,
      Value<int?> baseRevision,
      Value<DateTime> createdAt,
      Value<DateTime?> processedAt,
      Value<String> status,
      Value<String?> errorMessage,
      Value<int> retryCount,
      Value<int> priority,
      Value<int?> permissionEpochAtEdit,
      Value<DateTime?> lastRetryAt,
      Value<int> maxRetries,
      Value<int> rowid,
    });
typedef $$OutboxEventsTableUpdateCompanionBuilder =
    OutboxEventsCompanion Function({
      Value<String> id,
      Value<String> entityType,
      Value<String> entityId,
      Value<String> operation,
      Value<String> payload,
      Value<int?> baseRevision,
      Value<DateTime> createdAt,
      Value<DateTime?> processedAt,
      Value<String> status,
      Value<String?> errorMessage,
      Value<int> retryCount,
      Value<int> priority,
      Value<int?> permissionEpochAtEdit,
      Value<DateTime?> lastRetryAt,
      Value<int> maxRetries,
      Value<int> rowid,
    });

class $$OutboxEventsTableFilterComposer
    extends Composer<_$AppDatabase, $OutboxEventsTable> {
  $$OutboxEventsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operation => $composableBuilder(
    column: $table.operation,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get payload => $composableBuilder(
    column: $table.payload,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get processedAt => $composableBuilder(
    column: $table.processedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get errorMessage => $composableBuilder(
    column: $table.errorMessage,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get priority => $composableBuilder(
    column: $table.priority,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get permissionEpochAtEdit => $composableBuilder(
    column: $table.permissionEpochAtEdit,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastRetryAt => $composableBuilder(
    column: $table.lastRetryAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get maxRetries => $composableBuilder(
    column: $table.maxRetries,
    builder: (column) => ColumnFilters(column),
  );
}

class $$OutboxEventsTableOrderingComposer
    extends Composer<_$AppDatabase, $OutboxEventsTable> {
  $$OutboxEventsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operation => $composableBuilder(
    column: $table.operation,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get payload => $composableBuilder(
    column: $table.payload,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get processedAt => $composableBuilder(
    column: $table.processedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get errorMessage => $composableBuilder(
    column: $table.errorMessage,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get priority => $composableBuilder(
    column: $table.priority,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get permissionEpochAtEdit => $composableBuilder(
    column: $table.permissionEpochAtEdit,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastRetryAt => $composableBuilder(
    column: $table.lastRetryAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get maxRetries => $composableBuilder(
    column: $table.maxRetries,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$OutboxEventsTableAnnotationComposer
    extends Composer<_$AppDatabase, $OutboxEventsTable> {
  $$OutboxEventsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityId =>
      $composableBuilder(column: $table.entityId, builder: (column) => column);

  GeneratedColumn<String> get operation =>
      $composableBuilder(column: $table.operation, builder: (column) => column);

  GeneratedColumn<String> get payload =>
      $composableBuilder(column: $table.payload, builder: (column) => column);

  GeneratedColumn<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get processedAt => $composableBuilder(
    column: $table.processedAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get errorMessage => $composableBuilder(
    column: $table.errorMessage,
    builder: (column) => column,
  );

  GeneratedColumn<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => column,
  );

  GeneratedColumn<int> get priority =>
      $composableBuilder(column: $table.priority, builder: (column) => column);

  GeneratedColumn<int> get permissionEpochAtEdit => $composableBuilder(
    column: $table.permissionEpochAtEdit,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastRetryAt => $composableBuilder(
    column: $table.lastRetryAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get maxRetries => $composableBuilder(
    column: $table.maxRetries,
    builder: (column) => column,
  );
}

class $$OutboxEventsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $OutboxEventsTable,
          OutboxEvent,
          $$OutboxEventsTableFilterComposer,
          $$OutboxEventsTableOrderingComposer,
          $$OutboxEventsTableAnnotationComposer,
          $$OutboxEventsTableCreateCompanionBuilder,
          $$OutboxEventsTableUpdateCompanionBuilder,
          (
            OutboxEvent,
            BaseReferences<_$AppDatabase, $OutboxEventsTable, OutboxEvent>,
          ),
          OutboxEvent,
          PrefetchHooks Function()
        > {
  $$OutboxEventsTableTableManager(_$AppDatabase db, $OutboxEventsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$OutboxEventsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$OutboxEventsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$OutboxEventsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> entityType = const Value.absent(),
                Value<String> entityId = const Value.absent(),
                Value<String> operation = const Value.absent(),
                Value<String> payload = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> processedAt = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> errorMessage = const Value.absent(),
                Value<int> retryCount = const Value.absent(),
                Value<int> priority = const Value.absent(),
                Value<int?> permissionEpochAtEdit = const Value.absent(),
                Value<DateTime?> lastRetryAt = const Value.absent(),
                Value<int> maxRetries = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OutboxEventsCompanion(
                id: id,
                entityType: entityType,
                entityId: entityId,
                operation: operation,
                payload: payload,
                baseRevision: baseRevision,
                createdAt: createdAt,
                processedAt: processedAt,
                status: status,
                errorMessage: errorMessage,
                retryCount: retryCount,
                priority: priority,
                permissionEpochAtEdit: permissionEpochAtEdit,
                lastRetryAt: lastRetryAt,
                maxRetries: maxRetries,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String entityType,
                required String entityId,
                required String operation,
                required String payload,
                Value<int?> baseRevision = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> processedAt = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> errorMessage = const Value.absent(),
                Value<int> retryCount = const Value.absent(),
                Value<int> priority = const Value.absent(),
                Value<int?> permissionEpochAtEdit = const Value.absent(),
                Value<DateTime?> lastRetryAt = const Value.absent(),
                Value<int> maxRetries = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => OutboxEventsCompanion.insert(
                id: id,
                entityType: entityType,
                entityId: entityId,
                operation: operation,
                payload: payload,
                baseRevision: baseRevision,
                createdAt: createdAt,
                processedAt: processedAt,
                status: status,
                errorMessage: errorMessage,
                retryCount: retryCount,
                priority: priority,
                permissionEpochAtEdit: permissionEpochAtEdit,
                lastRetryAt: lastRetryAt,
                maxRetries: maxRetries,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$OutboxEventsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $OutboxEventsTable,
      OutboxEvent,
      $$OutboxEventsTableFilterComposer,
      $$OutboxEventsTableOrderingComposer,
      $$OutboxEventsTableAnnotationComposer,
      $$OutboxEventsTableCreateCompanionBuilder,
      $$OutboxEventsTableUpdateCompanionBuilder,
      (
        OutboxEvent,
        BaseReferences<_$AppDatabase, $OutboxEventsTable, OutboxEvent>,
      ),
      OutboxEvent,
      PrefetchHooks Function()
    >;
typedef $$CategoryLearningTableCreateCompanionBuilder =
    CategoryLearningCompanion Function({
      required String id,
      required String merchantPattern,
      Value<String?> semanticTokens,
      required String categoryName,
      Value<String?> subCategoryId,
      Value<int> confidenceBoost,
      Value<double> sourceWeight,
      Value<int> usageCount,
      required DateTime lastUsedAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });
typedef $$CategoryLearningTableUpdateCompanionBuilder =
    CategoryLearningCompanion Function({
      Value<String> id,
      Value<String> merchantPattern,
      Value<String?> semanticTokens,
      Value<String> categoryName,
      Value<String?> subCategoryId,
      Value<int> confidenceBoost,
      Value<double> sourceWeight,
      Value<int> usageCount,
      Value<DateTime> lastUsedAt,
      Value<DateTime> createdAt,
      Value<int> rowid,
    });

final class $$CategoryLearningTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $CategoryLearningTable,
          CategoryLearningData
        > {
  $$CategoryLearningTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $SubCategoriesTable _subCategoryIdTable(_$AppDatabase db) =>
      db.subCategories.createAlias(
        $_aliasNameGenerator(
          db.categoryLearning.subCategoryId,
          db.subCategories.id,
        ),
      );

  $$SubCategoriesTableProcessedTableManager? get subCategoryId {
    final $_column = $_itemColumn<String>('sub_category_id');
    if ($_column == null) return null;
    final manager = $$SubCategoriesTableTableManager(
      $_db,
      $_db.subCategories,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_subCategoryIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$CategoryLearningTableFilterComposer
    extends Composer<_$AppDatabase, $CategoryLearningTable> {
  $$CategoryLearningTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get merchantPattern => $composableBuilder(
    column: $table.merchantPattern,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get semanticTokens => $composableBuilder(
    column: $table.semanticTokens,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get categoryName => $composableBuilder(
    column: $table.categoryName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get confidenceBoost => $composableBuilder(
    column: $table.confidenceBoost,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get sourceWeight => $composableBuilder(
    column: $table.sourceWeight,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get usageCount => $composableBuilder(
    column: $table.usageCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastUsedAt => $composableBuilder(
    column: $table.lastUsedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  $$SubCategoriesTableFilterComposer get subCategoryId {
    final $$SubCategoriesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.subCategoryId,
      referencedTable: $db.subCategories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SubCategoriesTableFilterComposer(
            $db: $db,
            $table: $db.subCategories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CategoryLearningTableOrderingComposer
    extends Composer<_$AppDatabase, $CategoryLearningTable> {
  $$CategoryLearningTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get merchantPattern => $composableBuilder(
    column: $table.merchantPattern,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get semanticTokens => $composableBuilder(
    column: $table.semanticTokens,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get categoryName => $composableBuilder(
    column: $table.categoryName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get confidenceBoost => $composableBuilder(
    column: $table.confidenceBoost,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get sourceWeight => $composableBuilder(
    column: $table.sourceWeight,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get usageCount => $composableBuilder(
    column: $table.usageCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastUsedAt => $composableBuilder(
    column: $table.lastUsedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$SubCategoriesTableOrderingComposer get subCategoryId {
    final $$SubCategoriesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.subCategoryId,
      referencedTable: $db.subCategories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SubCategoriesTableOrderingComposer(
            $db: $db,
            $table: $db.subCategories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CategoryLearningTableAnnotationComposer
    extends Composer<_$AppDatabase, $CategoryLearningTable> {
  $$CategoryLearningTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get merchantPattern => $composableBuilder(
    column: $table.merchantPattern,
    builder: (column) => column,
  );

  GeneratedColumn<String> get semanticTokens => $composableBuilder(
    column: $table.semanticTokens,
    builder: (column) => column,
  );

  GeneratedColumn<String> get categoryName => $composableBuilder(
    column: $table.categoryName,
    builder: (column) => column,
  );

  GeneratedColumn<int> get confidenceBoost => $composableBuilder(
    column: $table.confidenceBoost,
    builder: (column) => column,
  );

  GeneratedColumn<double> get sourceWeight => $composableBuilder(
    column: $table.sourceWeight,
    builder: (column) => column,
  );

  GeneratedColumn<int> get usageCount => $composableBuilder(
    column: $table.usageCount,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastUsedAt => $composableBuilder(
    column: $table.lastUsedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  $$SubCategoriesTableAnnotationComposer get subCategoryId {
    final $$SubCategoriesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.subCategoryId,
      referencedTable: $db.subCategories,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SubCategoriesTableAnnotationComposer(
            $db: $db,
            $table: $db.subCategories,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CategoryLearningTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CategoryLearningTable,
          CategoryLearningData,
          $$CategoryLearningTableFilterComposer,
          $$CategoryLearningTableOrderingComposer,
          $$CategoryLearningTableAnnotationComposer,
          $$CategoryLearningTableCreateCompanionBuilder,
          $$CategoryLearningTableUpdateCompanionBuilder,
          (CategoryLearningData, $$CategoryLearningTableReferences),
          CategoryLearningData,
          PrefetchHooks Function({bool subCategoryId})
        > {
  $$CategoryLearningTableTableManager(
    _$AppDatabase db,
    $CategoryLearningTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CategoryLearningTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CategoryLearningTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CategoryLearningTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> merchantPattern = const Value.absent(),
                Value<String?> semanticTokens = const Value.absent(),
                Value<String> categoryName = const Value.absent(),
                Value<String?> subCategoryId = const Value.absent(),
                Value<int> confidenceBoost = const Value.absent(),
                Value<double> sourceWeight = const Value.absent(),
                Value<int> usageCount = const Value.absent(),
                Value<DateTime> lastUsedAt = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CategoryLearningCompanion(
                id: id,
                merchantPattern: merchantPattern,
                semanticTokens: semanticTokens,
                categoryName: categoryName,
                subCategoryId: subCategoryId,
                confidenceBoost: confidenceBoost,
                sourceWeight: sourceWeight,
                usageCount: usageCount,
                lastUsedAt: lastUsedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String merchantPattern,
                Value<String?> semanticTokens = const Value.absent(),
                required String categoryName,
                Value<String?> subCategoryId = const Value.absent(),
                Value<int> confidenceBoost = const Value.absent(),
                Value<double> sourceWeight = const Value.absent(),
                Value<int> usageCount = const Value.absent(),
                required DateTime lastUsedAt,
                Value<DateTime> createdAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CategoryLearningCompanion.insert(
                id: id,
                merchantPattern: merchantPattern,
                semanticTokens: semanticTokens,
                categoryName: categoryName,
                subCategoryId: subCategoryId,
                confidenceBoost: confidenceBoost,
                sourceWeight: sourceWeight,
                usageCount: usageCount,
                lastUsedAt: lastUsedAt,
                createdAt: createdAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CategoryLearningTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({subCategoryId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (subCategoryId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.subCategoryId,
                                referencedTable:
                                    $$CategoryLearningTableReferences
                                        ._subCategoryIdTable(db),
                                referencedColumn:
                                    $$CategoryLearningTableReferences
                                        ._subCategoryIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$CategoryLearningTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CategoryLearningTable,
      CategoryLearningData,
      $$CategoryLearningTableFilterComposer,
      $$CategoryLearningTableOrderingComposer,
      $$CategoryLearningTableAnnotationComposer,
      $$CategoryLearningTableCreateCompanionBuilder,
      $$CategoryLearningTableUpdateCompanionBuilder,
      (CategoryLearningData, $$CategoryLearningTableReferences),
      CategoryLearningData,
      PrefetchHooks Function({bool subCategoryId})
    >;
typedef $$SyncRecoveryStateTableCreateCompanionBuilder =
    SyncRecoveryStateCompanion Function({
      Value<int> id,
      required String currentState,
      Value<DateTime?> syncStartedAt,
      Value<DateTime?> lastSyncCompletedAt,
      Value<String?> syncReason,
      Value<String?> pendingOperations,
      Value<String?> lastError,
      Value<int> retryCount,
      required DateTime updatedAt,
    });
typedef $$SyncRecoveryStateTableUpdateCompanionBuilder =
    SyncRecoveryStateCompanion Function({
      Value<int> id,
      Value<String> currentState,
      Value<DateTime?> syncStartedAt,
      Value<DateTime?> lastSyncCompletedAt,
      Value<String?> syncReason,
      Value<String?> pendingOperations,
      Value<String?> lastError,
      Value<int> retryCount,
      Value<DateTime> updatedAt,
    });

class $$SyncRecoveryStateTableFilterComposer
    extends Composer<_$AppDatabase, $SyncRecoveryStateTable> {
  $$SyncRecoveryStateTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get currentState => $composableBuilder(
    column: $table.currentState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get syncStartedAt => $composableBuilder(
    column: $table.syncStartedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get lastSyncCompletedAt => $composableBuilder(
    column: $table.lastSyncCompletedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncReason => $composableBuilder(
    column: $table.syncReason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get pendingOperations => $composableBuilder(
    column: $table.pendingOperations,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastError => $composableBuilder(
    column: $table.lastError,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SyncRecoveryStateTableOrderingComposer
    extends Composer<_$AppDatabase, $SyncRecoveryStateTable> {
  $$SyncRecoveryStateTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get currentState => $composableBuilder(
    column: $table.currentState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get syncStartedAt => $composableBuilder(
    column: $table.syncStartedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get lastSyncCompletedAt => $composableBuilder(
    column: $table.lastSyncCompletedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncReason => $composableBuilder(
    column: $table.syncReason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get pendingOperations => $composableBuilder(
    column: $table.pendingOperations,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastError => $composableBuilder(
    column: $table.lastError,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SyncRecoveryStateTableAnnotationComposer
    extends Composer<_$AppDatabase, $SyncRecoveryStateTable> {
  $$SyncRecoveryStateTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get currentState => $composableBuilder(
    column: $table.currentState,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get syncStartedAt => $composableBuilder(
    column: $table.syncStartedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get lastSyncCompletedAt => $composableBuilder(
    column: $table.lastSyncCompletedAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncReason => $composableBuilder(
    column: $table.syncReason,
    builder: (column) => column,
  );

  GeneratedColumn<String> get pendingOperations => $composableBuilder(
    column: $table.pendingOperations,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastError =>
      $composableBuilder(column: $table.lastError, builder: (column) => column);

  GeneratedColumn<int> get retryCount => $composableBuilder(
    column: $table.retryCount,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$SyncRecoveryStateTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SyncRecoveryStateTable,
          SyncRecoveryStateData,
          $$SyncRecoveryStateTableFilterComposer,
          $$SyncRecoveryStateTableOrderingComposer,
          $$SyncRecoveryStateTableAnnotationComposer,
          $$SyncRecoveryStateTableCreateCompanionBuilder,
          $$SyncRecoveryStateTableUpdateCompanionBuilder,
          (
            SyncRecoveryStateData,
            BaseReferences<
              _$AppDatabase,
              $SyncRecoveryStateTable,
              SyncRecoveryStateData
            >,
          ),
          SyncRecoveryStateData,
          PrefetchHooks Function()
        > {
  $$SyncRecoveryStateTableTableManager(
    _$AppDatabase db,
    $SyncRecoveryStateTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SyncRecoveryStateTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SyncRecoveryStateTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SyncRecoveryStateTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> currentState = const Value.absent(),
                Value<DateTime?> syncStartedAt = const Value.absent(),
                Value<DateTime?> lastSyncCompletedAt = const Value.absent(),
                Value<String?> syncReason = const Value.absent(),
                Value<String?> pendingOperations = const Value.absent(),
                Value<String?> lastError = const Value.absent(),
                Value<int> retryCount = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
              }) => SyncRecoveryStateCompanion(
                id: id,
                currentState: currentState,
                syncStartedAt: syncStartedAt,
                lastSyncCompletedAt: lastSyncCompletedAt,
                syncReason: syncReason,
                pendingOperations: pendingOperations,
                lastError: lastError,
                retryCount: retryCount,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String currentState,
                Value<DateTime?> syncStartedAt = const Value.absent(),
                Value<DateTime?> lastSyncCompletedAt = const Value.absent(),
                Value<String?> syncReason = const Value.absent(),
                Value<String?> pendingOperations = const Value.absent(),
                Value<String?> lastError = const Value.absent(),
                Value<int> retryCount = const Value.absent(),
                required DateTime updatedAt,
              }) => SyncRecoveryStateCompanion.insert(
                id: id,
                currentState: currentState,
                syncStartedAt: syncStartedAt,
                lastSyncCompletedAt: lastSyncCompletedAt,
                syncReason: syncReason,
                pendingOperations: pendingOperations,
                lastError: lastError,
                retryCount: retryCount,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SyncRecoveryStateTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SyncRecoveryStateTable,
      SyncRecoveryStateData,
      $$SyncRecoveryStateTableFilterComposer,
      $$SyncRecoveryStateTableOrderingComposer,
      $$SyncRecoveryStateTableAnnotationComposer,
      $$SyncRecoveryStateTableCreateCompanionBuilder,
      $$SyncRecoveryStateTableUpdateCompanionBuilder,
      (
        SyncRecoveryStateData,
        BaseReferences<
          _$AppDatabase,
          $SyncRecoveryStateTable,
          SyncRecoveryStateData
        >,
      ),
      SyncRecoveryStateData,
      PrefetchHooks Function()
    >;
typedef $$SyncOperationsLogTableCreateCompanionBuilder =
    SyncOperationsLogCompanion Function({
      required String operationId,
      required String entityType,
      required String entityId,
      required String action,
      required String status,
      Value<String?> deviceId,
      required DateTime timestamp,
      Value<DateTime?> completedAt,
      Value<String?> errorMessage,
      Value<String?> metadata,
      Value<int> rowid,
    });
typedef $$SyncOperationsLogTableUpdateCompanionBuilder =
    SyncOperationsLogCompanion Function({
      Value<String> operationId,
      Value<String> entityType,
      Value<String> entityId,
      Value<String> action,
      Value<String> status,
      Value<String?> deviceId,
      Value<DateTime> timestamp,
      Value<DateTime?> completedAt,
      Value<String?> errorMessage,
      Value<String?> metadata,
      Value<int> rowid,
    });

class $$SyncOperationsLogTableFilterComposer
    extends Composer<_$AppDatabase, $SyncOperationsLogTable> {
  $$SyncOperationsLogTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get deviceId => $composableBuilder(
    column: $table.deviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get errorMessage => $composableBuilder(
    column: $table.errorMessage,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SyncOperationsLogTableOrderingComposer
    extends Composer<_$AppDatabase, $SyncOperationsLogTable> {
  $$SyncOperationsLogTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get action => $composableBuilder(
    column: $table.action,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get deviceId => $composableBuilder(
    column: $table.deviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get errorMessage => $composableBuilder(
    column: $table.errorMessage,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SyncOperationsLogTableAnnotationComposer
    extends Composer<_$AppDatabase, $SyncOperationsLogTable> {
  $$SyncOperationsLogTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityId =>
      $composableBuilder(column: $table.entityId, builder: (column) => column);

  GeneratedColumn<String> get action =>
      $composableBuilder(column: $table.action, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<String> get deviceId =>
      $composableBuilder(column: $table.deviceId, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get errorMessage => $composableBuilder(
    column: $table.errorMessage,
    builder: (column) => column,
  );

  GeneratedColumn<String> get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);
}

class $$SyncOperationsLogTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SyncOperationsLogTable,
          SyncOperationLog,
          $$SyncOperationsLogTableFilterComposer,
          $$SyncOperationsLogTableOrderingComposer,
          $$SyncOperationsLogTableAnnotationComposer,
          $$SyncOperationsLogTableCreateCompanionBuilder,
          $$SyncOperationsLogTableUpdateCompanionBuilder,
          (
            SyncOperationLog,
            BaseReferences<
              _$AppDatabase,
              $SyncOperationsLogTable,
              SyncOperationLog
            >,
          ),
          SyncOperationLog,
          PrefetchHooks Function()
        > {
  $$SyncOperationsLogTableTableManager(
    _$AppDatabase db,
    $SyncOperationsLogTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SyncOperationsLogTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SyncOperationsLogTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SyncOperationsLogTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> operationId = const Value.absent(),
                Value<String> entityType = const Value.absent(),
                Value<String> entityId = const Value.absent(),
                Value<String> action = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<String?> deviceId = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
                Value<DateTime?> completedAt = const Value.absent(),
                Value<String?> errorMessage = const Value.absent(),
                Value<String?> metadata = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SyncOperationsLogCompanion(
                operationId: operationId,
                entityType: entityType,
                entityId: entityId,
                action: action,
                status: status,
                deviceId: deviceId,
                timestamp: timestamp,
                completedAt: completedAt,
                errorMessage: errorMessage,
                metadata: metadata,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String operationId,
                required String entityType,
                required String entityId,
                required String action,
                required String status,
                Value<String?> deviceId = const Value.absent(),
                required DateTime timestamp,
                Value<DateTime?> completedAt = const Value.absent(),
                Value<String?> errorMessage = const Value.absent(),
                Value<String?> metadata = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SyncOperationsLogCompanion.insert(
                operationId: operationId,
                entityType: entityType,
                entityId: entityId,
                action: action,
                status: status,
                deviceId: deviceId,
                timestamp: timestamp,
                completedAt: completedAt,
                errorMessage: errorMessage,
                metadata: metadata,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SyncOperationsLogTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SyncOperationsLogTable,
      SyncOperationLog,
      $$SyncOperationsLogTableFilterComposer,
      $$SyncOperationsLogTableOrderingComposer,
      $$SyncOperationsLogTableAnnotationComposer,
      $$SyncOperationsLogTableCreateCompanionBuilder,
      $$SyncOperationsLogTableUpdateCompanionBuilder,
      (
        SyncOperationLog,
        BaseReferences<
          _$AppDatabase,
          $SyncOperationsLogTable,
          SyncOperationLog
        >,
      ),
      SyncOperationLog,
      PrefetchHooks Function()
    >;
typedef $$SyncStateTransitionsTableCreateCompanionBuilder =
    SyncStateTransitionsCompanion Function({
      Value<int> id,
      required String fromState,
      required String toState,
      required String reason,
      Value<String?> sessionId,
      required DateTime timestamp,
      Value<String?> context,
    });
typedef $$SyncStateTransitionsTableUpdateCompanionBuilder =
    SyncStateTransitionsCompanion Function({
      Value<int> id,
      Value<String> fromState,
      Value<String> toState,
      Value<String> reason,
      Value<String?> sessionId,
      Value<DateTime> timestamp,
      Value<String?> context,
    });

class $$SyncStateTransitionsTableFilterComposer
    extends Composer<_$AppDatabase, $SyncStateTransitionsTable> {
  $$SyncStateTransitionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get fromState => $composableBuilder(
    column: $table.fromState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get toState => $composableBuilder(
    column: $table.toState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sessionId => $composableBuilder(
    column: $table.sessionId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get context => $composableBuilder(
    column: $table.context,
    builder: (column) => ColumnFilters(column),
  );
}

class $$SyncStateTransitionsTableOrderingComposer
    extends Composer<_$AppDatabase, $SyncStateTransitionsTable> {
  $$SyncStateTransitionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get fromState => $composableBuilder(
    column: $table.fromState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get toState => $composableBuilder(
    column: $table.toState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get reason => $composableBuilder(
    column: $table.reason,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sessionId => $composableBuilder(
    column: $table.sessionId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get context => $composableBuilder(
    column: $table.context,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SyncStateTransitionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SyncStateTransitionsTable> {
  $$SyncStateTransitionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get fromState =>
      $composableBuilder(column: $table.fromState, builder: (column) => column);

  GeneratedColumn<String> get toState =>
      $composableBuilder(column: $table.toState, builder: (column) => column);

  GeneratedColumn<String> get reason =>
      $composableBuilder(column: $table.reason, builder: (column) => column);

  GeneratedColumn<String> get sessionId =>
      $composableBuilder(column: $table.sessionId, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<String> get context =>
      $composableBuilder(column: $table.context, builder: (column) => column);
}

class $$SyncStateTransitionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SyncStateTransitionsTable,
          SyncStateTransition,
          $$SyncStateTransitionsTableFilterComposer,
          $$SyncStateTransitionsTableOrderingComposer,
          $$SyncStateTransitionsTableAnnotationComposer,
          $$SyncStateTransitionsTableCreateCompanionBuilder,
          $$SyncStateTransitionsTableUpdateCompanionBuilder,
          (
            SyncStateTransition,
            BaseReferences<
              _$AppDatabase,
              $SyncStateTransitionsTable,
              SyncStateTransition
            >,
          ),
          SyncStateTransition,
          PrefetchHooks Function()
        > {
  $$SyncStateTransitionsTableTableManager(
    _$AppDatabase db,
    $SyncStateTransitionsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SyncStateTransitionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SyncStateTransitionsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$SyncStateTransitionsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> fromState = const Value.absent(),
                Value<String> toState = const Value.absent(),
                Value<String> reason = const Value.absent(),
                Value<String?> sessionId = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
                Value<String?> context = const Value.absent(),
              }) => SyncStateTransitionsCompanion(
                id: id,
                fromState: fromState,
                toState: toState,
                reason: reason,
                sessionId: sessionId,
                timestamp: timestamp,
                context: context,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String fromState,
                required String toState,
                required String reason,
                Value<String?> sessionId = const Value.absent(),
                required DateTime timestamp,
                Value<String?> context = const Value.absent(),
              }) => SyncStateTransitionsCompanion.insert(
                id: id,
                fromState: fromState,
                toState: toState,
                reason: reason,
                sessionId: sessionId,
                timestamp: timestamp,
                context: context,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$SyncStateTransitionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SyncStateTransitionsTable,
      SyncStateTransition,
      $$SyncStateTransitionsTableFilterComposer,
      $$SyncStateTransitionsTableOrderingComposer,
      $$SyncStateTransitionsTableAnnotationComposer,
      $$SyncStateTransitionsTableCreateCompanionBuilder,
      $$SyncStateTransitionsTableUpdateCompanionBuilder,
      (
        SyncStateTransition,
        BaseReferences<
          _$AppDatabase,
          $SyncStateTransitionsTable,
          SyncStateTransition
        >,
      ),
      SyncStateTransition,
      PrefetchHooks Function()
    >;
typedef $$FamilyGroupsTableCreateCompanionBuilder =
    FamilyGroupsCompanion Function({
      required String id,
      required String name,
      required String ownerId,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$FamilyGroupsTableUpdateCompanionBuilder =
    FamilyGroupsCompanion Function({
      Value<String> id,
      Value<String> name,
      Value<String> ownerId,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$FamilyGroupsTableReferences
    extends BaseReferences<_$AppDatabase, $FamilyGroupsTable, FamilyGroup> {
  $$FamilyGroupsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _ownerIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.familyGroups.ownerId, db.users.id),
  );

  $$UsersTableProcessedTableManager get ownerId {
    final $_column = $_itemColumn<String>('owner_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_ownerIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FamilyGroupsTableFilterComposer
    extends Composer<_$AppDatabase, $FamilyGroupsTable> {
  $$FamilyGroupsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get ownerId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FamilyGroupsTableOrderingComposer
    extends Composer<_$AppDatabase, $FamilyGroupsTable> {
  $$FamilyGroupsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get ownerId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FamilyGroupsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FamilyGroupsTable> {
  $$FamilyGroupsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get ownerId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.ownerId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FamilyGroupsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FamilyGroupsTable,
          FamilyGroup,
          $$FamilyGroupsTableFilterComposer,
          $$FamilyGroupsTableOrderingComposer,
          $$FamilyGroupsTableAnnotationComposer,
          $$FamilyGroupsTableCreateCompanionBuilder,
          $$FamilyGroupsTableUpdateCompanionBuilder,
          (FamilyGroup, $$FamilyGroupsTableReferences),
          FamilyGroup,
          PrefetchHooks Function({bool ownerId})
        > {
  $$FamilyGroupsTableTableManager(_$AppDatabase db, $FamilyGroupsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FamilyGroupsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FamilyGroupsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FamilyGroupsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> ownerId = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FamilyGroupsCompanion(
                id: id,
                name: name,
                ownerId: ownerId,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String name,
                required String ownerId,
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FamilyGroupsCompanion.insert(
                id: id,
                name: name,
                ownerId: ownerId,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$FamilyGroupsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({ownerId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (ownerId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.ownerId,
                                referencedTable: $$FamilyGroupsTableReferences
                                    ._ownerIdTable(db),
                                referencedColumn: $$FamilyGroupsTableReferences
                                    ._ownerIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$FamilyGroupsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FamilyGroupsTable,
      FamilyGroup,
      $$FamilyGroupsTableFilterComposer,
      $$FamilyGroupsTableOrderingComposer,
      $$FamilyGroupsTableAnnotationComposer,
      $$FamilyGroupsTableCreateCompanionBuilder,
      $$FamilyGroupsTableUpdateCompanionBuilder,
      (FamilyGroup, $$FamilyGroupsTableReferences),
      FamilyGroup,
      PrefetchHooks Function({bool ownerId})
    >;
typedef $$FamilyContactsTableCreateCompanionBuilder =
    FamilyContactsCompanion Function({
      required String id,
      Value<String?> deviceContactId,
      required String name,
      Value<String?> email,
      Value<String?> phone,
      Value<String?> avatarUrl,
      Value<bool> isLinkedToUser,
      Value<String?> linkedUserId,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$FamilyContactsTableUpdateCompanionBuilder =
    FamilyContactsCompanion Function({
      Value<String> id,
      Value<String?> deviceContactId,
      Value<String> name,
      Value<String?> email,
      Value<String?> phone,
      Value<String?> avatarUrl,
      Value<bool> isLinkedToUser,
      Value<String?> linkedUserId,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$FamilyContactsTableReferences
    extends BaseReferences<_$AppDatabase, $FamilyContactsTable, FamilyContact> {
  $$FamilyContactsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $UsersTable _linkedUserIdTable(_$AppDatabase db) =>
      db.users.createAlias(
        $_aliasNameGenerator(db.familyContacts.linkedUserId, db.users.id),
      );

  $$UsersTableProcessedTableManager? get linkedUserId {
    final $_column = $_itemColumn<String>('linked_user_id');
    if ($_column == null) return null;
    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_linkedUserIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FamilyContactsTableFilterComposer
    extends Composer<_$AppDatabase, $FamilyContactsTable> {
  $$FamilyContactsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get deviceContactId => $composableBuilder(
    column: $table.deviceContactId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get avatarUrl => $composableBuilder(
    column: $table.avatarUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isLinkedToUser => $composableBuilder(
    column: $table.isLinkedToUser,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get linkedUserId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.linkedUserId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FamilyContactsTableOrderingComposer
    extends Composer<_$AppDatabase, $FamilyContactsTable> {
  $$FamilyContactsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get deviceContactId => $composableBuilder(
    column: $table.deviceContactId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get email => $composableBuilder(
    column: $table.email,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get phone => $composableBuilder(
    column: $table.phone,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get avatarUrl => $composableBuilder(
    column: $table.avatarUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isLinkedToUser => $composableBuilder(
    column: $table.isLinkedToUser,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get linkedUserId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.linkedUserId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FamilyContactsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FamilyContactsTable> {
  $$FamilyContactsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get deviceContactId => $composableBuilder(
    column: $table.deviceContactId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get email =>
      $composableBuilder(column: $table.email, builder: (column) => column);

  GeneratedColumn<String> get phone =>
      $composableBuilder(column: $table.phone, builder: (column) => column);

  GeneratedColumn<String> get avatarUrl =>
      $composableBuilder(column: $table.avatarUrl, builder: (column) => column);

  GeneratedColumn<bool> get isLinkedToUser => $composableBuilder(
    column: $table.isLinkedToUser,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get linkedUserId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.linkedUserId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FamilyContactsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FamilyContactsTable,
          FamilyContact,
          $$FamilyContactsTableFilterComposer,
          $$FamilyContactsTableOrderingComposer,
          $$FamilyContactsTableAnnotationComposer,
          $$FamilyContactsTableCreateCompanionBuilder,
          $$FamilyContactsTableUpdateCompanionBuilder,
          (FamilyContact, $$FamilyContactsTableReferences),
          FamilyContact,
          PrefetchHooks Function({bool linkedUserId})
        > {
  $$FamilyContactsTableTableManager(
    _$AppDatabase db,
    $FamilyContactsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FamilyContactsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FamilyContactsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FamilyContactsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String?> deviceContactId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String?> email = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> avatarUrl = const Value.absent(),
                Value<bool> isLinkedToUser = const Value.absent(),
                Value<String?> linkedUserId = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FamilyContactsCompanion(
                id: id,
                deviceContactId: deviceContactId,
                name: name,
                email: email,
                phone: phone,
                avatarUrl: avatarUrl,
                isLinkedToUser: isLinkedToUser,
                linkedUserId: linkedUserId,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                Value<String?> deviceContactId = const Value.absent(),
                required String name,
                Value<String?> email = const Value.absent(),
                Value<String?> phone = const Value.absent(),
                Value<String?> avatarUrl = const Value.absent(),
                Value<bool> isLinkedToUser = const Value.absent(),
                Value<String?> linkedUserId = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FamilyContactsCompanion.insert(
                id: id,
                deviceContactId: deviceContactId,
                name: name,
                email: email,
                phone: phone,
                avatarUrl: avatarUrl,
                isLinkedToUser: isLinkedToUser,
                linkedUserId: linkedUserId,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$FamilyContactsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({linkedUserId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (linkedUserId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.linkedUserId,
                                referencedTable: $$FamilyContactsTableReferences
                                    ._linkedUserIdTable(db),
                                referencedColumn:
                                    $$FamilyContactsTableReferences
                                        ._linkedUserIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$FamilyContactsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FamilyContactsTable,
      FamilyContact,
      $$FamilyContactsTableFilterComposer,
      $$FamilyContactsTableOrderingComposer,
      $$FamilyContactsTableAnnotationComposer,
      $$FamilyContactsTableCreateCompanionBuilder,
      $$FamilyContactsTableUpdateCompanionBuilder,
      (FamilyContact, $$FamilyContactsTableReferences),
      FamilyContact,
      PrefetchHooks Function({bool linkedUserId})
    >;
typedef $$FamilyRelationsTableCreateCompanionBuilder =
    FamilyRelationsCompanion Function({
      required String id,
      required String fromContactId,
      required String toContactId,
      required String relationshipType,
      Value<double> confidence,
      Value<String> inferredBy,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$FamilyRelationsTableUpdateCompanionBuilder =
    FamilyRelationsCompanion Function({
      Value<String> id,
      Value<String> fromContactId,
      Value<String> toContactId,
      Value<String> relationshipType,
      Value<double> confidence,
      Value<String> inferredBy,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$FamilyRelationsTableReferences
    extends
        BaseReferences<_$AppDatabase, $FamilyRelationsTable, FamilyRelation> {
  $$FamilyRelationsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $FamilyContactsTable _fromContactIdTable(_$AppDatabase db) =>
      db.familyContacts.createAlias(
        $_aliasNameGenerator(
          db.familyRelations.fromContactId,
          db.familyContacts.id,
        ),
      );

  $$FamilyContactsTableProcessedTableManager get fromContactId {
    final $_column = $_itemColumn<String>('from_contact_id')!;

    final manager = $$FamilyContactsTableTableManager(
      $_db,
      $_db.familyContacts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_fromContactIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $FamilyContactsTable _toContactIdTable(_$AppDatabase db) =>
      db.familyContacts.createAlias(
        $_aliasNameGenerator(
          db.familyRelations.toContactId,
          db.familyContacts.id,
        ),
      );

  $$FamilyContactsTableProcessedTableManager get toContactId {
    final $_column = $_itemColumn<String>('to_contact_id')!;

    final manager = $$FamilyContactsTableTableManager(
      $_db,
      $_db.familyContacts,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_toContactIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$FamilyRelationsTableFilterComposer
    extends Composer<_$AppDatabase, $FamilyRelationsTable> {
  $$FamilyRelationsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get relationshipType => $composableBuilder(
    column: $table.relationshipType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get confidence => $composableBuilder(
    column: $table.confidence,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get inferredBy => $composableBuilder(
    column: $table.inferredBy,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  $$FamilyContactsTableFilterComposer get fromContactId {
    final $$FamilyContactsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fromContactId,
      referencedTable: $db.familyContacts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyContactsTableFilterComposer(
            $db: $db,
            $table: $db.familyContacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FamilyContactsTableFilterComposer get toContactId {
    final $$FamilyContactsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.toContactId,
      referencedTable: $db.familyContacts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyContactsTableFilterComposer(
            $db: $db,
            $table: $db.familyContacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FamilyRelationsTableOrderingComposer
    extends Composer<_$AppDatabase, $FamilyRelationsTable> {
  $$FamilyRelationsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get relationshipType => $composableBuilder(
    column: $table.relationshipType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get confidence => $composableBuilder(
    column: $table.confidence,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get inferredBy => $composableBuilder(
    column: $table.inferredBy,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  $$FamilyContactsTableOrderingComposer get fromContactId {
    final $$FamilyContactsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fromContactId,
      referencedTable: $db.familyContacts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyContactsTableOrderingComposer(
            $db: $db,
            $table: $db.familyContacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FamilyContactsTableOrderingComposer get toContactId {
    final $$FamilyContactsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.toContactId,
      referencedTable: $db.familyContacts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyContactsTableOrderingComposer(
            $db: $db,
            $table: $db.familyContacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FamilyRelationsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FamilyRelationsTable> {
  $$FamilyRelationsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get relationshipType => $composableBuilder(
    column: $table.relationshipType,
    builder: (column) => column,
  );

  GeneratedColumn<double> get confidence => $composableBuilder(
    column: $table.confidence,
    builder: (column) => column,
  );

  GeneratedColumn<String> get inferredBy => $composableBuilder(
    column: $table.inferredBy,
    builder: (column) => column,
  );

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  $$FamilyContactsTableAnnotationComposer get fromContactId {
    final $$FamilyContactsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.fromContactId,
      referencedTable: $db.familyContacts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyContactsTableAnnotationComposer(
            $db: $db,
            $table: $db.familyContacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$FamilyContactsTableAnnotationComposer get toContactId {
    final $$FamilyContactsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.toContactId,
      referencedTable: $db.familyContacts,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$FamilyContactsTableAnnotationComposer(
            $db: $db,
            $table: $db.familyContacts,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$FamilyRelationsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FamilyRelationsTable,
          FamilyRelation,
          $$FamilyRelationsTableFilterComposer,
          $$FamilyRelationsTableOrderingComposer,
          $$FamilyRelationsTableAnnotationComposer,
          $$FamilyRelationsTableCreateCompanionBuilder,
          $$FamilyRelationsTableUpdateCompanionBuilder,
          (FamilyRelation, $$FamilyRelationsTableReferences),
          FamilyRelation,
          PrefetchHooks Function({bool fromContactId, bool toContactId})
        > {
  $$FamilyRelationsTableTableManager(
    _$AppDatabase db,
    $FamilyRelationsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FamilyRelationsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FamilyRelationsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FamilyRelationsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> fromContactId = const Value.absent(),
                Value<String> toContactId = const Value.absent(),
                Value<String> relationshipType = const Value.absent(),
                Value<double> confidence = const Value.absent(),
                Value<String> inferredBy = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FamilyRelationsCompanion(
                id: id,
                fromContactId: fromContactId,
                toContactId: toContactId,
                relationshipType: relationshipType,
                confidence: confidence,
                inferredBy: inferredBy,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String fromContactId,
                required String toContactId,
                required String relationshipType,
                Value<double> confidence = const Value.absent(),
                Value<String> inferredBy = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FamilyRelationsCompanion.insert(
                id: id,
                fromContactId: fromContactId,
                toContactId: toContactId,
                relationshipType: relationshipType,
                confidence: confidence,
                inferredBy: inferredBy,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$FamilyRelationsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback:
              ({fromContactId = false, toContactId = false}) {
                return PrefetchHooks(
                  db: db,
                  explicitlyWatchedTables: [],
                  addJoins:
                      <
                        T extends TableManagerState<
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic,
                          dynamic
                        >
                      >(state) {
                        if (fromContactId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.fromContactId,
                                    referencedTable:
                                        $$FamilyRelationsTableReferences
                                            ._fromContactIdTable(db),
                                    referencedColumn:
                                        $$FamilyRelationsTableReferences
                                            ._fromContactIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }
                        if (toContactId) {
                          state =
                              state.withJoin(
                                    currentTable: table,
                                    currentColumn: table.toContactId,
                                    referencedTable:
                                        $$FamilyRelationsTableReferences
                                            ._toContactIdTable(db),
                                    referencedColumn:
                                        $$FamilyRelationsTableReferences
                                            ._toContactIdTable(db)
                                            .id,
                                  )
                                  as T;
                        }

                        return state;
                      },
                  getPrefetchedDataCallback: (items) async {
                    return [];
                  },
                );
              },
        ),
      );
}

typedef $$FamilyRelationsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FamilyRelationsTable,
      FamilyRelation,
      $$FamilyRelationsTableFilterComposer,
      $$FamilyRelationsTableOrderingComposer,
      $$FamilyRelationsTableAnnotationComposer,
      $$FamilyRelationsTableCreateCompanionBuilder,
      $$FamilyRelationsTableUpdateCompanionBuilder,
      (FamilyRelation, $$FamilyRelationsTableReferences),
      FamilyRelation,
      PrefetchHooks Function({bool fromContactId, bool toContactId})
    >;
typedef $$KnowledgeArticlesTableCreateCompanionBuilder =
    KnowledgeArticlesCompanion Function({
      required String id,
      required String title,
      required String summary,
      required String content,
      required String topic,
      Value<String?> tags,
      Value<String?> imageUrl,
      Value<int> readTimeMinutes,
      Value<String> languageCode,
      Value<bool> isPremium,
      Value<DateTime> publishedAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$KnowledgeArticlesTableUpdateCompanionBuilder =
    KnowledgeArticlesCompanion Function({
      Value<String> id,
      Value<String> title,
      Value<String> summary,
      Value<String> content,
      Value<String> topic,
      Value<String?> tags,
      Value<String?> imageUrl,
      Value<int> readTimeMinutes,
      Value<String> languageCode,
      Value<bool> isPremium,
      Value<DateTime> publishedAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

class $$KnowledgeArticlesTableFilterComposer
    extends Composer<_$AppDatabase, $KnowledgeArticlesTable> {
  $$KnowledgeArticlesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get summary => $composableBuilder(
    column: $table.summary,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get content => $composableBuilder(
    column: $table.content,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get topic => $composableBuilder(
    column: $table.topic,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get tags => $composableBuilder(
    column: $table.tags,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get readTimeMinutes => $composableBuilder(
    column: $table.readTimeMinutes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get languageCode => $composableBuilder(
    column: $table.languageCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isPremium => $composableBuilder(
    column: $table.isPremium,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get publishedAt => $composableBuilder(
    column: $table.publishedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );
}

class $$KnowledgeArticlesTableOrderingComposer
    extends Composer<_$AppDatabase, $KnowledgeArticlesTable> {
  $$KnowledgeArticlesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get summary => $composableBuilder(
    column: $table.summary,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get content => $composableBuilder(
    column: $table.content,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get topic => $composableBuilder(
    column: $table.topic,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get tags => $composableBuilder(
    column: $table.tags,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imageUrl => $composableBuilder(
    column: $table.imageUrl,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get readTimeMinutes => $composableBuilder(
    column: $table.readTimeMinutes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get languageCode => $composableBuilder(
    column: $table.languageCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isPremium => $composableBuilder(
    column: $table.isPremium,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get publishedAt => $composableBuilder(
    column: $table.publishedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$KnowledgeArticlesTableAnnotationComposer
    extends Composer<_$AppDatabase, $KnowledgeArticlesTable> {
  $$KnowledgeArticlesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get summary =>
      $composableBuilder(column: $table.summary, builder: (column) => column);

  GeneratedColumn<String> get content =>
      $composableBuilder(column: $table.content, builder: (column) => column);

  GeneratedColumn<String> get topic =>
      $composableBuilder(column: $table.topic, builder: (column) => column);

  GeneratedColumn<String> get tags =>
      $composableBuilder(column: $table.tags, builder: (column) => column);

  GeneratedColumn<String> get imageUrl =>
      $composableBuilder(column: $table.imageUrl, builder: (column) => column);

  GeneratedColumn<int> get readTimeMinutes => $composableBuilder(
    column: $table.readTimeMinutes,
    builder: (column) => column,
  );

  GeneratedColumn<String> get languageCode => $composableBuilder(
    column: $table.languageCode,
    builder: (column) => column,
  );

  GeneratedColumn<bool> get isPremium =>
      $composableBuilder(column: $table.isPremium, builder: (column) => column);

  GeneratedColumn<DateTime> get publishedAt => $composableBuilder(
    column: $table.publishedAt,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => column,
  );

  GeneratedColumn<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );
}

class $$KnowledgeArticlesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $KnowledgeArticlesTable,
          KnowledgeArticleData,
          $$KnowledgeArticlesTableFilterComposer,
          $$KnowledgeArticlesTableOrderingComposer,
          $$KnowledgeArticlesTableAnnotationComposer,
          $$KnowledgeArticlesTableCreateCompanionBuilder,
          $$KnowledgeArticlesTableUpdateCompanionBuilder,
          (
            KnowledgeArticleData,
            BaseReferences<
              _$AppDatabase,
              $KnowledgeArticlesTable,
              KnowledgeArticleData
            >,
          ),
          KnowledgeArticleData,
          PrefetchHooks Function()
        > {
  $$KnowledgeArticlesTableTableManager(
    _$AppDatabase db,
    $KnowledgeArticlesTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$KnowledgeArticlesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$KnowledgeArticlesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$KnowledgeArticlesTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<String> summary = const Value.absent(),
                Value<String> content = const Value.absent(),
                Value<String> topic = const Value.absent(),
                Value<String?> tags = const Value.absent(),
                Value<String?> imageUrl = const Value.absent(),
                Value<int> readTimeMinutes = const Value.absent(),
                Value<String> languageCode = const Value.absent(),
                Value<bool> isPremium = const Value.absent(),
                Value<DateTime> publishedAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => KnowledgeArticlesCompanion(
                id: id,
                title: title,
                summary: summary,
                content: content,
                topic: topic,
                tags: tags,
                imageUrl: imageUrl,
                readTimeMinutes: readTimeMinutes,
                languageCode: languageCode,
                isPremium: isPremium,
                publishedAt: publishedAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String title,
                required String summary,
                required String content,
                required String topic,
                Value<String?> tags = const Value.absent(),
                Value<String?> imageUrl = const Value.absent(),
                Value<int> readTimeMinutes = const Value.absent(),
                Value<String> languageCode = const Value.absent(),
                Value<bool> isPremium = const Value.absent(),
                Value<DateTime> publishedAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => KnowledgeArticlesCompanion.insert(
                id: id,
                title: title,
                summary: summary,
                content: content,
                topic: topic,
                tags: tags,
                imageUrl: imageUrl,
                readTimeMinutes: readTimeMinutes,
                languageCode: languageCode,
                isPremium: isPremium,
                publishedAt: publishedAt,
                updatedAt: updatedAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$KnowledgeArticlesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $KnowledgeArticlesTable,
      KnowledgeArticleData,
      $$KnowledgeArticlesTableFilterComposer,
      $$KnowledgeArticlesTableOrderingComposer,
      $$KnowledgeArticlesTableAnnotationComposer,
      $$KnowledgeArticlesTableCreateCompanionBuilder,
      $$KnowledgeArticlesTableUpdateCompanionBuilder,
      (
        KnowledgeArticleData,
        BaseReferences<
          _$AppDatabase,
          $KnowledgeArticlesTable,
          KnowledgeArticleData
        >,
      ),
      KnowledgeArticleData,
      PrefetchHooks Function()
    >;
typedef $$FinancialTipsTableCreateCompanionBuilder =
    FinancialTipsCompanion Function({
      required String id,
      required String title,
      required String content,
      required String category,
      required String type,
      Value<String?> actionLabel,
      Value<String?> actionRoute,
      Value<String> languageCode,
      Value<DateTime> createdAt,
      Value<DateTime?> expiresAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$FinancialTipsTableUpdateCompanionBuilder =
    FinancialTipsCompanion Function({
      Value<String> id,
      Value<String> title,
      Value<String> content,
      Value<String> category,
      Value<String> type,
      Value<String?> actionLabel,
      Value<String?> actionRoute,
      Value<String> languageCode,
      Value<DateTime> createdAt,
      Value<DateTime?> expiresAt,
      Value<int> revision,
      Value<int?> baseRevision,
      Value<String?> operationId,
      Value<String?> lastModifiedByDeviceId,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

class $$FinancialTipsTableFilterComposer
    extends Composer<_$AppDatabase, $FinancialTipsTable> {
  $$FinancialTipsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get content => $composableBuilder(
    column: $table.content,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get actionLabel => $composableBuilder(
    column: $table.actionLabel,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get actionRoute => $composableBuilder(
    column: $table.actionRoute,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get languageCode => $composableBuilder(
    column: $table.languageCode,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );
}

class $$FinancialTipsTableOrderingComposer
    extends Composer<_$AppDatabase, $FinancialTipsTable> {
  $$FinancialTipsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get title => $composableBuilder(
    column: $table.title,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get content => $composableBuilder(
    column: $table.content,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get category => $composableBuilder(
    column: $table.category,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get actionLabel => $composableBuilder(
    column: $table.actionLabel,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get actionRoute => $composableBuilder(
    column: $table.actionRoute,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get languageCode => $composableBuilder(
    column: $table.languageCode,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FinancialTipsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FinancialTipsTable> {
  $$FinancialTipsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get title =>
      $composableBuilder(column: $table.title, builder: (column) => column);

  GeneratedColumn<String> get content =>
      $composableBuilder(column: $table.content, builder: (column) => column);

  GeneratedColumn<String> get category =>
      $composableBuilder(column: $table.category, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get actionLabel => $composableBuilder(
    column: $table.actionLabel,
    builder: (column) => column,
  );

  GeneratedColumn<String> get actionRoute => $composableBuilder(
    column: $table.actionRoute,
    builder: (column) => column,
  );

  GeneratedColumn<String> get languageCode => $composableBuilder(
    column: $table.languageCode,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<int> get baseRevision => $composableBuilder(
    column: $table.baseRevision,
    builder: (column) => column,
  );

  GeneratedColumn<String> get operationId => $composableBuilder(
    column: $table.operationId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get lastModifiedByDeviceId => $composableBuilder(
    column: $table.lastModifiedByDeviceId,
    builder: (column) => column,
  );

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );
}

class $$FinancialTipsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FinancialTipsTable,
          FinancialTipData,
          $$FinancialTipsTableFilterComposer,
          $$FinancialTipsTableOrderingComposer,
          $$FinancialTipsTableAnnotationComposer,
          $$FinancialTipsTableCreateCompanionBuilder,
          $$FinancialTipsTableUpdateCompanionBuilder,
          (
            FinancialTipData,
            BaseReferences<
              _$AppDatabase,
              $FinancialTipsTable,
              FinancialTipData
            >,
          ),
          FinancialTipData,
          PrefetchHooks Function()
        > {
  $$FinancialTipsTableTableManager(_$AppDatabase db, $FinancialTipsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FinancialTipsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$FinancialTipsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$FinancialTipsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> title = const Value.absent(),
                Value<String> content = const Value.absent(),
                Value<String> category = const Value.absent(),
                Value<String> type = const Value.absent(),
                Value<String?> actionLabel = const Value.absent(),
                Value<String?> actionRoute = const Value.absent(),
                Value<String> languageCode = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> expiresAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FinancialTipsCompanion(
                id: id,
                title: title,
                content: content,
                category: category,
                type: type,
                actionLabel: actionLabel,
                actionRoute: actionRoute,
                languageCode: languageCode,
                createdAt: createdAt,
                expiresAt: expiresAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String title,
                required String content,
                required String category,
                required String type,
                Value<String?> actionLabel = const Value.absent(),
                Value<String?> actionRoute = const Value.absent(),
                Value<String> languageCode = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime?> expiresAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<int?> baseRevision = const Value.absent(),
                Value<String?> operationId = const Value.absent(),
                Value<String?> lastModifiedByDeviceId = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FinancialTipsCompanion.insert(
                id: id,
                title: title,
                content: content,
                category: category,
                type: type,
                actionLabel: actionLabel,
                actionRoute: actionRoute,
                languageCode: languageCode,
                createdAt: createdAt,
                expiresAt: expiresAt,
                revision: revision,
                baseRevision: baseRevision,
                operationId: operationId,
                lastModifiedByDeviceId: lastModifiedByDeviceId,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$FinancialTipsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FinancialTipsTable,
      FinancialTipData,
      $$FinancialTipsTableFilterComposer,
      $$FinancialTipsTableOrderingComposer,
      $$FinancialTipsTableAnnotationComposer,
      $$FinancialTipsTableCreateCompanionBuilder,
      $$FinancialTipsTableUpdateCompanionBuilder,
      (
        FinancialTipData,
        BaseReferences<_$AppDatabase, $FinancialTipsTable, FinancialTipData>,
      ),
      FinancialTipData,
      PrefetchHooks Function()
    >;
typedef $$AssetsTableCreateCompanionBuilder =
    AssetsCompanion Function({
      required String id,
      required String userId,
      required String name,
      required String type,
      required int currentValue,
      Value<String> currency,
      Value<bool> isAutomated,
      Value<String?> InstitutionName,
      Value<DateTime?> acquiredAt,
      Value<String?> notes,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$AssetsTableUpdateCompanionBuilder =
    AssetsCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String> name,
      Value<String> type,
      Value<int> currentValue,
      Value<String> currency,
      Value<bool> isAutomated,
      Value<String?> InstitutionName,
      Value<DateTime?> acquiredAt,
      Value<String?> notes,
      Value<Map<String, dynamic>?> metadata,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$AssetsTableReferences
    extends BaseReferences<_$AppDatabase, $AssetsTable, Asset> {
  $$AssetsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _userIdTable(_$AppDatabase db) =>
      db.users.createAlias($_aliasNameGenerator(db.assets.userId, db.users.id));

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$AssetsTableFilterComposer
    extends Composer<_$AppDatabase, $AssetsTable> {
  $$AssetsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get currentValue => $composableBuilder(
    column: $table.currentValue,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isAutomated => $composableBuilder(
    column: $table.isAutomated,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get InstitutionName => $composableBuilder(
    column: $table.InstitutionName,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get acquiredAt => $composableBuilder(
    column: $table.acquiredAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>?,
    Map<String, dynamic>,
    String
  >
  get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AssetsTableOrderingComposer
    extends Composer<_$AppDatabase, $AssetsTable> {
  $$AssetsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get currentValue => $composableBuilder(
    column: $table.currentValue,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isAutomated => $composableBuilder(
    column: $table.isAutomated,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get InstitutionName => $composableBuilder(
    column: $table.InstitutionName,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get acquiredAt => $composableBuilder(
    column: $table.acquiredAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metadata => $composableBuilder(
    column: $table.metadata,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AssetsTableAnnotationComposer
    extends Composer<_$AppDatabase, $AssetsTable> {
  $$AssetsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<int> get currentValue => $composableBuilder(
    column: $table.currentValue,
    builder: (column) => column,
  );

  GeneratedColumn<String> get currency =>
      $composableBuilder(column: $table.currency, builder: (column) => column);

  GeneratedColumn<bool> get isAutomated => $composableBuilder(
    column: $table.isAutomated,
    builder: (column) => column,
  );

  GeneratedColumn<String> get InstitutionName => $composableBuilder(
    column: $table.InstitutionName,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get acquiredAt => $composableBuilder(
    column: $table.acquiredAt,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>?, String>
  get metadata =>
      $composableBuilder(column: $table.metadata, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$AssetsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $AssetsTable,
          Asset,
          $$AssetsTableFilterComposer,
          $$AssetsTableOrderingComposer,
          $$AssetsTableAnnotationComposer,
          $$AssetsTableCreateCompanionBuilder,
          $$AssetsTableUpdateCompanionBuilder,
          (Asset, $$AssetsTableReferences),
          Asset,
          PrefetchHooks Function({bool userId})
        > {
  $$AssetsTableTableManager(_$AppDatabase db, $AssetsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$AssetsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$AssetsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$AssetsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> type = const Value.absent(),
                Value<int> currentValue = const Value.absent(),
                Value<String> currency = const Value.absent(),
                Value<bool> isAutomated = const Value.absent(),
                Value<String?> InstitutionName = const Value.absent(),
                Value<DateTime?> acquiredAt = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AssetsCompanion(
                id: id,
                userId: userId,
                name: name,
                type: type,
                currentValue: currentValue,
                currency: currency,
                isAutomated: isAutomated,
                InstitutionName: InstitutionName,
                acquiredAt: acquiredAt,
                notes: notes,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required String name,
                required String type,
                required int currentValue,
                Value<String> currency = const Value.absent(),
                Value<bool> isAutomated = const Value.absent(),
                Value<String?> InstitutionName = const Value.absent(),
                Value<DateTime?> acquiredAt = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<Map<String, dynamic>?> metadata = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => AssetsCompanion.insert(
                id: id,
                userId: userId,
                name: name,
                type: type,
                currentValue: currentValue,
                currency: currency,
                isAutomated: isAutomated,
                InstitutionName: InstitutionName,
                acquiredAt: acquiredAt,
                notes: notes,
                metadata: metadata,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$AssetsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable: $$AssetsTableReferences
                                    ._userIdTable(db),
                                referencedColumn: $$AssetsTableReferences
                                    ._userIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$AssetsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $AssetsTable,
      Asset,
      $$AssetsTableFilterComposer,
      $$AssetsTableOrderingComposer,
      $$AssetsTableAnnotationComposer,
      $$AssetsTableCreateCompanionBuilder,
      $$AssetsTableUpdateCompanionBuilder,
      (Asset, $$AssetsTableReferences),
      Asset,
      PrefetchHooks Function({bool userId})
    >;
typedef $$LiabilitiesTableCreateCompanionBuilder =
    LiabilitiesCompanion Function({
      required String id,
      required String userId,
      required String name,
      required String type,
      required int currentBalance,
      Value<String> currency,
      Value<double?> interestRate,
      Value<DateTime?> dueDate,
      Value<int?> minPayment,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });
typedef $$LiabilitiesTableUpdateCompanionBuilder =
    LiabilitiesCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String> name,
      Value<String> type,
      Value<int> currentBalance,
      Value<String> currency,
      Value<double?> interestRate,
      Value<DateTime?> dueDate,
      Value<int?> minPayment,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<bool> isDeleted,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<int> rowid,
    });

final class $$LiabilitiesTableReferences
    extends BaseReferences<_$AppDatabase, $LiabilitiesTable, Liability> {
  $$LiabilitiesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.liabilities.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$LiabilitiesTableFilterComposer
    extends Composer<_$AppDatabase, $LiabilitiesTable> {
  $$LiabilitiesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get currentBalance => $composableBuilder(
    column: $table.currentBalance,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get interestRate => $composableBuilder(
    column: $table.interestRate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get dueDate => $composableBuilder(
    column: $table.dueDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get minPayment => $composableBuilder(
    column: $table.minPayment,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LiabilitiesTableOrderingComposer
    extends Composer<_$AppDatabase, $LiabilitiesTable> {
  $$LiabilitiesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get currentBalance => $composableBuilder(
    column: $table.currentBalance,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get interestRate => $composableBuilder(
    column: $table.interestRate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get dueDate => $composableBuilder(
    column: $table.dueDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get minPayment => $composableBuilder(
    column: $table.minPayment,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<bool> get isDeleted => $composableBuilder(
    column: $table.isDeleted,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LiabilitiesTableAnnotationComposer
    extends Composer<_$AppDatabase, $LiabilitiesTable> {
  $$LiabilitiesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<int> get currentBalance => $composableBuilder(
    column: $table.currentBalance,
    builder: (column) => column,
  );

  GeneratedColumn<String> get currency =>
      $composableBuilder(column: $table.currency, builder: (column) => column);

  GeneratedColumn<double> get interestRate => $composableBuilder(
    column: $table.interestRate,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get dueDate =>
      $composableBuilder(column: $table.dueDate, builder: (column) => column);

  GeneratedColumn<int> get minPayment => $composableBuilder(
    column: $table.minPayment,
    builder: (column) => column,
  );

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  GeneratedColumn<bool> get isDeleted =>
      $composableBuilder(column: $table.isDeleted, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LiabilitiesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $LiabilitiesTable,
          Liability,
          $$LiabilitiesTableFilterComposer,
          $$LiabilitiesTableOrderingComposer,
          $$LiabilitiesTableAnnotationComposer,
          $$LiabilitiesTableCreateCompanionBuilder,
          $$LiabilitiesTableUpdateCompanionBuilder,
          (Liability, $$LiabilitiesTableReferences),
          Liability,
          PrefetchHooks Function({bool userId})
        > {
  $$LiabilitiesTableTableManager(_$AppDatabase db, $LiabilitiesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LiabilitiesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LiabilitiesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LiabilitiesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<String> type = const Value.absent(),
                Value<int> currentBalance = const Value.absent(),
                Value<String> currency = const Value.absent(),
                Value<double?> interestRate = const Value.absent(),
                Value<DateTime?> dueDate = const Value.absent(),
                Value<int?> minPayment = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LiabilitiesCompanion(
                id: id,
                userId: userId,
                name: name,
                type: type,
                currentBalance: currentBalance,
                currency: currency,
                interestRate: interestRate,
                dueDate: dueDate,
                minPayment: minPayment,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required String name,
                required String type,
                required int currentBalance,
                Value<String> currency = const Value.absent(),
                Value<double?> interestRate = const Value.absent(),
                Value<DateTime?> dueDate = const Value.absent(),
                Value<int?> minPayment = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<bool> isDeleted = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LiabilitiesCompanion.insert(
                id: id,
                userId: userId,
                name: name,
                type: type,
                currentBalance: currentBalance,
                currency: currency,
                interestRate: interestRate,
                dueDate: dueDate,
                minPayment: minPayment,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                isDeleted: isDeleted,
                lamportClock: lamportClock,
                versionVector: versionVector,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$LiabilitiesTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable: $$LiabilitiesTableReferences
                                    ._userIdTable(db),
                                referencedColumn: $$LiabilitiesTableReferences
                                    ._userIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$LiabilitiesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $LiabilitiesTable,
      Liability,
      $$LiabilitiesTableFilterComposer,
      $$LiabilitiesTableOrderingComposer,
      $$LiabilitiesTableAnnotationComposer,
      $$LiabilitiesTableCreateCompanionBuilder,
      $$LiabilitiesTableUpdateCompanionBuilder,
      (Liability, $$LiabilitiesTableReferences),
      Liability,
      PrefetchHooks Function({bool userId})
    >;
typedef $$ValuationHistoryTableCreateCompanionBuilder =
    ValuationHistoryCompanion Function({
      required String id,
      required String entityType,
      required String entityId,
      required int value,
      required DateTime date,
      Value<DateTime> recordedAt,
      Value<int> rowid,
    });
typedef $$ValuationHistoryTableUpdateCompanionBuilder =
    ValuationHistoryCompanion Function({
      Value<String> id,
      Value<String> entityType,
      Value<String> entityId,
      Value<int> value,
      Value<DateTime> date,
      Value<DateTime> recordedAt,
      Value<int> rowid,
    });

class $$ValuationHistoryTableFilterComposer
    extends Composer<_$AppDatabase, $ValuationHistoryTable> {
  $$ValuationHistoryTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get value => $composableBuilder(
    column: $table.value,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get recordedAt => $composableBuilder(
    column: $table.recordedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$ValuationHistoryTableOrderingComposer
    extends Composer<_$AppDatabase, $ValuationHistoryTable> {
  $$ValuationHistoryTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get value => $composableBuilder(
    column: $table.value,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get date => $composableBuilder(
    column: $table.date,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get recordedAt => $composableBuilder(
    column: $table.recordedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$ValuationHistoryTableAnnotationComposer
    extends Composer<_$AppDatabase, $ValuationHistoryTable> {
  $$ValuationHistoryTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityId =>
      $composableBuilder(column: $table.entityId, builder: (column) => column);

  GeneratedColumn<int> get value =>
      $composableBuilder(column: $table.value, builder: (column) => column);

  GeneratedColumn<DateTime> get date =>
      $composableBuilder(column: $table.date, builder: (column) => column);

  GeneratedColumn<DateTime> get recordedAt => $composableBuilder(
    column: $table.recordedAt,
    builder: (column) => column,
  );
}

class $$ValuationHistoryTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $ValuationHistoryTable,
          ValuationHistoryData,
          $$ValuationHistoryTableFilterComposer,
          $$ValuationHistoryTableOrderingComposer,
          $$ValuationHistoryTableAnnotationComposer,
          $$ValuationHistoryTableCreateCompanionBuilder,
          $$ValuationHistoryTableUpdateCompanionBuilder,
          (
            ValuationHistoryData,
            BaseReferences<
              _$AppDatabase,
              $ValuationHistoryTable,
              ValuationHistoryData
            >,
          ),
          ValuationHistoryData,
          PrefetchHooks Function()
        > {
  $$ValuationHistoryTableTableManager(
    _$AppDatabase db,
    $ValuationHistoryTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$ValuationHistoryTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$ValuationHistoryTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$ValuationHistoryTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> entityType = const Value.absent(),
                Value<String> entityId = const Value.absent(),
                Value<int> value = const Value.absent(),
                Value<DateTime> date = const Value.absent(),
                Value<DateTime> recordedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ValuationHistoryCompanion(
                id: id,
                entityType: entityType,
                entityId: entityId,
                value: value,
                date: date,
                recordedAt: recordedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String entityType,
                required String entityId,
                required int value,
                required DateTime date,
                Value<DateTime> recordedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => ValuationHistoryCompanion.insert(
                id: id,
                entityType: entityType,
                entityId: entityId,
                value: value,
                date: date,
                recordedAt: recordedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$ValuationHistoryTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $ValuationHistoryTable,
      ValuationHistoryData,
      $$ValuationHistoryTableFilterComposer,
      $$ValuationHistoryTableOrderingComposer,
      $$ValuationHistoryTableAnnotationComposer,
      $$ValuationHistoryTableCreateCompanionBuilder,
      $$ValuationHistoryTableUpdateCompanionBuilder,
      (
        ValuationHistoryData,
        BaseReferences<
          _$AppDatabase,
          $ValuationHistoryTable,
          ValuationHistoryData
        >,
      ),
      ValuationHistoryData,
      PrefetchHooks Function()
    >;
typedef $$LedgerEventsTableCreateCompanionBuilder =
    LedgerEventsCompanion Function({
      required String eventId,
      required String eventType,
      required String entityType,
      required String entityId,
      required String userId,
      Value<String?> deviceId,
      required Map<String, dynamic> eventData,
      Value<DateTime> timestamp,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<String?> previousEventHash,
      Value<String?> hash,
      Value<int> rowid,
    });
typedef $$LedgerEventsTableUpdateCompanionBuilder =
    LedgerEventsCompanion Function({
      Value<String> eventId,
      Value<String> eventType,
      Value<String> entityType,
      Value<String> entityId,
      Value<String> userId,
      Value<String?> deviceId,
      Value<Map<String, dynamic>> eventData,
      Value<DateTime> timestamp,
      Value<int> lamportClock,
      Value<String?> versionVector,
      Value<String?> previousEventHash,
      Value<String?> hash,
      Value<int> rowid,
    });

final class $$LedgerEventsTableReferences
    extends BaseReferences<_$AppDatabase, $LedgerEventsTable, LedgerEvent> {
  $$LedgerEventsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.ledgerEvents.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$LedgerEventsTableFilterComposer
    extends Composer<_$AppDatabase, $LedgerEventsTable> {
  $$LedgerEventsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get eventId => $composableBuilder(
    column: $table.eventId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get eventType => $composableBuilder(
    column: $table.eventType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get deviceId => $composableBuilder(
    column: $table.deviceId,
    builder: (column) => ColumnFilters(column),
  );

  ColumnWithTypeConverterFilters<
    Map<String, dynamic>,
    Map<String, dynamic>,
    String
  >
  get eventData => $composableBuilder(
    column: $table.eventData,
    builder: (column) => ColumnWithTypeConverterFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get previousEventHash => $composableBuilder(
    column: $table.previousEventHash,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get hash => $composableBuilder(
    column: $table.hash,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LedgerEventsTableOrderingComposer
    extends Composer<_$AppDatabase, $LedgerEventsTable> {
  $$LedgerEventsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get eventId => $composableBuilder(
    column: $table.eventId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get eventType => $composableBuilder(
    column: $table.eventType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get entityId => $composableBuilder(
    column: $table.entityId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get deviceId => $composableBuilder(
    column: $table.deviceId,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get eventData => $composableBuilder(
    column: $table.eventData,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get previousEventHash => $composableBuilder(
    column: $table.previousEventHash,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get hash => $composableBuilder(
    column: $table.hash,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LedgerEventsTableAnnotationComposer
    extends Composer<_$AppDatabase, $LedgerEventsTable> {
  $$LedgerEventsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get eventId =>
      $composableBuilder(column: $table.eventId, builder: (column) => column);

  GeneratedColumn<String> get eventType =>
      $composableBuilder(column: $table.eventType, builder: (column) => column);

  GeneratedColumn<String> get entityType => $composableBuilder(
    column: $table.entityType,
    builder: (column) => column,
  );

  GeneratedColumn<String> get entityId =>
      $composableBuilder(column: $table.entityId, builder: (column) => column);

  GeneratedColumn<String> get deviceId =>
      $composableBuilder(column: $table.deviceId, builder: (column) => column);

  GeneratedColumnWithTypeConverter<Map<String, dynamic>, String>
  get eventData =>
      $composableBuilder(column: $table.eventData, builder: (column) => column);

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  GeneratedColumn<int> get lamportClock => $composableBuilder(
    column: $table.lamportClock,
    builder: (column) => column,
  );

  GeneratedColumn<String> get versionVector => $composableBuilder(
    column: $table.versionVector,
    builder: (column) => column,
  );

  GeneratedColumn<String> get previousEventHash => $composableBuilder(
    column: $table.previousEventHash,
    builder: (column) => column,
  );

  GeneratedColumn<String> get hash =>
      $composableBuilder(column: $table.hash, builder: (column) => column);

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$LedgerEventsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $LedgerEventsTable,
          LedgerEvent,
          $$LedgerEventsTableFilterComposer,
          $$LedgerEventsTableOrderingComposer,
          $$LedgerEventsTableAnnotationComposer,
          $$LedgerEventsTableCreateCompanionBuilder,
          $$LedgerEventsTableUpdateCompanionBuilder,
          (LedgerEvent, $$LedgerEventsTableReferences),
          LedgerEvent,
          PrefetchHooks Function({bool userId})
        > {
  $$LedgerEventsTableTableManager(_$AppDatabase db, $LedgerEventsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$LedgerEventsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$LedgerEventsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$LedgerEventsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> eventId = const Value.absent(),
                Value<String> eventType = const Value.absent(),
                Value<String> entityType = const Value.absent(),
                Value<String> entityId = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String?> deviceId = const Value.absent(),
                Value<Map<String, dynamic>> eventData = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<String?> previousEventHash = const Value.absent(),
                Value<String?> hash = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LedgerEventsCompanion(
                eventId: eventId,
                eventType: eventType,
                entityType: entityType,
                entityId: entityId,
                userId: userId,
                deviceId: deviceId,
                eventData: eventData,
                timestamp: timestamp,
                lamportClock: lamportClock,
                versionVector: versionVector,
                previousEventHash: previousEventHash,
                hash: hash,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String eventId,
                required String eventType,
                required String entityType,
                required String entityId,
                required String userId,
                Value<String?> deviceId = const Value.absent(),
                required Map<String, dynamic> eventData,
                Value<DateTime> timestamp = const Value.absent(),
                Value<int> lamportClock = const Value.absent(),
                Value<String?> versionVector = const Value.absent(),
                Value<String?> previousEventHash = const Value.absent(),
                Value<String?> hash = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => LedgerEventsCompanion.insert(
                eventId: eventId,
                eventType: eventType,
                entityType: entityType,
                entityId: entityId,
                userId: userId,
                deviceId: deviceId,
                eventData: eventData,
                timestamp: timestamp,
                lamportClock: lamportClock,
                versionVector: versionVector,
                previousEventHash: previousEventHash,
                hash: hash,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$LedgerEventsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable: $$LedgerEventsTableReferences
                                    ._userIdTable(db),
                                referencedColumn: $$LedgerEventsTableReferences
                                    ._userIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$LedgerEventsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $LedgerEventsTable,
      LedgerEvent,
      $$LedgerEventsTableFilterComposer,
      $$LedgerEventsTableOrderingComposer,
      $$LedgerEventsTableAnnotationComposer,
      $$LedgerEventsTableCreateCompanionBuilder,
      $$LedgerEventsTableUpdateCompanionBuilder,
      (LedgerEvent, $$LedgerEventsTableReferences),
      LedgerEvent,
      PrefetchHooks Function({bool userId})
    >;
typedef $$BudgetHealthSnapshotsTableCreateCompanionBuilder =
    BudgetHealthSnapshotsCompanion Function({
      required String id,
      required String userId,
      required double overallScore,
      required String metricsJson,
      Value<DateTime> timestamp,
      Value<int> rowid,
    });
typedef $$BudgetHealthSnapshotsTableUpdateCompanionBuilder =
    BudgetHealthSnapshotsCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<double> overallScore,
      Value<String> metricsJson,
      Value<DateTime> timestamp,
      Value<int> rowid,
    });

final class $$BudgetHealthSnapshotsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $BudgetHealthSnapshotsTable,
          BudgetHealthSnapshot
        > {
  $$BudgetHealthSnapshotsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.budgetHealthSnapshots.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$BudgetHealthSnapshotsTableFilterComposer
    extends Composer<_$AppDatabase, $BudgetHealthSnapshotsTable> {
  $$BudgetHealthSnapshotsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<double> get overallScore => $composableBuilder(
    column: $table.overallScore,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get metricsJson => $composableBuilder(
    column: $table.metricsJson,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BudgetHealthSnapshotsTableOrderingComposer
    extends Composer<_$AppDatabase, $BudgetHealthSnapshotsTable> {
  $$BudgetHealthSnapshotsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<double> get overallScore => $composableBuilder(
    column: $table.overallScore,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get metricsJson => $composableBuilder(
    column: $table.metricsJson,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get timestamp => $composableBuilder(
    column: $table.timestamp,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BudgetHealthSnapshotsTableAnnotationComposer
    extends Composer<_$AppDatabase, $BudgetHealthSnapshotsTable> {
  $$BudgetHealthSnapshotsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<double> get overallScore => $composableBuilder(
    column: $table.overallScore,
    builder: (column) => column,
  );

  GeneratedColumn<String> get metricsJson => $composableBuilder(
    column: $table.metricsJson,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get timestamp =>
      $composableBuilder(column: $table.timestamp, builder: (column) => column);

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$BudgetHealthSnapshotsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $BudgetHealthSnapshotsTable,
          BudgetHealthSnapshot,
          $$BudgetHealthSnapshotsTableFilterComposer,
          $$BudgetHealthSnapshotsTableOrderingComposer,
          $$BudgetHealthSnapshotsTableAnnotationComposer,
          $$BudgetHealthSnapshotsTableCreateCompanionBuilder,
          $$BudgetHealthSnapshotsTableUpdateCompanionBuilder,
          (BudgetHealthSnapshot, $$BudgetHealthSnapshotsTableReferences),
          BudgetHealthSnapshot,
          PrefetchHooks Function({bool userId})
        > {
  $$BudgetHealthSnapshotsTableTableManager(
    _$AppDatabase db,
    $BudgetHealthSnapshotsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$BudgetHealthSnapshotsTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$BudgetHealthSnapshotsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$BudgetHealthSnapshotsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<double> overallScore = const Value.absent(),
                Value<String> metricsJson = const Value.absent(),
                Value<DateTime> timestamp = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BudgetHealthSnapshotsCompanion(
                id: id,
                userId: userId,
                overallScore: overallScore,
                metricsJson: metricsJson,
                timestamp: timestamp,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required double overallScore,
                required String metricsJson,
                Value<DateTime> timestamp = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => BudgetHealthSnapshotsCompanion.insert(
                id: id,
                userId: userId,
                overallScore: overallScore,
                metricsJson: metricsJson,
                timestamp: timestamp,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$BudgetHealthSnapshotsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable:
                                    $$BudgetHealthSnapshotsTableReferences
                                        ._userIdTable(db),
                                referencedColumn:
                                    $$BudgetHealthSnapshotsTableReferences
                                        ._userIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$BudgetHealthSnapshotsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $BudgetHealthSnapshotsTable,
      BudgetHealthSnapshot,
      $$BudgetHealthSnapshotsTableFilterComposer,
      $$BudgetHealthSnapshotsTableOrderingComposer,
      $$BudgetHealthSnapshotsTableAnnotationComposer,
      $$BudgetHealthSnapshotsTableCreateCompanionBuilder,
      $$BudgetHealthSnapshotsTableUpdateCompanionBuilder,
      (BudgetHealthSnapshot, $$BudgetHealthSnapshotsTableReferences),
      BudgetHealthSnapshot,
      PrefetchHooks Function({bool userId})
    >;
typedef $$CanonicalLedgerTableCreateCompanionBuilder =
    CanonicalLedgerCompanion Function({
      required String id,
      required String userId,
      required String source,
      Value<String?> sourceReference,
      required int amount,
      Value<String> currency,
      required DateTime bookingDate,
      Value<String?> description,
      Value<String> verificationStatus,
      Value<String?> derivedExpenseId,
      Value<String?> payloadHash,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });
typedef $$CanonicalLedgerTableUpdateCompanionBuilder =
    CanonicalLedgerCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String> source,
      Value<String?> sourceReference,
      Value<int> amount,
      Value<String> currency,
      Value<DateTime> bookingDate,
      Value<String?> description,
      Value<String> verificationStatus,
      Value<String?> derivedExpenseId,
      Value<String?> payloadHash,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> rowid,
    });

final class $$CanonicalLedgerTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $CanonicalLedgerTable,
          CanonicalLedgerData
        > {
  $$CanonicalLedgerTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.canonicalLedger.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $ExpensesTable _derivedExpenseIdTable(_$AppDatabase db) =>
      db.expenses.createAlias(
        $_aliasNameGenerator(
          db.canonicalLedger.derivedExpenseId,
          db.expenses.id,
        ),
      );

  $$ExpensesTableProcessedTableManager? get derivedExpenseId {
    final $_column = $_itemColumn<String>('derived_expense_id');
    if ($_column == null) return null;
    final manager = $$ExpensesTableTableManager(
      $_db,
      $_db.expenses,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_derivedExpenseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$CanonicalLedgerTableFilterComposer
    extends Composer<_$AppDatabase, $CanonicalLedgerTable> {
  $$CanonicalLedgerTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get sourceReference => $composableBuilder(
    column: $table.sourceReference,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get bookingDate => $composableBuilder(
    column: $table.bookingDate,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get verificationStatus => $composableBuilder(
    column: $table.verificationStatus,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get payloadHash => $composableBuilder(
    column: $table.payloadHash,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ExpensesTableFilterComposer get derivedExpenseId {
    final $$ExpensesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.derivedExpenseId,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableFilterComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CanonicalLedgerTableOrderingComposer
    extends Composer<_$AppDatabase, $CanonicalLedgerTable> {
  $$CanonicalLedgerTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get source => $composableBuilder(
    column: $table.source,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get sourceReference => $composableBuilder(
    column: $table.sourceReference,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get currency => $composableBuilder(
    column: $table.currency,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get bookingDate => $composableBuilder(
    column: $table.bookingDate,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get verificationStatus => $composableBuilder(
    column: $table.verificationStatus,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get payloadHash => $composableBuilder(
    column: $table.payloadHash,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ExpensesTableOrderingComposer get derivedExpenseId {
    final $$ExpensesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.derivedExpenseId,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableOrderingComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CanonicalLedgerTableAnnotationComposer
    extends Composer<_$AppDatabase, $CanonicalLedgerTable> {
  $$CanonicalLedgerTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get source =>
      $composableBuilder(column: $table.source, builder: (column) => column);

  GeneratedColumn<String> get sourceReference => $composableBuilder(
    column: $table.sourceReference,
    builder: (column) => column,
  );

  GeneratedColumn<int> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<String> get currency =>
      $composableBuilder(column: $table.currency, builder: (column) => column);

  GeneratedColumn<DateTime> get bookingDate => $composableBuilder(
    column: $table.bookingDate,
    builder: (column) => column,
  );

  GeneratedColumn<String> get description => $composableBuilder(
    column: $table.description,
    builder: (column) => column,
  );

  GeneratedColumn<String> get verificationStatus => $composableBuilder(
    column: $table.verificationStatus,
    builder: (column) => column,
  );

  GeneratedColumn<String> get payloadHash => $composableBuilder(
    column: $table.payloadHash,
    builder: (column) => column,
  );

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$ExpensesTableAnnotationComposer get derivedExpenseId {
    final $$ExpensesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.derivedExpenseId,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableAnnotationComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CanonicalLedgerTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CanonicalLedgerTable,
          CanonicalLedgerData,
          $$CanonicalLedgerTableFilterComposer,
          $$CanonicalLedgerTableOrderingComposer,
          $$CanonicalLedgerTableAnnotationComposer,
          $$CanonicalLedgerTableCreateCompanionBuilder,
          $$CanonicalLedgerTableUpdateCompanionBuilder,
          (CanonicalLedgerData, $$CanonicalLedgerTableReferences),
          CanonicalLedgerData,
          PrefetchHooks Function({bool userId, bool derivedExpenseId})
        > {
  $$CanonicalLedgerTableTableManager(
    _$AppDatabase db,
    $CanonicalLedgerTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CanonicalLedgerTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CanonicalLedgerTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CanonicalLedgerTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> source = const Value.absent(),
                Value<String?> sourceReference = const Value.absent(),
                Value<int> amount = const Value.absent(),
                Value<String> currency = const Value.absent(),
                Value<DateTime> bookingDate = const Value.absent(),
                Value<String?> description = const Value.absent(),
                Value<String> verificationStatus = const Value.absent(),
                Value<String?> derivedExpenseId = const Value.absent(),
                Value<String?> payloadHash = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CanonicalLedgerCompanion(
                id: id,
                userId: userId,
                source: source,
                sourceReference: sourceReference,
                amount: amount,
                currency: currency,
                bookingDate: bookingDate,
                description: description,
                verificationStatus: verificationStatus,
                derivedExpenseId: derivedExpenseId,
                payloadHash: payloadHash,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required String source,
                Value<String?> sourceReference = const Value.absent(),
                required int amount,
                Value<String> currency = const Value.absent(),
                required DateTime bookingDate,
                Value<String?> description = const Value.absent(),
                Value<String> verificationStatus = const Value.absent(),
                Value<String?> derivedExpenseId = const Value.absent(),
                Value<String?> payloadHash = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => CanonicalLedgerCompanion.insert(
                id: id,
                userId: userId,
                source: source,
                sourceReference: sourceReference,
                amount: amount,
                currency: currency,
                bookingDate: bookingDate,
                description: description,
                verificationStatus: verificationStatus,
                derivedExpenseId: derivedExpenseId,
                payloadHash: payloadHash,
                createdAt: createdAt,
                updatedAt: updatedAt,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$CanonicalLedgerTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({userId = false, derivedExpenseId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable:
                                    $$CanonicalLedgerTableReferences
                                        ._userIdTable(db),
                                referencedColumn:
                                    $$CanonicalLedgerTableReferences
                                        ._userIdTable(db)
                                        .id,
                              )
                              as T;
                    }
                    if (derivedExpenseId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.derivedExpenseId,
                                referencedTable:
                                    $$CanonicalLedgerTableReferences
                                        ._derivedExpenseIdTable(db),
                                referencedColumn:
                                    $$CanonicalLedgerTableReferences
                                        ._derivedExpenseIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$CanonicalLedgerTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CanonicalLedgerTable,
      CanonicalLedgerData,
      $$CanonicalLedgerTableFilterComposer,
      $$CanonicalLedgerTableOrderingComposer,
      $$CanonicalLedgerTableAnnotationComposer,
      $$CanonicalLedgerTableCreateCompanionBuilder,
      $$CanonicalLedgerTableUpdateCompanionBuilder,
      (CanonicalLedgerData, $$CanonicalLedgerTableReferences),
      CanonicalLedgerData,
      PrefetchHooks Function({bool userId, bool derivedExpenseId})
    >;
typedef $$UserConsentsTableCreateCompanionBuilder =
    UserConsentsCompanion Function({
      required String id,
      required String userId,
      required String scope,
      Value<String> status,
      Value<DateTime> grantedAt,
      Value<DateTime?> expiresAt,
      Value<String?> evidenceJson,
      Value<int> rowid,
    });
typedef $$UserConsentsTableUpdateCompanionBuilder =
    UserConsentsCompanion Function({
      Value<String> id,
      Value<String> userId,
      Value<String> scope,
      Value<String> status,
      Value<DateTime> grantedAt,
      Value<DateTime?> expiresAt,
      Value<String?> evidenceJson,
      Value<int> rowid,
    });

final class $$UserConsentsTableReferences
    extends BaseReferences<_$AppDatabase, $UserConsentsTable, UserConsent> {
  $$UserConsentsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $UsersTable _userIdTable(_$AppDatabase db) => db.users.createAlias(
    $_aliasNameGenerator(db.userConsents.userId, db.users.id),
  );

  $$UsersTableProcessedTableManager get userId {
    final $_column = $_itemColumn<String>('user_id')!;

    final manager = $$UsersTableTableManager(
      $_db,
      $_db.users,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_userIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$UserConsentsTableFilterComposer
    extends Composer<_$AppDatabase, $UserConsentsTable> {
  $$UserConsentsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get scope => $composableBuilder(
    column: $table.scope,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get grantedAt => $composableBuilder(
    column: $table.grantedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get evidenceJson => $composableBuilder(
    column: $table.evidenceJson,
    builder: (column) => ColumnFilters(column),
  );

  $$UsersTableFilterComposer get userId {
    final $$UsersTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableFilterComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserConsentsTableOrderingComposer
    extends Composer<_$AppDatabase, $UserConsentsTable> {
  $$UserConsentsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get scope => $composableBuilder(
    column: $table.scope,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get grantedAt => $composableBuilder(
    column: $table.grantedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get expiresAt => $composableBuilder(
    column: $table.expiresAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get evidenceJson => $composableBuilder(
    column: $table.evidenceJson,
    builder: (column) => ColumnOrderings(column),
  );

  $$UsersTableOrderingComposer get userId {
    final $$UsersTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableOrderingComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserConsentsTableAnnotationComposer
    extends Composer<_$AppDatabase, $UserConsentsTable> {
  $$UserConsentsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get scope =>
      $composableBuilder(column: $table.scope, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get grantedAt =>
      $composableBuilder(column: $table.grantedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get expiresAt =>
      $composableBuilder(column: $table.expiresAt, builder: (column) => column);

  GeneratedColumn<String> get evidenceJson => $composableBuilder(
    column: $table.evidenceJson,
    builder: (column) => column,
  );

  $$UsersTableAnnotationComposer get userId {
    final $$UsersTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.userId,
      referencedTable: $db.users,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$UsersTableAnnotationComposer(
            $db: $db,
            $table: $db.users,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$UserConsentsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $UserConsentsTable,
          UserConsent,
          $$UserConsentsTableFilterComposer,
          $$UserConsentsTableOrderingComposer,
          $$UserConsentsTableAnnotationComposer,
          $$UserConsentsTableCreateCompanionBuilder,
          $$UserConsentsTableUpdateCompanionBuilder,
          (UserConsent, $$UserConsentsTableReferences),
          UserConsent,
          PrefetchHooks Function({bool userId})
        > {
  $$UserConsentsTableTableManager(_$AppDatabase db, $UserConsentsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$UserConsentsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$UserConsentsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$UserConsentsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> userId = const Value.absent(),
                Value<String> scope = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime> grantedAt = const Value.absent(),
                Value<DateTime?> expiresAt = const Value.absent(),
                Value<String?> evidenceJson = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserConsentsCompanion(
                id: id,
                userId: userId,
                scope: scope,
                status: status,
                grantedAt: grantedAt,
                expiresAt: expiresAt,
                evidenceJson: evidenceJson,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String userId,
                required String scope,
                Value<String> status = const Value.absent(),
                Value<DateTime> grantedAt = const Value.absent(),
                Value<DateTime?> expiresAt = const Value.absent(),
                Value<String?> evidenceJson = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => UserConsentsCompanion.insert(
                id: id,
                userId: userId,
                scope: scope,
                status: status,
                grantedAt: grantedAt,
                expiresAt: expiresAt,
                evidenceJson: evidenceJson,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$UserConsentsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({userId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (userId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.userId,
                                referencedTable: $$UserConsentsTableReferences
                                    ._userIdTable(db),
                                referencedColumn: $$UserConsentsTableReferences
                                    ._userIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$UserConsentsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $UserConsentsTable,
      UserConsent,
      $$UserConsentsTableFilterComposer,
      $$UserConsentsTableOrderingComposer,
      $$UserConsentsTableAnnotationComposer,
      $$UserConsentsTableCreateCompanionBuilder,
      $$UserConsentsTableUpdateCompanionBuilder,
      (UserConsent, $$UserConsentsTableReferences),
      UserConsent,
      PrefetchHooks Function({bool userId})
    >;
typedef $$FinancialIngestionLogsTableCreateCompanionBuilder =
    FinancialIngestionLogsCompanion Function({
      required String id,
      required String provider,
      required String status,
      Value<DateTime> startedAt,
      Value<DateTime?> completedAt,
      Value<int?> recordsCount,
      Value<String?> errorMessage,
      Value<int> rowid,
    });
typedef $$FinancialIngestionLogsTableUpdateCompanionBuilder =
    FinancialIngestionLogsCompanion Function({
      Value<String> id,
      Value<String> provider,
      Value<String> status,
      Value<DateTime> startedAt,
      Value<DateTime?> completedAt,
      Value<int?> recordsCount,
      Value<String?> errorMessage,
      Value<int> rowid,
    });

class $$FinancialIngestionLogsTableFilterComposer
    extends Composer<_$AppDatabase, $FinancialIngestionLogsTable> {
  $$FinancialIngestionLogsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get provider => $composableBuilder(
    column: $table.provider,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get recordsCount => $composableBuilder(
    column: $table.recordsCount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get errorMessage => $composableBuilder(
    column: $table.errorMessage,
    builder: (column) => ColumnFilters(column),
  );
}

class $$FinancialIngestionLogsTableOrderingComposer
    extends Composer<_$AppDatabase, $FinancialIngestionLogsTable> {
  $$FinancialIngestionLogsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get provider => $composableBuilder(
    column: $table.provider,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get status => $composableBuilder(
    column: $table.status,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get startedAt => $composableBuilder(
    column: $table.startedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get recordsCount => $composableBuilder(
    column: $table.recordsCount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get errorMessage => $composableBuilder(
    column: $table.errorMessage,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$FinancialIngestionLogsTableAnnotationComposer
    extends Composer<_$AppDatabase, $FinancialIngestionLogsTable> {
  $$FinancialIngestionLogsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get provider =>
      $composableBuilder(column: $table.provider, builder: (column) => column);

  GeneratedColumn<String> get status =>
      $composableBuilder(column: $table.status, builder: (column) => column);

  GeneratedColumn<DateTime> get startedAt =>
      $composableBuilder(column: $table.startedAt, builder: (column) => column);

  GeneratedColumn<DateTime> get completedAt => $composableBuilder(
    column: $table.completedAt,
    builder: (column) => column,
  );

  GeneratedColumn<int> get recordsCount => $composableBuilder(
    column: $table.recordsCount,
    builder: (column) => column,
  );

  GeneratedColumn<String> get errorMessage => $composableBuilder(
    column: $table.errorMessage,
    builder: (column) => column,
  );
}

class $$FinancialIngestionLogsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $FinancialIngestionLogsTable,
          FinancialIngestionLog,
          $$FinancialIngestionLogsTableFilterComposer,
          $$FinancialIngestionLogsTableOrderingComposer,
          $$FinancialIngestionLogsTableAnnotationComposer,
          $$FinancialIngestionLogsTableCreateCompanionBuilder,
          $$FinancialIngestionLogsTableUpdateCompanionBuilder,
          (
            FinancialIngestionLog,
            BaseReferences<
              _$AppDatabase,
              $FinancialIngestionLogsTable,
              FinancialIngestionLog
            >,
          ),
          FinancialIngestionLog,
          PrefetchHooks Function()
        > {
  $$FinancialIngestionLogsTableTableManager(
    _$AppDatabase db,
    $FinancialIngestionLogsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$FinancialIngestionLogsTableFilterComposer(
                $db: db,
                $table: table,
              ),
          createOrderingComposer: () =>
              $$FinancialIngestionLogsTableOrderingComposer(
                $db: db,
                $table: table,
              ),
          createComputedFieldComposer: () =>
              $$FinancialIngestionLogsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> provider = const Value.absent(),
                Value<String> status = const Value.absent(),
                Value<DateTime> startedAt = const Value.absent(),
                Value<DateTime?> completedAt = const Value.absent(),
                Value<int?> recordsCount = const Value.absent(),
                Value<String?> errorMessage = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FinancialIngestionLogsCompanion(
                id: id,
                provider: provider,
                status: status,
                startedAt: startedAt,
                completedAt: completedAt,
                recordsCount: recordsCount,
                errorMessage: errorMessage,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String provider,
                required String status,
                Value<DateTime> startedAt = const Value.absent(),
                Value<DateTime?> completedAt = const Value.absent(),
                Value<int?> recordsCount = const Value.absent(),
                Value<String?> errorMessage = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => FinancialIngestionLogsCompanion.insert(
                id: id,
                provider: provider,
                status: status,
                startedAt: startedAt,
                completedAt: completedAt,
                recordsCount: recordsCount,
                errorMessage: errorMessage,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$FinancialIngestionLogsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $FinancialIngestionLogsTable,
      FinancialIngestionLog,
      $$FinancialIngestionLogsTableFilterComposer,
      $$FinancialIngestionLogsTableOrderingComposer,
      $$FinancialIngestionLogsTableAnnotationComposer,
      $$FinancialIngestionLogsTableCreateCompanionBuilder,
      $$FinancialIngestionLogsTableUpdateCompanionBuilder,
      (
        FinancialIngestionLog,
        BaseReferences<
          _$AppDatabase,
          $FinancialIngestionLogsTable,
          FinancialIngestionLog
        >,
      ),
      FinancialIngestionLog,
      PrefetchHooks Function()
    >;
typedef $$SplitTransactionsTableCreateCompanionBuilder =
    SplitTransactionsCompanion Function({
      required String id,
      required String expenseId,
      required String semiBudgetId,
      required int amount,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<int> rowid,
    });
typedef $$SplitTransactionsTableUpdateCompanionBuilder =
    SplitTransactionsCompanion Function({
      Value<String> id,
      Value<String> expenseId,
      Value<String> semiBudgetId,
      Value<int> amount,
      Value<String?> notes,
      Value<DateTime> createdAt,
      Value<DateTime> updatedAt,
      Value<int> revision,
      Value<String> syncState,
      Value<int> rowid,
    });

final class $$SplitTransactionsTableReferences
    extends
        BaseReferences<
          _$AppDatabase,
          $SplitTransactionsTable,
          SplitTransaction
        > {
  $$SplitTransactionsTableReferences(
    super.$_db,
    super.$_table,
    super.$_typedResult,
  );

  static $ExpensesTable _expenseIdTable(_$AppDatabase db) =>
      db.expenses.createAlias(
        $_aliasNameGenerator(db.splitTransactions.expenseId, db.expenses.id),
      );

  $$ExpensesTableProcessedTableManager get expenseId {
    final $_column = $_itemColumn<String>('expense_id')!;

    final manager = $$ExpensesTableTableManager(
      $_db,
      $_db.expenses,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_expenseIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }

  static $SemiBudgetsTable _semiBudgetIdTable(_$AppDatabase db) =>
      db.semiBudgets.createAlias(
        $_aliasNameGenerator(
          db.splitTransactions.semiBudgetId,
          db.semiBudgets.id,
        ),
      );

  $$SemiBudgetsTableProcessedTableManager get semiBudgetId {
    final $_column = $_itemColumn<String>('semi_budget_id')!;

    final manager = $$SemiBudgetsTableTableManager(
      $_db,
      $_db.semiBudgets,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_semiBudgetIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$SplitTransactionsTableFilterComposer
    extends Composer<_$AppDatabase, $SplitTransactionsTable> {
  $$SplitTransactionsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnFilters(column),
  );

  $$ExpensesTableFilterComposer get expenseId {
    final $$ExpensesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.expenseId,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableFilterComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SemiBudgetsTableFilterComposer get semiBudgetId {
    final $$SemiBudgetsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.semiBudgetId,
      referencedTable: $db.semiBudgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SemiBudgetsTableFilterComposer(
            $db: $db,
            $table: $db.semiBudgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SplitTransactionsTableOrderingComposer
    extends Composer<_$AppDatabase, $SplitTransactionsTable> {
  $$SplitTransactionsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<String> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get amount => $composableBuilder(
    column: $table.amount,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get notes => $composableBuilder(
    column: $table.notes,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<DateTime> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get revision => $composableBuilder(
    column: $table.revision,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get syncState => $composableBuilder(
    column: $table.syncState,
    builder: (column) => ColumnOrderings(column),
  );

  $$ExpensesTableOrderingComposer get expenseId {
    final $$ExpensesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.expenseId,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableOrderingComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SemiBudgetsTableOrderingComposer get semiBudgetId {
    final $$SemiBudgetsTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.semiBudgetId,
      referencedTable: $db.semiBudgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SemiBudgetsTableOrderingComposer(
            $db: $db,
            $table: $db.semiBudgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SplitTransactionsTableAnnotationComposer
    extends Composer<_$AppDatabase, $SplitTransactionsTable> {
  $$SplitTransactionsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<String> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<int> get amount =>
      $composableBuilder(column: $table.amount, builder: (column) => column);

  GeneratedColumn<String> get notes =>
      $composableBuilder(column: $table.notes, builder: (column) => column);

  GeneratedColumn<DateTime> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<DateTime> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  GeneratedColumn<int> get revision =>
      $composableBuilder(column: $table.revision, builder: (column) => column);

  GeneratedColumn<String> get syncState =>
      $composableBuilder(column: $table.syncState, builder: (column) => column);

  $$ExpensesTableAnnotationComposer get expenseId {
    final $$ExpensesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.expenseId,
      referencedTable: $db.expenses,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$ExpensesTableAnnotationComposer(
            $db: $db,
            $table: $db.expenses,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }

  $$SemiBudgetsTableAnnotationComposer get semiBudgetId {
    final $$SemiBudgetsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.semiBudgetId,
      referencedTable: $db.semiBudgets,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SemiBudgetsTableAnnotationComposer(
            $db: $db,
            $table: $db.semiBudgets,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$SplitTransactionsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SplitTransactionsTable,
          SplitTransaction,
          $$SplitTransactionsTableFilterComposer,
          $$SplitTransactionsTableOrderingComposer,
          $$SplitTransactionsTableAnnotationComposer,
          $$SplitTransactionsTableCreateCompanionBuilder,
          $$SplitTransactionsTableUpdateCompanionBuilder,
          (SplitTransaction, $$SplitTransactionsTableReferences),
          SplitTransaction,
          PrefetchHooks Function({bool expenseId, bool semiBudgetId})
        > {
  $$SplitTransactionsTableTableManager(
    _$AppDatabase db,
    $SplitTransactionsTable table,
  ) : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SplitTransactionsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SplitTransactionsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SplitTransactionsTableAnnotationComposer(
                $db: db,
                $table: table,
              ),
          updateCompanionCallback:
              ({
                Value<String> id = const Value.absent(),
                Value<String> expenseId = const Value.absent(),
                Value<String> semiBudgetId = const Value.absent(),
                Value<int> amount = const Value.absent(),
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SplitTransactionsCompanion(
                id: id,
                expenseId: expenseId,
                semiBudgetId: semiBudgetId,
                amount: amount,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                rowid: rowid,
              ),
          createCompanionCallback:
              ({
                required String id,
                required String expenseId,
                required String semiBudgetId,
                required int amount,
                Value<String?> notes = const Value.absent(),
                Value<DateTime> createdAt = const Value.absent(),
                Value<DateTime> updatedAt = const Value.absent(),
                Value<int> revision = const Value.absent(),
                Value<String> syncState = const Value.absent(),
                Value<int> rowid = const Value.absent(),
              }) => SplitTransactionsCompanion.insert(
                id: id,
                expenseId: expenseId,
                semiBudgetId: semiBudgetId,
                amount: amount,
                notes: notes,
                createdAt: createdAt,
                updatedAt: updatedAt,
                revision: revision,
                syncState: syncState,
                rowid: rowid,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) => (
                  e.readTable(table),
                  $$SplitTransactionsTableReferences(db, table, e),
                ),
              )
              .toList(),
          prefetchHooksCallback: ({expenseId = false, semiBudgetId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (expenseId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.expenseId,
                                referencedTable:
                                    $$SplitTransactionsTableReferences
                                        ._expenseIdTable(db),
                                referencedColumn:
                                    $$SplitTransactionsTableReferences
                                        ._expenseIdTable(db)
                                        .id,
                              )
                              as T;
                    }
                    if (semiBudgetId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.semiBudgetId,
                                referencedTable:
                                    $$SplitTransactionsTableReferences
                                        ._semiBudgetIdTable(db),
                                referencedColumn:
                                    $$SplitTransactionsTableReferences
                                        ._semiBudgetIdTable(db)
                                        .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$SplitTransactionsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SplitTransactionsTable,
      SplitTransaction,
      $$SplitTransactionsTableFilterComposer,
      $$SplitTransactionsTableOrderingComposer,
      $$SplitTransactionsTableAnnotationComposer,
      $$SplitTransactionsTableCreateCompanionBuilder,
      $$SplitTransactionsTableUpdateCompanionBuilder,
      (SplitTransaction, $$SplitTransactionsTableReferences),
      SplitTransaction,
      PrefetchHooks Function({bool expenseId, bool semiBudgetId})
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$UsersTableTableManager get users =>
      $$UsersTableTableManager(_db, _db.users);
  $$BudgetsTableTableManager get budgets =>
      $$BudgetsTableTableManager(_db, _db.budgets);
  $$CategoriesTableTableManager get categories =>
      $$CategoriesTableTableManager(_db, _db.categories);
  $$SemiBudgetsTableTableManager get semiBudgets =>
      $$SemiBudgetsTableTableManager(_db, _db.semiBudgets);
  $$AccountsTableTableManager get accounts =>
      $$AccountsTableTableManager(_db, _db.accounts);
  $$SubCategoriesTableTableManager get subCategories =>
      $$SubCategoriesTableTableManager(_db, _db.subCategories);
  $$ExpensesTableTableManager get expenses =>
      $$ExpensesTableTableManager(_db, _db.expenses);
  $$BudgetMembersTableTableManager get budgetMembers =>
      $$BudgetMembersTableTableManager(_db, _db.budgetMembers);
  $$ActivityLogsTableTableManager get activityLogs =>
      $$ActivityLogsTableTableManager(_db, _db.activityLogs);
  $$AuditLogsTableTableManager get auditLogs =>
      $$AuditLogsTableTableManager(_db, _db.auditLogs);
  $$SyncQueueTableTableManager get syncQueue =>
      $$SyncQueueTableTableManager(_db, _db.syncQueue);
  $$RecurringExpensesTableTableManager get recurringExpenses =>
      $$RecurringExpensesTableTableManager(_db, _db.recurringExpenses);
  $$SubscriptionsTableTableManager get subscriptions =>
      $$SubscriptionsTableTableManager(_db, _db.subscriptions);
  $$SavingsGoalsTableTableManager get savingsGoals =>
      $$SavingsGoalsTableTableManager(_db, _db.savingsGoals);
  $$LocationsTableTableManager get locations =>
      $$LocationsTableTableManager(_db, _db.locations);
  $$GeocodingCacheTableTableManager get geocodingCache =>
      $$GeocodingCacheTableTableManager(_db, _db.geocodingCache);
  $$ExpenseLocationsTableTableManager get expenseLocations =>
      $$ExpenseLocationsTableTableManager(_db, _db.expenseLocations);
  $$RecurringExpenseLocationsTableTableManager get recurringExpenseLocations =>
      $$RecurringExpenseLocationsTableTableManager(
        _db,
        _db.recurringExpenseLocations,
      );
  $$LocationAnalyticsTableTableManager get locationAnalytics =>
      $$LocationAnalyticsTableTableManager(_db, _db.locationAnalytics);
  $$GeofencesTableTableManager get geofences =>
      $$GeofencesTableTableManager(_db, _db.geofences);
  $$GeofenceEventsTableTableManager get geofenceEvents =>
      $$GeofenceEventsTableTableManager(_db, _db.geofenceEvents);
  $$ConflictsTableTableManager get conflicts =>
      $$ConflictsTableTableManager(_db, _db.conflicts);
  $$AuditEventsTableTableManager get auditEvents =>
      $$AuditEventsTableTableManager(_db, _db.auditEvents);
  $$OutboxEventsTableTableManager get outboxEvents =>
      $$OutboxEventsTableTableManager(_db, _db.outboxEvents);
  $$CategoryLearningTableTableManager get categoryLearning =>
      $$CategoryLearningTableTableManager(_db, _db.categoryLearning);
  $$SyncRecoveryStateTableTableManager get syncRecoveryState =>
      $$SyncRecoveryStateTableTableManager(_db, _db.syncRecoveryState);
  $$SyncOperationsLogTableTableManager get syncOperationsLog =>
      $$SyncOperationsLogTableTableManager(_db, _db.syncOperationsLog);
  $$SyncStateTransitionsTableTableManager get syncStateTransitions =>
      $$SyncStateTransitionsTableTableManager(_db, _db.syncStateTransitions);
  $$FamilyGroupsTableTableManager get familyGroups =>
      $$FamilyGroupsTableTableManager(_db, _db.familyGroups);
  $$FamilyContactsTableTableManager get familyContacts =>
      $$FamilyContactsTableTableManager(_db, _db.familyContacts);
  $$FamilyRelationsTableTableManager get familyRelations =>
      $$FamilyRelationsTableTableManager(_db, _db.familyRelations);
  $$KnowledgeArticlesTableTableManager get knowledgeArticles =>
      $$KnowledgeArticlesTableTableManager(_db, _db.knowledgeArticles);
  $$FinancialTipsTableTableManager get financialTips =>
      $$FinancialTipsTableTableManager(_db, _db.financialTips);
  $$AssetsTableTableManager get assets =>
      $$AssetsTableTableManager(_db, _db.assets);
  $$LiabilitiesTableTableManager get liabilities =>
      $$LiabilitiesTableTableManager(_db, _db.liabilities);
  $$ValuationHistoryTableTableManager get valuationHistory =>
      $$ValuationHistoryTableTableManager(_db, _db.valuationHistory);
  $$LedgerEventsTableTableManager get ledgerEvents =>
      $$LedgerEventsTableTableManager(_db, _db.ledgerEvents);
  $$BudgetHealthSnapshotsTableTableManager get budgetHealthSnapshots =>
      $$BudgetHealthSnapshotsTableTableManager(_db, _db.budgetHealthSnapshots);
  $$CanonicalLedgerTableTableManager get canonicalLedger =>
      $$CanonicalLedgerTableTableManager(_db, _db.canonicalLedger);
  $$UserConsentsTableTableManager get userConsents =>
      $$UserConsentsTableTableManager(_db, _db.userConsents);
  $$FinancialIngestionLogsTableTableManager get financialIngestionLogs =>
      $$FinancialIngestionLogsTableTableManager(
        _db,
        _db.financialIngestionLogs,
      );
  $$SplitTransactionsTableTableManager get splitTransactions =>
      $$SplitTransactionsTableTableManager(_db, _db.splitTransactions);
}
