import 'dart:io';
import 'package:flutter/foundation.dart';
import 'package:device_info_plus/device_info_plus.dart';
import 'package:uuid/uuid.dart';
import 'package:supabase_flutter/supabase_flutter.dart';

/// Analytics Event Types
enum AnalyticsEventType {
  // engagement
  appOpen,
  screenView,
  featureUsed,
  
  // growth
  onboardingCompleted,
  trialStarted,
  trialConverted,
  paywallViewed,
  
  // features
  budgetCreated,
  expenseAdded,
  ocrScan,
  insightViewed,
  exportGenerated,
  
  // reliability
  syncError,
  crashDetected,
}

class AnalyticsTrackingService {
  static final AnalyticsTrackingService _instance = AnalyticsTrackingService._internal();
  factory AnalyticsTrackingService() => _instance;
  AnalyticsTrackingService._internal();

  bool _initialized = false;
  
  // simple queue to hold events before init or if offline
  final List<Map<String, dynamic>> _eventQueue = [];
  bool _isQueueProcessing = false;
  
  // Session ID for this run
  final String _sessionId = const Uuid().v4();
  String? _cachedDeviceId;

  /// Initialize the service
  Future<void> initialize() async {
    if (_initialized) return;
    
    // Process any queued events
    _initialized = true;
    _processQueue();
    
    // Log app open
    trackEvent(AnalyticsEventType.appOpen, {
      'timestamp': DateTime.now().toIso8601String(),
      'platform': defaultTargetPlatform.name,
    });
    
    debugPrint('[AnalyticsTrackingService] Initialized');
  }

  /// Compatibility layer for string-based events
  void logEvent(String name, {Map<String, dynamic>? parameters}) {
    trackEvent(AnalyticsEventType.featureUsed, {
      'legacy_event_name': name,
      if (parameters != null) ...parameters,
    });
  }

  /// Track a specific event with properties
  void trackEvent(AnalyticsEventType type, [Map<String, dynamic>? properties]) {
    // Build event with correct column names matching Supabase schema
    final event = <String, dynamic>{
      'event_type': type.name,  // matches column name
      'event_data': properties ?? {},  // matches column name (JSONB)
      // created_at is auto-generated by database
    };

    // Add user_id if logged in (required by table)
    final user = Supabase.instance.client.auth.currentUser;
    if (user != null) {
      event['user_id'] = user.id;
    } else {
      // Skip if no user - table requires user_id
      if (kDebugMode) {
        debugPrint('[Analytics] [${type.name}] Skipped (no user)');
      }
      return;
    }

    // Always log to console in debug
    if (kDebugMode) {
      debugPrint('[Analytics] [${type.name}] $properties');
    }

    _eventQueue.add(event);
    _processQueue();
  }

  /// Track a screen view
  void trackScreen(String screenName) {
    trackEvent(AnalyticsEventType.screenView, {
      'screen_name': screenName,
    });
  }

  /// Set user properties in analytics
  Future<void> setUserProperty(String name, String value) async {
    final user = Supabase.instance.client.auth.currentUser;
    if (user == null) return;

    try {
      await Supabase.instance.client.from('user_properties').upsert({
        'user_id': user.id,
        'property_name': name,
        'property_value': value,
        'updated_at': DateTime.now().toIso8601String(),
      });
      
      if (kDebugMode) {
        debugPrint('[Analytics] Set property: $name = $value');
      }
    } catch (e) {
      if (kDebugMode) {
        debugPrint('[Analytics] Error setting property: $e');
      }
    }
  }

  /// Set user ID for analytics tracking
  Future<void> setUserId(String userId) async {
    await setUserProperty('user_id', userId);
  }

  /// Process the event queue
  Future<void> _processQueue() async {
    if (!_initialized || _isQueueProcessing || _eventQueue.isEmpty) return;
    
    try {
      _isQueueProcessing = true;
      
      // In a real production app, we would batch these and send to Supabase/PostHog/Firebase
      // For now, we'll implement the "Structure" and ready it for Phase 2 (Supabase Table)
      
      while (_eventQueue.isNotEmpty) {
        final event = _eventQueue.first;
        
        // Add session and device info if not present
        event['session_id'] ??= _sessionId;
        event['device_id'] ??= await _getDeviceId();

        await Supabase.instance.client
            .from('analytics_events')
            .insert(event);
            
        _eventQueue.removeAt(0);
      }
      
    } catch (e) {
      debugPrint('[Analytics] Sync error: $e');
    } finally {
      _isQueueProcessing = false;
    }
  }

  Future<String?> _getDeviceId() async {
    if (_cachedDeviceId != null) return _cachedDeviceId;
    
    try {
      final deviceInfo = DeviceInfoPlugin();
      if (kIsWeb) {
        _cachedDeviceId = 'web';
      } else if (Platform.isIOS) {
        final iosInfo = await deviceInfo.iosInfo;
        _cachedDeviceId = iosInfo.identifierForVendor;
      } else if (Platform.isAndroid) {
        final androidInfo = await deviceInfo.androidInfo;
        _cachedDeviceId = androidInfo.id;
      } else if (Platform.isMacOS) {
        final macInfo = await deviceInfo.macOsInfo;
        _cachedDeviceId = macInfo.systemGUID;
      }
    } catch (e) {
      debugPrint('Error getting device ID: $e');
    }
    
    return _cachedDeviceId;
  }
}

/// Global instance
final analyticsService = AnalyticsTrackingService();
